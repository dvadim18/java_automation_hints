============================================================================Starting with Git==============================================================================
Git-это распределенная система управления версиями, которая помогает разработчикам отслеживать и записывать изменения в файлах. Это могут быть любые файлы, с которыми вы 
хотите работать, но мы подробнее рассмотрим исходные коды программ. С помощью Git вы можете вернуться к более старой версии вашего проекта, сравнить ее, проанализировать 
и объединить(merge) изменения. This process is called version control.

Git распространяется, то есть он не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, храня данные в папках 
на вашем жестком диске, называемых хранилищем(repository). Это локальный репозиторий, существующий только на вашем жестком диске. Тем не менее, вы можете хранить его 
копию в Интернете, что значительно облегчает работу нескольких человек над одним и тем же проектом. В этом случае это удаленный(remote) репозиторий.

Ряд сервисов предоставляют хостинг для репозиториев Git, среди наиболее известных-GitHub, Codebase, SourceForge, SourceHut, Bitbucket, GitLab и Gitorious, но он был 
приобретен GitLab в 2015 году. Далее мы обсудим только GitHub как наиболее популярный среди этих ресурсов. В любом случае, если вы хотите, вы можете использовать вместо 
этого другие, перечисленные выше.

Git-это бесплатное программное обеспечение с открытым исходным кодом, разработанное в основном на Linux, но оно также поддерживает большинство основных операционных систем, 
включая macOS и Windows. Теперь мы узнаем, как установить Git на эти системы.

2. Linux

You can just open a terminal and install the application using your distribution's package manager. If you have Fedora (or another similar distribution such as RHEL or CentOS), you can use dnf:

$ sudo dnf install git-all
If you have a Debian-based distribution like Ubuntu, try apt:

$ sudo apt install git

Итак, мы успешно установили Git, теперь нам нужно настроить некоторые настройки. Есть довольно много вариантов для игры, но мы настроим самые важные из них: наше имя 
пользователя и адрес электронной почты. Откройте терминал и выполните команды:

git config --global user.name "My Name"
git config --global user.email myEmail@example.com

Теперь каждое наше действие будет помечено нашим именем и адресом электронной почты. Таким образом, пользователи всегда будут знать, кто несет ответственность за те или 
иные изменения: это наводит порядок!

Usually, the installation is successful, but just in case, we recommend you to check that the latest version of Git has actually been installed by running the 
git --version command in the terminal. The result will be the following:

git version 2.17.1
This means that the Git is installed and you can start working with it.

======================================================================Git internal structure===============================================================================
Основной задачей при работе с git является управление версиями проекта. Для этого вам нужно:

- рабочие инструменты, содержащиеся в папке git, которая создается сразу после объявления нового репозитория;
- отслеживание состояния файлов, чтобы понять, на какой стадии работы находится проект сейчас и куда он отправится позже;
- фиксация изменений, внесенных в файлы проекта, после завершения работы.

Thus, three main notions that describe the logic of Git work are git folder, git commit, and git files stages.

1) .git folder

После создания нового репозитория у вас будет .git folder. В папке содержится все необходимое для работы с Git. Вы также можете удалить его, если вам не нужен Git в вашем 
проекте. Файлы проекта останутся на диске.

Вот содержимое типичной .git folder перед первым commit:

- HEAD-это файл, содержащий указатель либо на текущий (для репозитория) branch, либо на текущий commit;
- config – этот файл содержит настройки для вашего репозитория, здесь, например, в репозитории хранится URL-адрес вашего репозитория, ваше имя, адрес электронной почты, 
который вы можете настроить с помощью команды git config после создания репозитория. Каждый раз, когда вы выполняете git config, вы будете ссылаться на этот файл;
- description используется интерфейсом Gitweb для отображения описания репозитория;
- hooks – эта папка содержит сценарии, которые могут быть выполнены на различных этапах выполнения Git. Примером хука может быть скрипт проверки стиля перед отправкой в 
репозиторий;
- info-exclude – файлы, которые вы не хотите включать в репозиторий, описаны здесь.

Вот три основных состояния, в которых могут находиться ваши файлы:

- committed, т. е. файл уже сохранен в вашей локальной базе данных;
- modified, т. е. в файлах есть некоторые несохраненные изменения;
- и подготовленный (staged), т. е. измененный файл помечается для включения в следующий commit.

Итак, соответственно, существуют три основные концепции архитектуры Git: три основных раздела проекта Git.

working directory -> git add -> staging area -> git commit -> repository

Git directory (.git) - это место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, которая копируется при клонировании репозитория с 
другой машины.

Working directory представляет собой копию версии проекта. Файлы распаковываются из сжатой базы данных в каталог Git и помещаются на диск, чтобы вы могли их использовать 
и изменять.

Staging area-это файл, расположенный в вашем каталоге Git, который содержит информацию о том, какие изменения будут внесены в следующий commit. Эта область также 
называется "index", но ее также принято называть stage area. Когда вы добавляете файл, он сначала попадает точно в index, и только после commit он появляется в репозитории.

Подводя итог всему этому, основной подход Git выглядит следующим образом:

- Вы меняете файлы в Working directory.
- Вы добавляете файлы в index, тем самым добавляя их копии в Staging area.
- При коммите файлы из index используются как есть, и этот index сохраняется в вашем каталоге Git (.git).

Вся структура Git в значительной степени основана на необходимости сохранения текущей версии проекта. Представьте, что было бы, если бы у нас этого вообще не было, и как 
неудобно было бы работать с файлами. Если файл был изменен, но возникла необходимость вернуться к предыдущей версии из-за, скажем, неправильных изменений, было бы 
невозможно восстановить статус-кво и исправить ошибку.

Вот почему одной из самых важных концепций в Git является commit, что означает сохранение состояния вашего проекта. Каждый раз, когда вы делаете commit, система запоминает, 
как выглядит каждый файл в этот момент, и сохраняет ссылку на него. Для повышения эффективности, если не было никаких изменений, Git не запоминает эти файлы снова, а только 
создает ссылку на предыдущую версию идентичного файла, который уже сохранен.

Все изменения хранятся в локальной базе данных, которая создается сразу после установки Git на ваш компьютер. Это означает, что вы увидите историю проекта почти мгновенно. 
Если вам нужно просмотреть изменения, внесенные между текущей версией файла и версией, созданной месяц назад, Git может найти файл месячной давности и вычислить изменения 
локально.

При поиске Git ссылается на ранее сохраненную строку. Это означает, что вы не можете просто взять и изменить содержимое файла, не зная об этом Git. Эта функциональность 
встроена в Git на низком уровне. Таким образом, вы не потеряете информацию во время передачи или не получите поврежденный файл без ведома Git.


=======================================================================Local repository====================================================================================
После того, как мы выяснили, что такое Git, для чего он предназначен и как его установить, мы можем создать наш первый репозиторий Git, т. Е. каталог файловой системы, 
содержащий файлы. Как вы видите, репозиторий-это пространство, в котором мы работаем с Git, поэтому в первую очередь мы должны его создать.

Помните два вида хранилищ: локальные и удаленные? Поскольку сначала все делается локально и только потом передается в удаленный доступ, сначала мы должны создать локальный 
репозиторий.

Как вы, возможно, помните, Git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, перейти в папку нашего 
проекта и выполнить команду git init:

$ git init

Это включит приложение в эту конкретную папку и создаст скрытый каталог .git, в котором будут храниться история репозитория и настройки. В результате вы увидите:

Initialized empty Git repository in /path to the folder with the repository / repository_name/.git/

Это означает, что ваше хранилище успешно создано, но оно все еще пусто. Итак, почему бы не добавить несколько файлов?

Теперь вы можете создать файл или использовать уже написанную программу и сохранить ее в каталоге git. Там может быть столько файлов, сколько вы хотите, с различными 
расширениями. Здесь у нас есть два варианта: вы можете либо добавлять файлы по одному с помощью команды git add, либо добавлять все файлы с помощью git add-A:

# adding one concrete file

$ git add my_file.txt

# adding all files from your directory

$ git add -A

Чтобы убедиться, что мы все делаем правильно, а также проверить изменения, вы можете отслеживать статус репозитория с помощью команды git status. Например, сейчас мы 
проверим, что происходит с нашим недавно созданным репозиторием. Запущенный статус git должен давать:

$ git status
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: my_file.txt

Вывод команды показывает, что у нас есть новое хранилище, содержащее файл. Обратите внимание, что вы можете использовать эту команду на любом этапе работы с репозиторием, 
поэтому вы всегда можете проверить, все ли правильно. В выходных данных все еще есть концепции, которые могут быть непонятны, например, Branch master. Мы объясним их в 
следующих темах. Теперь давайте перейдем к заключительному шагу этой темы, который заключается в committe, т. Е. добавлении туда файлов. Для этого мы будем использовать 
команду git commit.

Commit представляет состояние репозитория в определенный момент времени. Таким образом, каждый commit добавляет изменения и облегчает их последующее отслеживание. Чтобы 
зафиксировать изменения, нам нужно хотя бы одно промежуточное изменение, например, добавление новых файлов, как мы делали раньше. После этого мы вводим:

$ git commit -m "First commit."

Эта команда создаст новый commit со всеми промежуточными изменениями. -m означает "message" и "First commit.". это сообщение или, другими словами, комментарий, который вы 
добавляете к commit. Считается хорошей практикой часто совершать и всегда писать содержательные комментарии, так как это облегчает вам и другим людям понимание и 
запоминание того, что вы сделали.


======================================================================Editing the commit===================================================================================
Ранее мы обсуждали, как создать локальный репозиторий, как добавить в него файлы и как зафиксировать изменения. Но что, если изменений будет много и некоторые из них 
окажутся неверными? В этом случае вам нужно уметь отслеживать и исправлять их. Давайте разберемся, как это сделать.

Каждая фиксация имеет свой собственный уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторы, вы можете использовать 
команду git log:

$ git log
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Admin
Date: Fri Sep 18 13:47:20 2020 +0300

    New feature complete

commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Admin
Date: Fri Sep 18 14:33:09 2020 +0300

    Added content to hello.txt

commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Admin
Date: Fri Sep 18 14:50:18 2020 +0300

    Initial commit

Как вы можете видеть, идентификаторы довольно длинные и жуткие, но вам не нужно копировать всю строку, чтобы работать с ними, достаточно первых нескольких символов. Чтобы 
узнать, что нового в commit, мы можем использовать команду git show:

$ git show b10cc123
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Admin
Date: Fri Sep 18 14:33:09 2020 +0300

    Added content to my_file.txt

diff --git a/my_file.txt b/my_file.txt
index e69de29..b546a21 100644
--- a/my_file.txt
+++ b/my_file.txt
@@ -0,0 +1 @@
+Hello, world!

В этом примере показано, когда файл был изменен, кем и какого рода это было изменение: новый текст "Hello, world!". Чтобы увидеть разницу между двумя commit и выяснить, 
где, когда и как она была изменена, вы можете использовать команду git diff:

$ git diff 09bd8cc..ba25c0ff
diff --git a/file.txt b/file.txt
new file mode 100644
index 0000000..e69de29
diff --git a/my_file.txt b/my_file.txt
index e69de29..b546a21 100644
--- a/my_file.txt
+++ b/my_file.txt
@@ -0,0 +1 @@
+Hello, world!

Теперь мы можем найти необходимый коммит и сравнить его с другими коммитами. Но что, если сщььше ошибочен и его необходимо исправить? Здесь есть две возможности. Во-первых, 
если вы совершили коммит и сразу поняли, что это неправильно, вы можете использовать команду commit --amend. Он добавляет все, начиная с последнего commit, в промежуточную 
область и пытается создать новый commit, поэтому вы можете просто ввести git commit. Это позволяет исправить комментарий или добавить отсутствующие файлы в промежуточную 
область.

Если ошибка была допущена несколько коммитов назад и изменения уже были отправлены на сервер, то вам необходимо использовать команду git revert. Эта команда создаст 
commit, который отменит изменения, внесенные в commit с заданным идентификатором:

$ git revert b10cc123

Доступ к последнему commit, отправленному на сервер, можно получить, добавив HEAD в $ git revert без идентификатора:

$ git revert HEAD

При отмене старых коммитов будьте готовы к конфликтам. Они случаются, если файл был изменен другим, более новым commit, и теперь git не может найти строки, которые 
необходимо откатить, поскольку они больше не существуют. Пожалуйста, постарайтесь принять это во внимание.

Существует еще один способ борьбы с ошибочными commit с помощью команды git checkout. Если у вас нет файла, содержащего ошибки, но есть другой commit, в котором ошибка 
еще не была или была исправлена, вы можете получить его с помощью git checkout. Вам нужно написать саму команду, идентификатор commit, который вы хотите удалить, и имя 
файла, в котором было внесено неправильное изменение.

$ git checkout 09bd8cc1 my_file.txt

Let's sum up what we've learned in this topic:

to see what commits were made, you need to remember the following three commands:
"git log" to find out the commit identifier,
"git show" to see a specific commit by its identifier,
"git diff" for comparing commits.

2. to change commits use
"commit --amend" if you noticed the mistake immediately after making a commit,
if changes are already on the server, use "git revert <commit ID>" or "git revert HEAD" for the last commit.
3. to cancel the commit, use the "git checkout command".

=================================================================Working with remote repository============================================================================
Представьте, что вы и команда вашей мечты разрабатываете большой и сложный проект. Вы решили разделить его на части, чтобы каждый мог сосредоточиться на выполнении одной 
из них. И в конце концов, вы планируете объединить усилия. Каков наилучший способ сделать это? Самый простой подход-создать удаленный репозиторий, в который каждый будет 
загружать свои версии. Таким образом, вы не будете сбиты с толку новыми версиями кода и не потеряете важные функции.

Другими словами, когда кто-то завершает одну часть проекта, новые данные загружаются в удаленное хранилище. После того как вы обновите данные, другой член команды может 
загрузить их и продолжить работу над ними.

Существуют полезные команды, git clone, git push и git pull, для загрузки и выгрузки данных оттуда. Давайте посмотрим, как они все работают.

Вы можете начать работу после создания удаленного репозитория, например, на GitHub. Для этого вам следует клонировать репозиторий на свой компьютер. Вы можете сделать это 
с помощью команды git clone:

$ git clone https://github.com/dream_team/project.git

Синтаксис следующий: сначала мы вводим команду git clone, а затем добавляем адрес удаленного репозитория на сервере, в данном случае это репозиторий dream_team на GitHub, 
где есть новый project.git. Таким образом, вы получите весь репозиторий со всем его содержимым. Но в самый первый раз он, естественно, будет пуст.

Круто, теперь у вас есть рабочая зона, и вы можете приступить к кодированию! И тогда у вас будет время, чтобы отправить новые данные на сервер. Для этого вам понадобится 
команда git push.

Git push отправляет данные, то есть commits и branches, на сервер, в удаленное хранилище. То есть каждый раз, когда вы вносите какие-то изменения в код и коммитите их, вы 
можете и должны загружать обновленные данные на сервер. Таким образом, ваши коллеги всегда будут видеть текущую версию кода. И также важно иметь такую резервную копию на 
случай потери данных на вашем компьютере.

Синтаксис команды следующий: git push origin <branch_name>. Это означает, что вы отправляете данные на удаленный сервер (origin) и отправляете их в конкретную ветвь. В 
приведенном ниже примере это основная ветвь:

$ git push origin main

git push <remote_repo> <branch_name>

Если хочешь, можешь запушить на другую ветку. Если такой ветки на сервере нет, то она будет создана. Если вы уже пушили раньше, то новые коммиты будут просто отправлены 
туда, и в этом случае вы можете использовать короткие версии команды: просто git push. И, пожалуйста, не забывайте, что, прежде чем вносить изменения, вы должны сделать 
коммит.

Хорошо, теперь вы перенесли свои изменения на сервер. Но как насчет противоположной ситуации, когда вам нужно загрузить их с сервера? Вы, наверное, уже догадались: вы 
можете клонировать репозиторий еще раз с помощью git clone, но он скопирует все когда-либо внесенные изменения. Что делать, если вас интересуют только последние изменения, 
которые являются более актуальными? Для этого вы должны использовать команду git pull.

Git pull загружает данные с сервера, и только самые последние. Таким образом, вы не запутаетесь в коммитах и будете уверены, что скопировали только самые свежие и 
актуальные из них. Итак, вы просто делаете: git pull origin <branch_name>, т. Е. вы загружаете последние изменения из ветки удаленного репозитория на сервере. В примере 
мы загружаем данные из основной ветки.

$ git pull origin main

Вы можете выбрать все необходимые ветви и использовать короткую версию команды. Просто напишите запрос git, если локальная ветвь уже принадлежит какой-либо удаленной ветви, 
из которой вы загружаете изменения.

Потрясающе, теперь, когда все последние изменения внесены, вы можете начать вносить свои собственные и снова их продвигать. И так далее по кругу, пока проект не будет 
завершен. Однако в крупном проекте с большим количеством постоянных изменений могут возникнуть некоторые проблемы. Давайте обсудим один из наиболее частых из них ниже, 
чтобы понять, почему это происходит и как это можно решить.

Эта проблема рано или поздно возникает, если вы и ваша команда регулярно работаете с git. И это выглядит так: вы делаете новый коммит, пытаетесь запушить его, и git выдает 
вам ошибку git push rejected error. Это происходит с вами, если кто-то внес изменения, а вы еще не сделали pull. Git разработан таким образом, чтобы мы могли совершать commit 
столько раз, сколько захотим, но только локально. Прежде чем отправлять свои коммиты на сервер, вам необходимо сделать pull с него. То есть сделайте git pull, и проблема 
решена!


=============================================================================Git branches==================================================================================
Теперь пришло время выяснить, как организованы копии проектов, которые мы храним с помощью git. В этой теме мы познакомимся с ветвлением, зачем оно нужно и что мы можем с 
ним сделать.

Иногда полезно разрабатывать модули отдельно или создать альтернативную версию проекта, чтобы посмотреть, лучше ли она предыдущей. В таких случаях рекомендуется работать с 
копией исходного проекта, которая называется branch. Ветви имеют свою собственную историю и изменения, изолированные друг от друга, пока вы не решите объединить их. Есть 
несколько причин, по которым это так:

1) уже работающая, стабильная версия кода сохраняется,
2) различные новые функции могут параллельно разрабатываться разными программистами,
3) разработчики могут работать со своими собственными ветвями без риска того, что база кода изменится из-за чужих изменений,
4) в случае сомнений вы можете разработать разные реализации одной и той же идеи в разных ветвях, а затем сравнить их.

Другими словами, ветвление-это возможность разбивать версии одного проекта и работать с ними отдельно.

Как вы создаете branch? Основная ветвь в каждом репозитории называется master branch. Чтобы создать другую ветвь, используйте команду branch <name> :

$ git branch new_branch

Это создаст новую ветвь, которая на данный момент является точной копией основной ветви. Вы можете изменить его позже и получить новую версию кода, не затрагивая основную. 
Поэтому, в случае ошибок и сбоев, просто переключитесь на мастер и продолжайте в нем работать, или, как вариант, создайте другую ветку, потому что их количество не 
ограничено.

Если мы запустим git branch, будет два варианта:

$ git branch
new_branch
* master

Мастер является активной ветвью и поэтому отмечен звездочкой. Но поскольку мы хотим работать с нашим новым branch, нам нужно переключиться на него. Для этого мы используем 
команду git checkout, которая принимает только один параметр: имя нашей новой ветви.

$ git checkout new_branch

Итак, вы перешли в новую ветку, теперь вы можете начать с ней работать. Например, вы можете добавить и закоммитить новый файл документации для новой версии кода проекта.

$ git add new_documentation.txt
$ git commit -m "New documentation version complete!”

Поскольку изменения завершены, мы можем вернуться в главную ветвь:

$ git checkout master

Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим new_documentation.txt файл, потому что мы переключились обратно в главную ветвь, где такого файла не 
существует. В случае, если вам нужно поместить файлы из новой версии в основную, используйте команду git merge. Объединение просто означает применение изменений из новой 
ветви к основной версии проекта.

$ git merge new_branch

Если больше нет смысла хранить новые изменения отдельно, и они уже стали частью мастера, ветвь можно удалить с помощью команды git branch-d, где-d означает удалить:

$ git branch -d new_branch

Конфликты могут возникать при объединении ветвей. Наиболее распространенная ситуация-это когда один файл был закомичен дважды. Давайте рассмотрим конфликт версий более 
подробно. Например, основная ветвь имела initial.file с формулой e = mc^4. Кроме того, существовало еще два branch. В первом был файл с правильной версией формулы e = mc^2, 
а во втором был файл с неправильной версией формулы e = mc^3.

Программист попытался объединить все эти ветви вместе, используя команды merge:

git merge origin/fix-formula-wrong
git merge origin/fix-formula-right

As a result, he received the following error:

Auto-merging initial.file
CONFLICT (content): Merge conflict in initial.file
Automatic merge failed; fix conflicts and then commit the result

А в файле на главной ветке уже была такая формула e = mc^3. Если он отменит все свои изменения, он снова получит формулу e = mc^4, что неверно. В результате его выход 
состоит в том, чтобы исправить формулу руками и зафиксировать уже правильный результат, а именно формулу e = mc^2.

Как вы можете видеть, этот процесс довольно утомителен и может быть очень сложным в крупных проектах. Многие разработчики предпочитают использовать графические клиенты для 
разрешения конфликтов, но это не обязательно для простых, подобных тому, который мы обсуждали здесь.

В любом случае, прежде чем что-то предпринимать, лучше обсудить это со своими коллегами.

Let's sum up what you've learned in this topic:

a copy of the original project is called a branch; to create a branch, use git branch <branch name> command;
to switch between branches, use git checkout command;
merging branches means applying changes from one branch to another; to merge, use git merge command;
use git branch -d to delete a branch;
when merging branches, conflicts may occur; be attentive and keep track of all your actions and the actions of your colleagues if it is a group project.


================================================================================Git rebase=================================================================================
В дополнение к команде git merge существует еще один способ объединения ветвей. Это git rebase. Он используется с той же целью для объединения изменений, внесенных в одной 
ветви, в другую. Однако принципы этих методов различны, у каждого из них есть свои плюсы и минусы. Поэтому в разных ситуациях имеет смысл выбрать одно из двух. Ниже мы 
более подробно проанализируем разницу между этими командами и узнаем, как использовать git rebase.

Разница между этими командами может быть неуловимой на первый взгляд. Итак, давайте рассмотрим простой забавный пример с картинками, чтобы сделать его более понятным. 
Допустим, у нас есть задача сделать красивого рыжего кота с бантиком. Кошка разрабатывается на двух ветвях. В главной ветви мы последовательно рисуем кошку и на последнем 
этапе добавляем к ней бант. А в другой ветке, например, в функции, мы рисуем кошку. Когда мы все нарисуем и раскрасим, мы сможем объединить ветви.

Если мы используем команду git merge, мы получим, как в первой части рисунка, две ветви вместе, и их результатом будет полностью окрашенный кот с бантом. Мы видим всю 
историю развития кошки со всеми этапами.

Теперь давайте вернемся и попробуем использовать git rebase. У нас есть две ветви с различными модификациями cat, и в конце у нас есть одна основная ветвь с окончательной 
версией cat. История умалчивает о том, что там еще была ветка с рыжим котом. Мы просто перенесли то, что нам было нужно, и удалили все, что было между ними.

В этом основное различие между этими командами. Первый объединяет две ветви и хранит всю историю изменений. Таким образом, у нас есть возможность отслеживать каждый наш шаг. 
Недостатком является то, что в такой долгой истории с ветвями легко запутаться.
Вторая команда перемещает только самое важное в целевую ветвь и переписывает историю так, что некоторые ее части просто исчезают. Преимущество команды git rebase в том, что 
мы никогда не заблудимся в коммитах. Это очень удобно и экономично для больших проектов, где вам нужно много кодить и комитить.

В простейшем случае, чтобы применить rebase, вам нужно написать в терминале следующие команды:

$ git checkout feature
$ git rebase master

И если вам нужно чувствовать больше контроля и власти над коммитами, то вы можете это сделать:

$ git checkout feature
$ git rebase -i master

Таким образом, можно будет изменять коммиты при их перемещении в новую ветвь. Обычно используется для очистки истории перед объединением ветви функций в основную. Сразу 
после этих команд вы увидите редактор со списком всех коммитов, которые будут перемещены.

pick 48g8m10b Commit message #1

В частности, вы увидите список таких коммитов, где последовательность чисел 48g8m10b является идентификатором коммита, сообщение о коммите № 1 является сообщением, а 
команда pick означает "использовать этот коммит". Что еще вы можете сделать с коммитом? Вы можете изменить сообщение с помощью команды reword, вы можете удалить коммит с 
помощью команды drop или вы можете использовать команду squash, чтобы использовать ее, но объединить с предыдущей. Последняя команда особенно полезна, если вы используете 
модель gitflow и хотите добавить новые функции в свою ветвь разработки или релиза. Это сохранит вашу историю в чистоте. Полный список команд с их описаниями будет 
доступен вам в самом редакторе.




====================================================================Searching with git=====================================================================================
Представьте, что вы являетесь главным программистом крупного проекта и все время наблюдаете за результатами работы своих коллег. Они работают над ветвями, фиксируют, 
объединяют, совершают ошибки, что-то отменяют, провоцируют конфликты и так далее. Как вам легче следовать за ними? Опять же, с git! В Git есть опция поиска commit. Давайте 
посмотрим, что именно мы можем найти и как.

Кто виноват в ошибке в файле проекта code.py? Это легко выяснить с помощью команды git blame. Он вернет информацию об авторе кода и commit, в которой была изменена строка 
в файле. Вам просто нужно ввести эту команду и имя файла, который был изменен.

$ git blame code.py
^36a1d7 (Jonh User 2020-11-17 12:10:07 -0500  1) 

Превосходно! Мы нашли неправильный коммит. Похоже, это сделал Джон. Теперь вы можете пойти и спросить его, есть ли также ошибка в коде.

Поговорив с Джоном, вы решили поближе ознакомиться с последними изменениями. Для этого вам понадобится знакомая команда git log для git blame, которая просто показывает 
последнюю фиксацию и незафиксированные изменения, и не более того. С помощью команды git log вы можете найти коммиты, в которых изменился файл с проектом.

Чтобы просмотреть сообщение в commite файла, вам нужно git show ---name-only <hash from git blame>. Вы также можете получить информацию о других файлах, которые были 
изменены в этом commit. В качестве более конкретного примера его использования:

$ git show ---name-only ^36a1d7

Мы также можем тщательно изучить, в каких коммитах был изменен этот файл. Для этого есть еще две команды log. Чтобы получить информацию обо всех commit с изменениями в 
данном файле, вам необходимо использовать:

$ git log code.py

И с помощью следующей команды мы получаем информацию о последнем commit с изменениями в этом файле:

git log -n1 code.py

В git log еще есть много интересных флагов и вариантов их сочетания. Чтобы увидеть все, вы можете использовать флаг --help

В ходе бдительных проверок выяснилось, что вас очень интересует файл с ключевым словом "updated". Это последние изменения Джона в коде. И таких изменений, как оказалось, 
было очень много. Чтобы найти все файлы, в которых Джон обновил функции, используйте команду:

git log -Gupdated code.py

И в случае, если вы хотите выполнить поиск коммитов, содержащих слово в описании, вы можете сделать это с помощью команды:

git log --all --grep='README'


======================================================================Introduction to Gitflow==============================================================================
Вы уже знаете, что такое ветви, для чего они предназначены и как их создавать. Вероятно, вас не удивит, что существует множество подходов и техник для работы с ветвлением. 
Мы проанализируем один из самых известных методов, называемый Gitflow. Обычно он используется для совместной работы над проектом, особенно если есть четкий deadline.

Вся структура gitflow сводится к двум основным ветвям: master и develop. Master создается автоматически после инициализации репозитория gitflow. Параллельно вам также 
следует создать ветку develop. В мастере вы будете поддерживать исходный код в состоянии готовности к работе в любой произвольный момент времени. И в develop вы должны 
хранить код, содержащий самые последние опубликованные изменения. Когда вы убедитесь, что код в ветке разработки завершен, вам следует объединить все изменения в master . 
То есть у вас есть некоторая начальная версия проекта, хранящаяся в мастере, и вы со своей командой периодически разрабатываете новые улучшенные версии. Затем вы загружаете 
эти обновления в мастер. Помимо основных ветвей, существуют также вспомогательные ветви: feature, hotfix и release. Мы поговорим о них более подробно в следующей теме.

Если вы только начинаете, сначала вам нужно инициализировать git-flow внутри существующего репозитория git:

$ git flow init

После выполнения этой команды программа задаст вам ряд вопросов о том, какие ветви вы хотите использовать в качестве master, какие в качестве develop, а какие сделать 
вспомогательными. вам нужно выбрать одну из ваших уже созданных ветвей в качестве develop или создать ее отдельно заранее. Для других ветвей вы можете оставить значения по 
умолчанию. Тогда их имена ветвей будут совпадать с именами их схемы модели.
Затем вас переместят в ветку develop и вы сможете приступить к работе.


=======================================================================Gitflow auxiliary branches==========================================================================
После установки gitflow и создания репозитория gitflow вы можете приступить к разработке проекта в ветке. Однако этот процесс не так прост, как кажется: проекты могут 
иметь несколько версий и еще больше ошибок. Чтобы справиться с ними, нам необходимо включить вспомогательные ветви в нашу структуру gitflow для новых вариантов проекта, 
для устранения ошибок и для выпуска новых версий.

Во время работы вы можете создавать так называемые ветви feature на основе develop. Их может быть неограниченное количество. Эти ветви используются для разработки новых 
фич, которые должны появиться в текущих или будущих версиях. Поскольку они являются вспомогательными, их срок службы ограничен. Когда фича будет разработана, 
соответствующая ветвь должна быть объединена с ветвью вумудщз, а затем она будет автоматически удалена. В простейшем случае, если вам не нужно разрабатывать какие-либо 
дополнительные фичи, вам вообще не нужны такие ветви.

Ветви Release используются для подготовки к выпуску новых версий проекта. Они позволяют вам вносить окончательные изменения. Они создаются, когда проект разработки в 
отрасли почти или полностью готов. Обычно вы будете использовать их, если у вас будет несколько версий всего проекта и вы захотите выпускать их одну за другой.

Ветви Hotfix похожи на ветви Release в том, что они создаются и используются при работе с новыми версиями. Но разница в том, что они нужны только для немедленного 
исправления нежелательного поведения, т. Е. ошибки в рабочей версии. Преимущество заключается в том, что ваша команда может продолжать работать над веткой develop, пока 
один из вас исправляет ошибки версии. Они вам понадобятся, если вы обнаружите некоторые ошибки в своем коде во время разработки.

The working process in Gitflow follows approximately the algorithm below:

1) the repository is initialized;
2) the work on the project begins on the develop branch;
3) If you need to try a new thing, a feature branch is created;
4) when a new feature is ready, the feature branch is merged into develop and removed;
5) If everyone is happy with the current version, a release branch is created, where bugs will be fixed;
6) after fixing all the errors, the release version is merged with master.

Шаблон комманд:

git flow feature start   name
	 release finish
	 hotfix  publish
		 pull

На основе этого шаблона создаются основные команды: git flow <branch> <action> <branch_name>

To create a new branch, for example, feature, you need to choose start action:

$ git flow feature start new_feature

You will have a new feature branch based on the develop branch, and you will automatically switch to it. And when you're done with it, use the finish action:

$ git flow feature finish new_feature

So you will immediately do three actions: merge the feature with the develop, delete the original feature branch and stay on the develop branch to continue working. 
Don't forget to commit your changes before finishing! The hotfix and release branches are created and completed in the same way.

Чтобы загрузить результаты своей работы на удаленный сервер, например, на Github, вам необходимо выбрать действие.
Команда для публикации, например, release будет выглядеть следующим образом:

$ git flow release publish my_release

И для того, чтобы загрузить, например, hotfix, вам нужно выбрать действие pull:

$ git flow hotfix pull new_version

Номер вашего обновления или исправления может быть записан непосредственно в имя, например, git flow hotfix start version 1.0, или вы можете использовать команду 
git tag-a 1.0. Если вы внесете какие-либо изменения в теги, то не забудьте отправить их на сервер позже, тоже git push --tags.

В дополнение к тегированию также может быть удобно отслеживать удаленный выпуск или функцию в исходном репозитории с помощью:

$ git flow feature track new_feature


=======================================================================Starting with GitHub================================================================================
GitHub-это платформа для размещения кода. Это место, где разработчики могут хранить свои проекты и работать вместе над разработкой новых проектов. Таким образом, проще 
управлять версиями программ и сотрудничать. GitHub основан на популярной системе управления версиями под названием Git и предоставляет некоторые дополнительные функции, 
такие как веб-интерфейс, инструменты совместной работы, отслеживание проблем, статистика проектов и многое другое.

К 2020 году GitHub станет крупнейшим хранилищем исходного кода в мире. Вы можете найти множество популярных проектов с открытым исходным кодом, размещенных на GitHub, и 
внести свой вклад.

На GitHub размещены миллионы проектов, написанных на разных языках программирования. Каждый проект помещается в свой собственный контейнер, называемый репозиторием, в 
котором могут храниться код, конфигурации, наборы данных, изображения и другие файлы, включенные в ваш проект. Любые изменения файлов в репозитории будут отслеживаться с 
помощью системы управления версиями.

Если вы хотите найти какое-то конкретное хранилище проекта, введите его имя или часть имени в поле поиска. Вы увидите список подходящих репозиториев.

Иногда имя репозитория может быть слишком длинным или может быть много репозиториев с одним и тем же именем.

Обычно у вас есть ссылка на репозиторий. Многие проекты с открытым исходным кодом публикуют ссылки на своих личных веб-сайтах, или ваши коллеги могут дать вам ссылку на 
репозиторий проекта.

С 1 октября 2020 года ветвь Master на Github была переименована в Main. Теперь во всех репозиториях, которые будут созданы, основная ветвь будет называться Main, старые 
репозитории, созданные до октября этого года, остаются неизменными.

На вкладке Code есть два файла. README.md это файл, описывающий проект; этот файл должен быть в каждом репозитории. GitHub находит этот файл и отображает его содержимое 
под репо. Другой файл .gitignore; он указывает, какие файлы и каталоги Git следует игнорировать.

Хотя это репозиторий является общедоступным, вы не можете изменять файлы в этом репозитории напрямую, поскольку у вас есть доступ только для чтения к любому общедоступному 
репозиторию. Чтобы изменить файлы, вы должны быть участником этого проекта.

Вкладка Pull requests содержит предложения об изменениях в файлах, находящихся в репозитории (добавление, удаление или изменение файлов). Владельцы репо могут просмотреть 
запрос и одобрить ваши изменения, если они достаточно хороши.

Вы можете создать Issue или сделать Pull requests (PR), чтобы внести свой вклад в проект, даже если вы не являетесь сотрудником.

В нашем проекте вкладка Wiki пуста, но на самом деле именно там должна храниться документация проекта (как его использовать, как он был разработан, его основные принципы и 
так далее). В то время как а README.md чтобы быстро сообщить читателям, на что способен ваш проект, вики помогают предоставить дополнительную информацию.


==========================================================================Fork and pull request============================================================================
Предположим, вы хотите изменить чей-то проект или использовать чей-то проект в качестве отправной точки для своей собственной идеи. Если вы не являетесь сотрудником, вы не 
можете изменять файлы в репозитории проекта.

В этом случае GitHub позволяет вам стать участником. Вам нужно скопировать(fork) этот репо, изменить его содержимое и предложить свои изменения с помощью pull request. Если 
владельцам проекта понравятся ваши изменения, они могут поместить их в исходное хранилище.

Fork - это копия репозитория. Это позволяет вам свободно экспериментировать с ним, не влияя на исходный проект. Чтобы сделать fork, вы должны войти в GitHub.

Fork-это просто обычный репозиторий, размещенный на GitHub, как и исходный. Вы можете добавлять новые файлы и изменять их или удалять существующие в своём fork.

Прежде чем мы начнем изменять содержимое, давайте создадим новую ветвь. Нажмите на главную ветвь, откроется выпадающее меню. Введите уникальное имя для вашей ветви, 
например edit-readme, а затем нажмите Enter или нажмите Create branch: name.

Let's modify the README.md file, which we can find in the new branch. Open this file and click the edit button (pencil) or click the same button below the repo. Make some 
change; for example, write some information you learned about forks or branches.

To apply these changes, scroll to the Commit changes section below, write a meaningful message about your changes, and then click Commit changes. It will put these changes 
in your repository in the edit-readme branch. The original repo and the master branch of your fork will not undergo any changes.

After you change the content of a repo, you can create a pull request (PR) to propose your changes to the original repository. You may click Pull request as shown below or 
Compare and then Create pull request on the new Comparing changes page.

Then you will see a special page for creating a pull request.

You can see the green text Able to merge which means that your version of the project does not conflict with the original version in the repo. In some cases, the text 
might be different; that would mean that the original repository has some recent changes, but you still can create a PR. Later we will learn how to synchronize your fork 
with the original repository.

Make sure that you've specified the base fork as the original repo (hyperskill/intro-to-github) with the master branch, and the head fork is your repo with a non-master 
branch.

Click Create pull request, provide a descriptive title, then click Create pull request again. After that, you will see the PR that you've created in the repo of this 
project (you can find it in the Pull requests section).


===============================================================================Local work==================================================================================
Стандартный подход к работе с проектом заключается в том, чтобы иметь локальную копию репозитория и вносить изменения в эту копию, а не в удаленное хранилище, размещенное 
на GitHub через веб-интерфейс. Этот локальный репозиторий содержит полную историю версий проекта, которая может быть полезна при работе без подключения к Интернету. После 
того как вы что-то изменили в локальном репозитории, вы можете перенести свои изменения в удаленный репозиторий, чтобы они были видны другим разработчикам.

Во-первых, рассмотрим блок, связанный с GitHub. Существует два хранилища:

1) "upstream" is an original repo of the project that you have forked;
2) "origin" is your fork (copy) on GitHub to which you have full access

Чтобы внести изменения из fork в исходное репо проекта, вам необходимо сделать pull request.

Если вы хотите внести небольшие изменения в свое репо (fork), вы можете использовать веб-интерфейс GitHub. Однако такой подход неудобен при разработке программ, поскольку 
вам часто приходится запускать и отлаживать их локально. Стандартный способ-создать локальный клон удаленного репозитория и работать с ним локально, время от времени внося 
изменения в удаленное репозиторий.

Now you need to clone your fork (origin) of our educational repository on your computer. Find the Clone or download button within the repo and click it to show the address 
of the repository for cloning.

Open your command line or terminal and enter the directory where you want to copy the repository. Then write git clone and insert the address:

$ git clone https://github.com/hyperskill/intro-to-github.git

Now, you have a local repository of the project.

Перейдите в каталог репозитория и просмотрите содержимое. Локальное репо включает в себя все файлы, ветви и историю commit, такие как же как в удаленном хранилище. Введите 
эту команду, чтобы проверить состояние вашего репо:

$ git status

On branch master
Your branch is up-to-date with 'origin/master'.

Теперь ваша рабочая копия фактически находится в главной ветви вашего локального репозитория. И это похоже на главную ветвь origin (fork). Чтобы внести изменения в свое 
репо, сначала вы должны создать ветвь для защиты своей основной ветви. Введите команду ниже:

$ git branch edit-readme

После выполнения этой команды создается новая ветвь edit-readme, но вы все еще находитесь в главной ветви. Вы можете проверить его, используя статус, как и в предыдущем 
примере.

Чтобы получить другую ветвь, используйте checkout с именем ветви:

$ git checkout edit-readme

Теперь вы находитесь в созданной вами ветке.

$ git status

On branch edit-readme
nothing to commit, working tree clean

Мы готовы внести некоторые изменения в новую ветку.

The basic workflow looks like this:

1) Modify the files in your working copy.
2) Select and stage changes you want to be a part of your next commit.
3) Perform a commit that includes your changes.

Let's make some changes then! Open the README.md file and write a few lines in it. Then check the status of the repo again and you will see that the file has been changed. Now, stage these changes using add:

$ git add README.md

You can commit these changes to your local repo with a descriptive comment:

$ git commit -m "Add information about local repository in readme file"

Вы можете совершать столько коммитов, сколько вам нужно. Изменения могут быть разными: добавление новых файлов, удаление или изменение существующих. Не забудьте разместить 
их с помощью add перед commit.

It is important that commit adds changes only to your local repository. If you want to propagate them to the origin repository on GitHub, you need to use push.

For the first time, you need to push your local branch as well because it does not exist in the remote repo.

$ git push --set-upstream origin edit-readme
The next time it will be easier:

$ git push
To get changes made by someone else, use pull:

$ git pull

Хорошая вещь, которую можно сделать, - периодически выполнять pull, особенно перед push, чтобы предотвратить возможные конфликты, когда кто-то другой изменил файлы в 
репозитории в той же ветке.

After pushing your branch with changes, you may find it on GitHub and create Pull Request to the original (upstream) repo as we did it before.



============================================================================================Git lab=============================================================================================
1) Настраиваем имя в папке с проектом
git config --global user.name "Daniil Kuznetsov"
2) Указываем email
git config --global user.email "ldan93@yandex.ru"
3) Создаём репозиторий
git init
4) Контроль состояния текущего репозитория
git status
5) Указываем гиту файл за изменениями которого он должен следить
git add имя_файла.расширение
6) Указываем все файлы в папке для отслеживания гитом
git add * //добавляет все файлы кроме игнорируемых
git add . //дополнительно добавляет файл .gitignore
7) Удаляем файл из отслеживаемой группы
git rm --cashed имя_файла.расширение
git rm -f имя_файла.расширение //удалем из папки проекта тоже
8) Создать файл gitignore
touch .gitignore
9) Делаем коммит
git commit -m "сообщение"
10) После изменения файла в папке необходимо его снова добавить в отслеживаемые гитом и только потом сделать коммит
git add .
git add имя_файла.расширение
11) Информация о сделанных коммитах
git log
12) Посмотреть изменения в файлах по сравнению с последним коммитом
git diff
13) Связывает локальный репозиторий с удалённым
git remote add origin https://gitlab.com/atcourse/1.git
14) Список удалённых репозиториев с которыми связан текущий локальный репозиторий
git remote
15) Отправить локальный репозиторий на удалённый
git push -u имя_репозитория имя_ветки
git push -u origin master
16) Создание дополнительной ветки
git branch название_ветки
git branch - просмотр всех существующих локальных веток
17) Переключение на другую ветку
git checkout название_ветки
Ветка пустая, в ней также нужно сделать git add
18) Соединение веток

1 Переключаемся на мастер ветку
git checkout master
2 Делаем слияние
git merge имя_ветки_которую_хотим_присоединить_к_master

19) Загрузка удалённого репозитория
git clone url_репозитория

git remote -v show покажет список репозиториев;
git remote remove <имя> удалит указанный репозиторий(отвяжет локальный от удалённого).

Git pull загружает данные с сервера, и только самые последние. Таким образом, вы не запутаетесь в коммитах и будете уверены, что скопировали только самые свежие и 
актуальные из них. Итак, вы просто делаете: git pull origin <branch_name>, т. Е. вы загружаете последние изменения из ветки удаленного репозитория на сервере. В примере 
мы загружаем данные из основной ветки.

$ git pull origin main

20) HEAD

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.

Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту.

21) Относительные ссылки

Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что 
придётся каждый раз использовать git log, чтобы найти хеш нужного коммита

Более того, хеши в реальном репозитории Git намного более длинные - fed2da64c0efc5293610bdd892f82a58e8cbc5d8
Git нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто fed2 вместо колбасы выше.

С относительными ссылками можно начать с какого-либо удобного места (например, с ветки или от HEAD) и двигаться от него
Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:

- Перемещение на один коммит назад ^

Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
Так что git checkout main^ означает "первый родитель ветки main".
git checkout main^^ означает прародитель (родитель родителя) main

Можно также использовать HEAD как относительную ссылку.
git checkout C3 
git checkout HEAD^ 
git checkout HEAD^ 
git checkout HEAD^ 

- Перемещение на несколько коммитов назад ~<num>
Укажем после ~ число коммитов, через которые надо пройти.
git checkout HEAD~4

22) Перемещение ветки (branch forcing)

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. 
Например, команда:

git branch -f main HEAD~3

Откатит (принудительно) ветку main на три commit назад от HEAD.

23) Отмена изменений в Git

Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и 
на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: первый - это git reset, а второй - git revert

git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто 
некоторых коммитов вовсе и не было.

git reset HEAD~1

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие 
пользователи.Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert.

Забавно, появился новый коммит. Дело в том, что новый коммит просто содержит изменения, полностью противоположные тем, что сделаны в последнем коммите.
После revert можно сделать push и поделиться изменениями с остальными.

git revert HEAD

24) Cherry-pick

git cherry-pick <Commit1> <Commit2> <...>

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). 

25) Git Interactive Rebase

Всё, что нужно для интерактивного rebase - это опция -i
Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, 
так что можно легко понять что к чему.Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. 

После открытия окна интерактивного rebase есть три варианта для каждого коммита:

- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе.
- Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты, при помощи этой функции можно объединять изменения двух коммитов.

 git rebase -i HEAD~4 

26) Тэги

Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит. Важно, что после создания они никогда не сменят своего 
положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений. Если конкретный коммит не указан, гит пометит тегом HEAD.

 git tag v1 хэш_комита

27) Git Describe

Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состояние от ближайшего тега. И эта команда называется git describe
Git describe помогает сориентироваться после отката на много коммитов по истории изменений.

Git describe выглядит примерно так:

git describe <ref>

Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).

Вывод команды выглядит примерно так:

<tag>_<numCommits>_g<hash>

Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.