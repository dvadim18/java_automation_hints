Рефералка JetBrains Academy https://hyperskill.org/join/79ca62d58
			    https://hyperskill.org/join/a0e159e14
			    https://hyperskill.org/join/5872b82c1
			    https://hyperskill.org/join/878899354

Использование Scanner во время чтения строк и потоков:
Нажатие Enter не закрывает входной поток. Он все еще открыт и ждет ввода. Чтобы фактически закрыть входной поток, вам нужно создать 
событие конца файла. В IDEA нужно нажать Ctrl+D (Windows и Linux) или <command>+D (MacOS).
			    

Простые типы:
boolean       true или false
char   16 bit от 0 до 65535
_________________________________________
byte    8 bit от -128 до 127
short  16 bit от -32768 до 32767
int    32 bit от -2147483648 до 2147483647
long   64 bit от -9*10^18 до 9*10^18
_________________________________________
float  32 bit от -3,4*10^38 до 3,4*10^38
double 64 bit от +-5,0*10^-324 до 1,7*10^308

Аргументы - значения, которые вы передаёте методам foo.go(x) x-аргумент
Аргумент превращается в параметр (локальная переменная с именем и типом, которая может быть использована
внутри метода). Если метод принимает параметр, вы обязаны ему передать значение 
соответствующего типа.(стр 99). void go(int z){} int z - параметр

Помечайте переменные экземпляра как private
Помечайте геттеры и сеттеры как public

Переменные экземпляра объявляются внутри класса, а локальные переменные внутри метода

Значения переменных экземпляра по умолчанию:
целые 0
С плавающей точкой 0
Булевые false
Ссылки null

Локальные переменные не содержат значение по умолчанию, их нужно объявлять и задать значение

Чтобы сравнивать примитивы испотзуется ==
Чтобы сравнивать ссылки используется ==
Чтобы сравнивать объекты используется метод equals()

Основное различие между операторами постинкремента и преинкремента заключаются в следующем:
При постинкременте вызывающий код в начале получает значение переменной, а затем значение переменной 
увеличивается на единицу.
При преинкременте в начале значение переменной увеличивается на единицу, а затем вызывающий код получает 
значение переменной.
int x = 0;
int z = ++x;
x = 1, z = 1

int x = 0;
int z = x++;
x = 1, z = 0

======================================================ArrayList====================================================
java.util.ArrayList - класс для создания списков

Создание объекта класса ArrayList:
ArrayList <DataType> a = new ArrayList <DataType>();
ArrayList <DataType> a = new ArrayList(); // тоже самое, второй раз <DataType> можно не указывать
ArrayList <DataType> a = new ArrayList <>(); // тоже самое, рекомендуется импользовать данную конструкцию!!!

Для создания ArrayList нельзя использовать примитивные типы данных, необходимо использовать их классы - аналоги (INTEGER, DOUBLE и тд)

add(DataType element) - добавить элемент
add(int index, element) - добавить элемент на конкретный индекс
addAll(ArrayList  aL) - добавляет в указанный ArrayList в конец текущего
addAll(int index, ArrayList  aL) - добавляет в указанный ArrayList в указанный индекс текущего
get(int index) - возвращает элемент с указанным индексом
set(int index, DataType element) - заменяет элемент с указанным индексом на новый элемент
remove(Object element) - удалить элемент
remove(int index) - удалить элемент c указанным индексом
indexOf(Object element) - возвращает индекс первого встреченного элемента, если элемент не найден, то возвращает -1
lastIndexOf(Object element) - возвращает индекс последнего встреченного элемента, если элемент не найден, то возвращает -1
isEmpty() - выяснить пусть ли список, возвращает true или false соответственно
contains(Object element) - возвращает true если искомый элемент присутствует, иначе false
containsAll(Collection collection) - возвращает true если все элементы коллекции присутствует в текущей коллекции, иначе false
size() - узнать размер списка
clear() - очищает ArrayList
toString() - выводит ArrayList как строку

clone() - возвращает объект с копией элементов ArrayList
ArrayList <StringBuilder> list2 = (ArrayList <StringBuilder>) list1.clone()
list1.get(0) == list2.get(0) // true т.к. ссылаются на один объект
list1 == list2 // false т.к. это разные объекты

toArray() - возвращает Object[]
Object[] array = list.toArray();
 
toArray(DataType[] array) - возвращает DataType[]
StringBuilder[] array = list.toArray(new StringBuilder[10]);

Arrays.asList(DataType[]) - возвращает List<DataType> , причём, изменить размер List нельзя, все изменения в массиве отразятся в List
StringBuilder[] array = {sb1, sb2, sb3, sb4};
List <StringBuilder> list = Arrays.asList(array);

Collections.sort(ArrayList <DataType>) - сортирует ArrayList
Collections.frequincy(Collection 1, Object o) - возвращает количество одинаковых элементов
Collections.disjoint(Collection 1, Collection 2) - если есть одинаковые элементы, то возвращает false, если совпадений нет, то true
Collections.rotate(Collection 1, int col) - перемещает элементы на указанное количество шагов
Collections.swap(int i, int b) - меняет элементы местами
Collections.shuffle(Collection 1) - перемешивает содержимое коллекции

equals(ArrayList<DataType>) -> boolean - сравнивает количество элементов. элементы и их порядок в ArrayListах

ArrayList<String> - объявить тип списка
ArrayList<Boolean>
ArrayList<Character>
ArrayList<Byte>
ArrayList<Short>
ArrayList<Integer>
ArrayList<Long>
ArrayList<Float>
ArrayList<Double>

a.add(index:0, element:"ноль");
a.add(1, "один");
a.add(2, "два");
a.add(3, "три");
contains("три") - включён ли элемент в список

for (int i = 0; i < a.size(); i++) {
	System.out.println(a.get(i));
}

==================================================Iterator====================================================
java.util.Iterator

Iterator <String> it = list.iterator();

C помощью итератора it мы можем пройтись по элементам list(например ArrayList)

while (it.hasNext()) {
	System.out.println(it.next); // выводит следующий элемент list
	it.next(); // сохраняет в себе следующий элемент
	it.remove(); //удаляет текущий элемент list
}

=============================================================================Генерация UUID===================================================================================
String paymentId = UUID.randomUUID().toString();

========================================Классы для работы с датами============================================
new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(new Date());
=> 2022-06-06T20:03:58.123+03:00

String date ="2014, Month.MAY, 15";
new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(date);

ZonedDateTime dat = ZonedDateTime.now().plusMonths(1);
DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
=> 2022-07-06T19:47:20.903+0300

String offset = ZonedDateTime.now().minusMinutes(5).format(DateTimeFormatter.ISO_INSTANT);
	=> 2022-06-07T09:06:06.718Z	

LocalDate.of(1993, 5, 14).format(DateTimeFormatter.ofPattern("dd MMM,yyyy", Locale.ENGLISH));
	=> 14 May,1993

пакет java.time

класс LocalDate - содержит информацию о дне: год, месяц, день
класс LocalTime - содержит информацию о времени: час, минута, секунда, наносекунда
класс LocalDateTime - содержит инфо о дне и времени: год, месяц, день, час, минута, секунда, наносекунда

Данные 3 класса имеют статический метод now(), который возвращает соответствующие объекты с текущими значениями

Объекты данных классов immutable

Данные 3 класса имеют private конструктор, поэтому создать экземпляр класса с помощью него не получится

Объекты данных классов создаются с помощью методов of:

public static LocalDate of(int год, int месяц, int ден_месяца)
public static LocalDate of(int год, Month месяц, int ден_месяца)
LocalDate.of(2014, 5, 15);
LocalDate.of(2014, Month.MAY, 15);

public static LocalTime of(int час, int минута)
public static LocalTime of(int час, int минута, int секунда)
public static LocalTime of(int час, int минута, int секунда, int наносекунда)

public static LocalDateTime of(int год, int месяц, int ден_месяца, int час, int минута) // можно использовать Month месяц
public static LocalDateTime of(int год, int месяц, int ден_месяца, int час, int минута, int секунда) // можно использовать Month месяц
public static LocalDateTime of(int год, int месяц, int ден_месяца, int час, int минута, int секунда, int наносекунда) // можно использовать Month месяц

При некорректном указании дат и времени  выбрасывается DateTimeException

Методы LocalDate:
1) plusDays(long количество дней) -> LocalDate
2) minusDays(long количество дней) -> LocalDate
3) plusWeeks(long количество недель) -> LocalDate 
4) minusWeeks(long количество недель) -> LocalDate 
5) plusMonth(long количество месяцев) -> LocalDate  
6) minusMonth(long количество месяцев) -> LocalDate 
7) plusYears(long количество лет) -> LocalDate 
8) minusYears(long количество лет) -> LocalDate
9) getDayOfWeek() -> DayOfWeek 
10) getDayOfMonth() -> int
11) getDayOfYear() -> int
12) getMonth() -> Month
13) getMonthValue() -> int
14) getYear() -> int

Методы LocalTime:
1) plusHours(long количество часов) -> LocalTime
2) minusHours(long количество часов) -> LocalTime
3) plusMinutes(long количество минут) -> LocalTime
4) minusMinutes(long количество минут) -> LocalTime
5) plusSeconds(long количество секунд) -> LocalTime
6) minusSeconds(long количество секунд) -> LocalTime
7) plusNanos(long количество наносекунд) -> LocalTime
8) minusNanos(long количество наносекунд) -> LocalTime
9) getNano() -> int
10) getSecond() -> int
11) getMinute() -> int
12) getHour() -> int

Методы LocalDateTime используют методы LocalDate и LocalTime и возвращают объект LocalDateTime

Методы сравнения:
1) isAfter(Object obj) -> boolean // указанная дата больше даты в аргументе? (можно сравнивать только одинаковые классы)
2) isBefore(Object obj) -> boolean // указанная дата меньше даты в аргументе? (можно сравнивать только одинаковые классы)

Класс Period имеет private конструктор. Создаётся с помощью метода of, которые возвращают объект типа Period

Методы класса Period:
1) public static Period ofDays(int кол_дней)
2) public static Period ofWeeks(int кол_недель)
3) public static Period ofMonths(int кол_месяцев)
4) public static Period ofYears(int кол_лет)
5) public static Period of(int кол_лет, int кол_месяцев, int кол_дней)

Методы plus и minus могут быть использованы для прибавления и отнимания периодов к/от объектов класса LocalDate и 
LocalDateTime. При попытке использования методов plus или minus для сложения или отнимания периода к/от объекта
класса LocalTime будет выброшен exception

Класс Duration имеет private конструктор. Создаётся с помощью метода of, которые возвращают объект типа Duration.
Не работает с классом LocalDate

Методы класса Duration:
1) public static Duration ofDays(int кол_дней)
2) public static Duration ofHours(int кол_часов)
3) public static Duration ofSeconds(int кол_секунд)
4) public static Duration ofMilis(int кол_милисекунд)
5) public static Duration ofNanos(int кол_наносекунд)

Класс DateTimeFormatter - позволяет изменять вывод даты или времени на экран

находится в пакете java.time.format

DateTimeFormatter d = DateTimeFormatter.имя_формата
LocalDate ld = LocalDate.of(2016, 5, 1);
ld.format(d); // возвращает дату в указанном формате

DateTimeFormatter d = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
LocalDate ld = LocalDate.of(2016, 5, 1);
ld.format(d);

DateTimeFormatter d = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
LocalDate ld = LocalDate.of(2016, 5, 1);
d.format(ld);

Можно создать свой шаблон формата вывода:

DateTimeFormatter d = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm")

Создание даты из строки:

DateTimeFormatter d = DateTimeFormatter.ofPattern("MM dd yyyy");
LocalDate date = LocalDate.parse("01 02 2015", d);
System.out.println(date);


==========================================================LocalTime========================================================================
В Java есть специальный класс для представления времени суток. Класс LocalTime представляет дневное время в формате часы-минуты-секунды, 
например 06:30 или 11:45:30. Он не хранит информацию о дате или часовом поясе. Время хранится с точностью до наносекунды 
(например, 13:45:30,123456789). Класс LocalTime можно использовать для хранения таких вещей, как часы открытия и закрытия магазина или 
расписание поездов. Этот класс принадлежит пакету java.time и во многом напоминает класс LocalDate.

Прежде всего, давайте посмотрим, как мы создаем экземпляр класса LocalTime. Экземпляр, в котором хранится текущее время, может быть создан, 
как показано ниже:

LocalTime now = LocalTime.now();

Если мы хотим передать определенное время экземпляру, мы должны использовать любой из двух статических методов of или parse 
для создания экземпляра LocalTime:

LocalTime.of(11, 45);        // 11:45
LocalTime.of(11, 45, 30);    // 11:45:30
LocalTime.parse("11:45:30"); // 11:45:30 (hours, minutes, seconds)

В первой строке поля second и nanosecond будут равны нулю.

Час дня — это целое число от 0 до 23, а минуты и секунды — числа от 0 до 59. Наносекунды могут быть любыми целыми числами от 0 до 999 999 999. 
Следующий код вызывает исключение:

LocalTime.of(24, 1, 1); // it throws DateTimeException (24 is an invalid value for hours)

Также можно создать экземпляр LocalTime, используя статические методы SecondOfDay и ofNanoOfDay. В этом случае 
мы должны указать секунды и наносекунды дня соответственно:

LocalTime time = LocalTime.ofSecondOfDay(12345); // 03:25:45
LocalTime nanotime = LocalTime.ofNanoOfDay(1234567890); // 00:00:01.234567890

В классе LocalTime также есть некоторые предопределенные константы:

LocalTime.MIN; // 00:00
LocalTime.MAX; // 23:59:59.999999999
LocalTime.NOON; // 12:00
LocalTime.MIDNIGHT; // 00:00

Теперь давайте обсудим кучу полезных методов класса LocalTime. Предположим, у нас есть экземпляр LocalTime:б

LocalTime time = LocalTime.of(11, 45, 30); // 11:45:30

Используя следующие методы, мы можем получить часы, минуты, секунды и наносекунды:

time.getHour();   // 11
time.getMinute(); // 45
time.getSecond(); // 30
time.getNano();   // 0, nanoseconds

Другой полезный метод — toSecondOfDay. Он возвращает время в секундах дня из данного экземпляра LocalTime. 
Для нашего примера это будет:

time.toSecondOfDay(); // 42330

В классе также есть методы для сложения и вычитания часов, минут, секунд и наносекунд:

LocalTime time1 = time.plusHours(5); // 16:45:30
LocalTime time2 = time.plusHours(22); // 09:45:30
LocalTime time3 = time.minusMinutes(10); // 11:35:30
LocalTime time4 = time.minusSeconds(30); // 11:45

Следующие методы возвращают копию экземпляра с одной измененной частью:

LocalTime time1 = time.withHour(23); // 23:45:30
LocalTime time2 = time.withMinute(50); // 11:50:30
LocalTime time3 = time.withSecond(0); // 11:45

Имейте в виду, что класс LocalTime immutable и все рассматриваемые методы возвращают новый экземпляр.


===========================================================LocalDate=======================================================================
Класс LocalDate представляет одну дату в формате YYYY-MM-dd, например 2017-11-25 или 2025-01-23 . В нем можно хранить любую дату: от дня 
рождения до дня Апокалипсиса. Класс принадлежит пакету java.time.

После импорта класса можно создать экземпляр, хранящий текущую дату, как показано ниже:

LocalDate now = LocalDate.now();

Конечно, также можно создать экземпляр LocalDate, представляющий определенный день в году. Его можно получить с помощью любого из двух 
специальных статических методов: of и parse.

LocalDate date1 = LocalDate.of(2017, 11, 25); // 2017-11-25 (25 November 2017)
LocalDate date2 = LocalDate.parse("2017-11-25"); // 2017-11-25 (25 November 2017)

Система нумерации интуитивно понятна: номер месяца — число от 1 до 12 включительно, первый день месяца имеет число 1.

Другой полезный способ создать экземпляр LocalDate — указать год и порядковый номер дня в этом году, например:

LocalDate.ofYearDay(2017, 33); // 2017-02-02 (2 February 2017)

Номер дня в году — это целое число от 1 до 365-366 (в зависимости от того, високосный год или нет).

LocalDate.ofYearDay(2016, 365); // 2016-12-30 (30 December 2016)
LocalDate.ofYearDay(2017, 365); // 2017-12-31 (31 December 2017)

Давайте теперь рассмотрим следующий экземпляр LocalDate:

LocalDate date = LocalDate.of(2017, 11, 25); // 2017-11-25 (25 November 2017)

Мы можем получить год, месяц, день месяца, день года:

int year = date.getYear(); // 2017
int month = date.getMonthValue(); // 11
int dayOfMonth = date.getDayOfMonth(); // 25
int dayOfYear = date.getDayOfYear();  // 329

Также можно получить длину года и месяца:

int lenOfYear = date.lengthOfYear(); // 365
int lenOfMonth = date.lengthOfMonth(); // 30

У класса есть другие методы для добавления, вычитания и изменения дня, месяца и года. Давайте создадим еще один экземпляр LocalDate:

LocalDate date = LocalDate.of(2017, 1, 1); // 2017-01-01 (1 January 2017)

LocalDate tomorrow = date.plusDays(1);    // 2017-01-02 (2 January 2017)
LocalDate yesterday = date.minusDays(1);  // 2016-12-31 (31 December 2016)
LocalDate inTwoYears = date.plusYears(2); // 2019-01-01 (1 January 2019)
LocalDate in2016 = date.withYear(2016);   // 2016-01-01 (1 January 2016)


===========================================================LocalDateTime===================================================================
Класс LocalDateTime представляет собой комбинацию LocalDate и LocalTime, которая сохраняет такие значения, как 2017-12-03T22:30. Он 
по-прежнему не хранит информацию о часовом поясе. Его можно использовать для хранения даты и времени транзакции в платежной системе.
Как и в классе LocalTime, время представляется с точностью до наносекунды.

Экземпляр LocalDateTime, представляющий текущий момент, можно получить, как показано ниже:

LocalDateTime now = LocalDateTime.now(); // this moment

The class has static methods of and parse to create instances:

LocalDateTime dt1 = LocalDateTime.of(2017, 11, 25, 22, 30);  // 25 November 2017, 22:30
LocalDateTime dt2 = LocalDateTime.parse("2017-11-25T22:30"); // 25 November 2017, 22:30

Также возможно получить экземпляр из экземпляров LocalDate и LocalTime, например:

LocalDate date = LocalDate.of(2017, 11, 25); // 2017-11-25
LocalTime time = LocalTime.of(21, 30); // 21:30
        
LocalDateTime dateTime = LocalDateTime.of(date, time); // 2017-11-25T21:30

или с помощью специальных методов экземпляра LocalDate и LocalTime:

LocalDate date = LocalDate.of(2017, 11, 25); // 2017-11-25
LocalTime time = LocalTime.of(21, 30); // 21:30       

LocalDateTime dateTime1 = date.atTime(time); // 2017-11-25T21:30
LocalDateTime dateTime2 = time.atDate(date); // 2017-11-25T21:30

Теперь рассмотрим некоторые методы класса LocalDateTime. Мы уже создали экземпляр dateTime для представления 25 ноября 2017 года, 22:30:

LocalDateTime dateTime = LocalDateTime.of(2017, 11, 25, 22, 30); // 25 November 2017, 22:30

В классе LocalDateTime есть методы для получения единиц даты и времени, таких как месяц, день месяца, час и минута:

int month = dateTime.getMonthValue(); // 11
int day = dateTime.getDayOfMonth(); // 25
int hour = dateTime.getHour(); // 22
int minute = dateTime.getMinute(); // 30

В классе также есть методы экземпляра toLocalDate и toLocalTime для получения даты и времени как целых частей LocalDateTime:

LocalDate dateOf = dateTime.toLocalDate(); // 2017-11-25
LocalTime timeOf = dateTime.toLocalTime(); // 22:30

В классе есть методы для добавления, вычитания и изменения лет, месяцев, дней, часов, минут, секунд, а также LocalDate и 
LocalTime. Давайте рассмотрим их на другом примере:

LocalDateTime endOf2017 = LocalDateTime.of(2017, 12, 31, 23, 59, 59); // 2017-12-31T23:59:59

Вот как, добавляя одну секунду, мы попадаем в другой год или перемещаемся по годам:

LocalDateTime beginningOf2018 = endOf2017.plusSeconds(1); // 2018-01-01T00:00
LocalDateTime beginningOf2020 = beginningOf2018.plusYears(2); // 2020-01-01T00:00

Мы также можем изменить составные части LocalDateTime, указав их значения:

LocalDateTime beginningOf2020 = beginningOf2018.withYear(2020); // 2020-01-01T00:00

Пример 1. Разница между двумя датами в часах:

        LocalDateTime date = LocalDateTime.parse(scanner.nextLine());
        LocalDateTime date2 = LocalDateTime.of(date.getYear(), 1, 1, 0, 0);
        System.out.println(date2.until(date, ChronoUnit.HOURS));

        Scanner input = new Scanner(System.in);
        LocalDateTime presentTime = LocalDateTime.parse(input.nextLine());
        LocalDateTime begginingOfTheYear = LocalDateTime.parse("2017-01-01T00:00:00");
        long hours = ChronoUnit.HOURS.between(begginingOfTheYear, presentTime);
        System.out.println(hours);

        LocalDateTime localDateTime = LocalDateTime.parse(scanner.next());
        LocalDateTime startOfTheYear = LocalDateTime.of(localDateTime.getYear(), 1, 1, 00, 00, 00);
        Duration duration = Duration.between(startOfTheYear, localDateTime);
        System.out.println(duration.toHours());


====================================================Comparing dates and time===============================================================
Классы LocalDate, LocalTime, LocalDateTime имеют методы для сравнения их экземпляров в соответствии с их положением на временной шкале. 
Методы сравнивают экземпляры в хронологическом порядке (или в порядке времени).

Метод compareTo сравнивает этот экземпляр с другим, переданным в качестве аргумента метода. Он возвращает 0, если они равны, отрицательное 
значение, если этот экземпляр меньше другого, и положительное значение, если этот экземпляр больше.

Вот пример сравнения двух экземпляров класса LocalDate:

LocalDate date1 = LocalDate.parse("2017-01-02");
LocalDate date2 = LocalDate.parse("2017-12-12");

date1.compareTo(date1); // 0, date1 and date1 are equal
date1.compareTo(date2); // -11, negative value => date1 is less than date2
date2.compareTo(date1); // 11, positive value => date2 is greater than date1

В классе LocalTime есть тот же метод, который возвращает 0, 1 или -1:

LocalTime time1 = LocalTime.parse("15:30:10");
LocalTime time2 = LocalTime.parse("17:50:30");

time1.compareTo(time1); // 0, time1 and time1 are equal
time1.compareTo(time2); // -1, time1 is less than time2
time2.compareTo(time1); // 1, time2 is greater than time1

а также LocalDateTime:

LocalDateTime dateTime1 = LocalDateTime.parse("2017-01-01T20:30"); // 1 January 2017, 20:30
LocalDateTime dateTime2 = LocalDateTime.parse("2017-01-02T23:00"); // 2 January 2017, 23:00

dateTime1.compareTo(dateTime1); // 0, dateTime1 and dateTime are equal
dateTime1.compareTo(dateTime2); // -1, dateTime1 is less than dateTime2
dateTime2.compareTo(dateTime1); // 1, dateTime2 is greater than dateTime1

Классы также имеют несколько кратких методов для сравнения дат и времени на временной шкале, которые возвращают boolean значение.

Метод isAfter возвращает true, только если этот экземпляр находится строго после другого экземпляра, переданного в качестве аргумента, 
в противном случае метод возвращает false.

Метод isBefore возвращает true, только если этот экземпляр находится строго перед экземпляром, переданным в качестве аргумента, в 
противном случае метод возвращает false.

Метод isEqual возвращает true, если экземпляры равны, в противном случае метод возвращает false.

Вот пример сравнения двух экземпляров класса LocalDate.

LocalDate date1 = LocalDate.of(2017, 11, 30);
LocalDate date2 = LocalDate.of(2017, 12, 1);

date1.isEqual(date1); // true
date1.isEqual(date2); // false

date1.isBefore(date2); // true
date1.isBefore(date1); // false
date2.isBefore(date1); // false

date2.isAfter(date1); // true
date2.isAfter(date2); // false
date1.isAfter(date2); // false

Вот пример сравнения двух экземпляров класса LocalTime.

LocalTime time1 = LocalTime.of(14, 20); // 14:20
LocalTime time2 = LocalTime.of(15, 55); // 15:55
LocalTime time3 = LocalTime.of(16, 40); // 16:40
        
time1.isBefore(time2); // true
time3.isBefore(time2); // false
time3.isBefore(time3); // false

time2.isAfter(time1);  // true
time2.isAfter(time3);  // false

А вот пример сравнения двух экземпляров класса LocalDateTime.

LocalDateTime dateTime1 = LocalDateTime.parse("2017-12-01T21:30"); // 1 December 2017, 21:30
LocalDateTime dateTime2 = LocalDateTime.parse("2017-12-02T21:30"); // 2 December 2017, 21:30

dateTime1.isEqual(dateTime2); // false
dateTime2.isEqual(dateTime2); // true

dateTime1.isBefore(dateTime2); // true
dateTime1.isAfter(dateTime2); // false
dateTime2.isAfter(dateTime1); // true

Имейте в виду, что у класса LocalTime нет метода isEqual. Вместо этого вы можете использовать метод equals. Давайте рассмотрим несколько 
методов создания единиц периода:


========================================================Period and Duration================================================================
В этом разделе вы познакомитесь с классом Period, представляющим единицу измерения на основе даты, и классом Duration, представляющим 
единицу измерения на основе времени. Оба они принадлежат пакету java.time.

Класс Period представляет период времени в годах, месяцах и днях. Если единица измерения включает все показатели, ее единица измерения 
имеет формат P{year}Y{month}M{day}D, где {year}, {month} и {day} – это заполнители для значений.

- Первый и, вероятно, наиболее распространенный способ создания единиц Period — использование статического метода of().

Period period  = Period.of(1955, 5, 23);
System.out.println(period); // P1995Y5M23D

- Следующий метод позволяет получить единицу Period в виде разницы между двумя датами:

LocalDate startDate = LocalDate.of(1995, 5, 23);
LocalDate endDate = LocalDate.of(1995 , 8, 25);
Period period = Period.between(startDate, endDate);

System.out.println(period); // P3M2D

Он верет отрицательные значения, если второй аргумент меньше, ноль, если они равны, и положительное значение, если второй аргумент больше.

- Другой метод принимает текст и парсит его до типа Period.

// 23 days
System.out.println(Period.parse("P23D")); // P23D
// 5 months 23 days
System.out.println(Period.parse("P5M23D")); // P5M23D
// -1995 years 5 months 23 days
System.out.println(Period.parse("P-1995Y5M23D")); // P-1995Y5M23D

Та же логика работает и для отрицательных значений. Вот шаблон, который вы можете использовать, чтобы указать, что значения являются 
отрицательными:

// -23 days
System.out.println(Period.parse("P-23D")); // P-23D
// -5 months -23 days
System.out.println(Period.parse("P-5M-23D")); // P-5M-23D
// -1995 years -5 months -23 days
System.out.println(Period.parse("P-1995Y-5M-23D")); // P-1995Y-5M-23D
// -1995 years -5 months -23 days
System.out.println(Period.parse("-P1995Y5M23D")); // P-1995Y-5M-23D

Обычно, если вы напечатаете полную дату типа Period, она будет выглядеть как шаблоны, которые мы показали в предыдущих разделах. Этот 
класс также предоставляет нам некоторые методы, которые полезны, когда вы хотите извлечь один элемент даты из полной даты.

Period period  = Period.of(1995, 5, 23);

System.out.println(period.getYears()); // 1995
System.out.println(period.getMonths()); // 5
System.out.println(period.getDays()); // 23

Другим методом, выполняющим ту же операцию, является метод get(). Если у вас есть та же переменная period из предыдущего 
раздела, ваш код будет выглядеть так:

public static void main(String[] args) {
    Period period  = Period.of(1995, 5, 23);
        
    System.out.println(period.get(ChronoUnit.YEARS)); // 1995
    System.out.println(period.get(ChronoUnit.MONTHS)); // 5
    System.out.println(period.get(ChronoUnit.DAYS)); // 23
}

Обратите внимание, что в ChronoUnit есть поля и для других единиц измерения, но объем этого метода позволяет использовать только три из 
них, упомянутых выше. Если вы используете такие единицы, как ChronoUnit.WEEKS или любые другие, вы столкнетесь с исключением 
UnsupportedTemporalTypeException.

Теперь давайте рассмотрим две пары методов, предназначенных для сложения и вычитания единиц измерения на основе даты, а именно:

addTo() and subtractFrom()
plus() and minus()

Эти пары методов выполняют аналогичные операции, но ведут себя по-разному. Примеры кода ниже показывают разницу. Начнем с первой пары, 
addTo() и subtractFrom():

Period period  = Period.of(1, 1, 1);

System.out.println(period.addTo(LocalDate.of(1995, 5, 23))); // 1996-06-24
System.out.println(period.subtractFrom(LocalDate.of(1995, 5, 23))); // 1994-04-22
System.out.println(period); // P1Y1M1D

Это означает, что методы не предназначены для работы с двумя единицами периода. С их помощью вы будете добавлять или вычитать период из/в 
временную переменную, которая является базовым интерфейсом нескольких классов, включая LocalDate, LocalDateTime, ZonedDateTime и так далее.

С другой стороны, вторая пара plus() и minus() предназначена для работы с двумя переменными типа Period.

Period period  = Period.of(1, 1, 1);

System.out.println(period.plus(Period.of(1995, 5, 23))); // P1996Y6M24D
System.out.println(period.minus(Period.of(1995, 5, 23))); // P-1994Y-4M-22D
System.out.println(period); // P1Y1M1D

Как видите, мы имеем совершенно другой результат при вычитании. Метод subtractFrom() вычитает переменную периода из LocalDate, а метод 
minus() вычитает вторую единицу периода из первой.


Duration представляет собой период времени, в котором хранится значение в секундах и наносекундах. Его структура имеет много общего с 
классом Period. У них есть похожие методы, которые имеют схожие роли. Единицы этого класса создаются так же, как единицы периода, и имеют 
аналогичный формат единицы измерения PT{hour}H{minute}M{second}S, когда единица включает все показатели. Мы рассмотрим те же четыре метода, 
которые использовались при создании единиц периода. Прежде всего, давайте изучим метод of().

Duration durationOf = Duration.of(3, ChronoUnit.DAYS);
Duration durationOf1 = Duration.of(3, ChronoUnit.MINUTES);
Duration durationOf2 = Duration.of(3, ChronoUnit.NANOS);
        
System.out.println(durationOf); // PT72H
System.out.println(durationOf1); // PT3M
System.out.println(durationOf2); // PT0.000000003S

Здесь этот метод имеет немного другое поведение. Он принимает два аргумента, определяющих количество и единицу времени. Первый параметр не 
нуждается в объяснении, но вы должны знать о важном ограничении, касающемся второго. Хотя ChronoUnit предоставляет нам множество единиц 
времени, здесь мы можем использовать только точные единицы и дни, которые считаются как 24 часа (хотя фактическая продолжительность суток 
немного больше). Все неподдерживаемые единицы вызовут исключение UnsupportedTemporalTypeException. 

Два других метода ведут себя не иначе, чем те же методы класса Period. Здесь вы видите метод between():

LocalTime startTime = LocalTime.of(11, 45, 30);
LocalTime endTime = LocalTime.of(12, 50, 30);
 
System.out.println(Duration.between(startTime, endTime)); // PT1H5M

Точно так же работает и метод parse():

Duration duration1 = Duration.parse("PT1H20M");
Duration duration2 = Duration.parse("PT30M");

System.out.println(duration1); // PT1H20M
System.out.println(duration2); // PT30M

В отличие от класса Period, здесь меньше методов для извлечения нужной единицы из экземпляра Duration:

System.out.println(Duration.of(1, ChronoUnit.DAYS).getSeconds()); // 86400
System.out.println(Duration.of(1, ChronoUnit.HOURS).getSeconds()); // 3600
System.out.println(Duration.of(90, ChronoUnit.MINUTES).getSeconds()); // 5400
System.out.println(Duration.of(90, ChronoUnit.SECONDS).getSeconds()); // 90
System.out.println(Duration.of(90, ChronoUnit.SECONDS).getNano()); // 0
System.out.println(Duration.of(90, ChronoUnit.NANOS).getNano()); // 90

У него есть два метода, работающих с указанными единицами измерения: getSeconds() и getNano(), каждый из которых возвращает свой компонент.
Таким образом, если блок содержит секунды и наносекунды, getSeconds() вернет только секунды, а второй вернет только наносекунды.

Duration duration = Duration.ofSeconds(3675, 75);

System.out.println(duration); // PT1H1M15.000000075S
System.out.println(duration.getSeconds()); // 3675
System.out.println(duration.getNano()); // 75

Кроме того, вы можете использовать метод get(), если вы не хотите явно указывать единицу измерения, а передаете требуемую единицу измерения 
в качестве аргумента при ее вызове:

Duration duration = Duration.of(10, ChronoUnit.MINUTES);
System.out.println(duration.get(ChronoUnit.SECONDS)); // 600

Класс Duration предоставляет те же методы для сложения и вычитания своих единиц.

Duration duration = Duration.of(90, ChronoUnit.MINUTES);

System.out.println(duration.addTo(LocalTime.of(19, 5, 23))); // 20:35:23
System.out.println(duration.subtractFrom(LocalTime.of(19, 5, 23))); // 17:35:23
System.out.println(duration); // PT1H30M

Если вы внимательно рассмотрите два примера кода в этом разделе и их результаты, вы увидите, что методы работают так же, как и их 
эквиваленты Period.

Duration duration = Duration.of(90, ChronoUnit.MINUTES);

System.out.println(duration.plus(Duration.of(10, ChronoUnit.MINUTES))); // PT1H40M
System.out.println(duration.minus(Duration.of(10, ChronoUnit.MINUTES))); // PT1H20M
System.out.println(duration); // PT1H30M


============================================================Instant========================================================================
Пакет java.time предоставляет нам классы для работы с хронографическими единицами. В этом разделе вы познакомитесь с классом Instant: 
модулем даты и времени, подходящим для захвата timestamps событий во время выполнения приложения. Вы узнаете, как создавать эти юниты и 
выполнять с ними различные операции. Instant имеет много общего с классом LocalDateTime, но у них также есть различия, которые эта теория 
поможет вам обнаружить.

Единицы Instant создаются аналогично единицам класса Period и Duration. Он предоставляет статические методы для создания даты и времени в 
формате ISO 8601. Instant значения хранятся в переменной long, в которой хранятся секунды, отсчитываемые от Java epoch, и в переменной int, 
в которой хранятся наносекунды секунд. Java epoch — это распространенный формат представления даты и времени, который отсчитывает дату и 
время относительно 1 января 1970 года (полночь UTC/GMT), что выглядит как 1970-01-01T00:00:00Z в формате ISO 8601. Это значение можно 
получить с помощью статического поля Instant.EPOCH.

Instant epoch = Instant.EPOCH;
System.out.println(epoch); // 1970-01-01T00:00:00Z

В приведенном выше коде последняя буква Z означает идентификатор часового пояса, который в нашем случае равен нулю. Итак, он показывает 
нам время Java epoch часового пояса GMT0. Конечно, вы можете получить время любой зоны, которая вам нужна. Мы покажем, как это сделать 
позже в этом разделе.

Итак, в Java при работе с классом Instant вы указываете дату до или после Java epoch, считая время в секундах и наносекундах. Давайте 
начнем с трех основных методов, которые вы, вероятно, будете использовать чаще всего:

long posValue = 1234567890L;
long negValue = -1234567890L;

// Adding specified milliseconds to epoch
Instant milli = Instant.ofEpochMilli(posValue); // 1970-01-15T06:56:07.890Z
// Adding specified seconds to epoch
Instant second = Instant.ofEpochSecond(posValue); // 2009-02-13T23:31:30Z
// Adding specified seconds and nanoseconds to epoch
Instant secondNano = Instant.ofEpochSecond(posValue, 123L); // 2009-02-13T23:31:30.000000123Z
// Adding specified seconds and nanoseconds to epoch. Version 2
Instant nanoRounded = Instant.ofEpochSecond(posValue, 1_000_000_123L); // 2009-02-13T23:31:31.000000123Z


// Subtracting specified milliseconds from epoch
Instant milli = Instant.ofEpochMilli(negValue); // 1969-12-17T17:03:52.110Z
// Subtracting specified seconds from epoch
Instant second = Instant.ofEpochSecond(negValue); // 1930-11-18T00:28:30Z
// Subtracting specified milliseconds and nanoseconds from epoch
Instant secondNano = Instant.ofEpochSecond(negValue, -150L); // 1930-11-18T00:28:29.999999850Z
// Subtracting specified milliseconds and nanoseconds from epoch. Version 2
Instant nanoRounded = Instant.ofEpochSecond(negValue, -1_000_000_150L); // 1930-11-18T00:28:28.999999850Z

Хотя ofEpochSecond(long epochSecond, long nanoAdjustment) принимает переменную типа long, она округляет каждые 1 миллиард наносекунд до 
секунды и прибавляет к epochSecond, а остальное сохраняется в переменной типа int, как мы упоминали ранее.

Мы создали даты больше, чем 1 января 1970 года (midnight UTC/GMT), передав положительные значения в методы, и меньшие единицы, передав 
отрицательные значения. Все они показывают время часового пояса GMT0. Будет много ситуаций, когда вам 
нужно будет получить Instant для данного часового пояса. В таких случаях вы можете использовать класс ZoneId для указания зоны:

Instant instant = Instant.ofEpochSecond(1234567890L);
       
System.out.println(instant); // 2009-02-13T23:31:30Z 
System.out.println(instant.atZone(ZoneId.of("GMT+4"))); // 2009-02-14T03:31:30+04:00[GMT+04:00]
System.out.println(instant.atZone(ZoneId.of("+04:00"))); // 2009-02-14T03:31:30+04:00
System.out.println(instant.atZone(ZoneId.of("Asia/Yerevan"))); // 2009-02-14T03:31:30+04:00[Asia/Yerevan]
System.out.println(instant.atZone(ZoneId.systemDefault())); // 2009-02-14T03:31:30+04:00[Asia/Yerevan]
        
System.out.println(ZoneId.systemDefault().getId()); // Asia/Yerevan
System.out.println(ZoneId.systemDefault().getRules()); // ZoneRules[currentStandardOffset=+04:00]

Если вы не знаете свой идентификатор часового пояса или offset (разницу между указанным часовым поясом и GMT0), вам помогут последние две 
строки кода выше. В нашем случае это часовой пояс Армения/Ереван.

Следующий метод создания модулей Instant — Instant.parse(), который создает объект модуля, принимая текст и преобразовывая его в тип Instant.

Instant instant = Instant.parse("2009-02-14T03:31:30Z");
    
System.out.println(instant); // 2009-02-14T03:31:30Z
System.out.println(instant.atZone(ZoneId.of("GMT+4"))); // 2009-02-14T07:31:30+04:00[GMT+04:00]

Теперь, когда вы знаете, как создавать Instant, давайте рассмотрим другие его методы, которые помогают нам выполнять различные виды 
операций. Мы начнем с простой пары методов isBefore()/isAfter(), сравнивающих хронологический порядок двух единиц.

Instant instant1 = Instant.ofEpochSecond(123456L);
Instant instant2 = Instant.ofEpochSecond(123456789L);
    
System.out.println(instant1.isAfter(instant2)); // false
System.out.println(instant1.isBefore(instant2)); // true

Помимо того, что эти два метода возвращают boolean результат сравнения, класс реализует метод compareTo() из интерфейса Comparable:

Instant instant1 = Instant.ofEpochSecond(123456L);
Instant instant2 = Instant.ofEpochSecond(123456789L);

System.out.println(instant1.compareTo(instant2)); // -1

Работая с единицами даты и времени, вам обязательно нужно будет прибавить или вычесть две единицы в какой-то момент.
Этот класс не реализует методы addTo() и subtractFrom(), которые реализованы в классах Period и Duration, но он реализует некоторые другие: 
minus(), plus() и их "подверсии", такие как minusSeconds(), plusSeconds() и так далее.

Instant instant = Instant.ofEpochSecond(123456L);

System.out.println(instant); // 1970-01-02T10:17:36Z

System.out.println(instant.minus(Period.ofDays(1))); // 1970-01-01T10:17:36Z
System.out.println(instant.minus(Duration.ofDays(1))); //  1970-01-01T10:17:36Z
System.out.println(instant.minus(1, ChronoUnit.DAYS)); // 1970-01-01T10:17:36Z

System.out.println(instant.plus(Period.ofDays(1))); // 1970-01-03T10:17:36Z
System.out.println(instant.plus(Duration.ofDays(1))); // 1970-01-03T10:17:36Z
System.out.println(instant.plus(1, ChronoUnit.DAYS)); // 1970-01-03T10:17:36Z

System.out.println(instant); // 1970-01-02T10:17:36Z

Эти два метода имеют ограничения в отношении поддерживаемых типов единиц измерения. Они принимают единицы меньше дней (включительно).

Instant instant = Instant.ofEpochSecond(123456L);
 
System.out.println(instant.minus(Period.of(123, 12, 3))); // UnsupportedTemporalTypeException
System.out.println(instant.plus(1, ChronoUnit.WEEKS)); // UnsupportedTemporalTypeException
        
System.out.println(instant.plus(Period.ofWeeks(1))); // 1970-01-09T10:17:36Z

Здесь все строки, кроме последней, вызовут исключение. Мы не скажем вам почему: проведите небольшое исследование, изучите код и не 
стесняйтесь поделиться ответом с другими учащимися. В этом классе есть еще один интересный метод для вычисления разницы между двумя 
единицами измерения. Он показывает время, пока другая единица Instant не будет представлена ​​в виде указанной единицы:

Instant instant = Instant.ofEpochSecond(100200300L);
System.out.println(Instant.EPOCH.until(instant, ChronoUnit.DAYS)); // 1159
System.out.println(Instant.EPOCH.until(instant, ChronoUnit.HOURS)); // 27833

Теперь давайте взглянем на группу похожих методов, выполняющих операции получения из модуля Instant. Для этой цели существует три разных 
метода, которые будут показывать разные результаты в зависимости от того, как вы создали модуль Instant.

Instant ofEpochSecond = Instant.ofEpochSecond(123456L, 789L);
System.out.println(ofEpochSecond); // 1970-01-02T10:17:36.000000789Z
System.out.println(ofEpochSecond.getEpochSecond()); // 123456

System.out.println(ofEpochSecond.get(ChronoField.MICRO_OF_SECOND)); // 0
System.out.println(ofEpochSecond.get(ChronoField.MILLI_OF_SECOND)); // 0
System.out.println(ofEpochSecond.get(ChronoField.NANO_OF_SECOND)); // 789

System.out.println(ofEpochSecond.getLong(ChronoField.INSTANT_SECONDS)); // 123456
System.out.println(ofEpochSecond.getLong(ChronoField.MICRO_OF_SECOND)); // 0
System.out.println(ofEpochSecond.getLong(ChronoField.MILLI_OF_SECOND)); // 0
System.out.println(ofEpochSecond.getLong(ChronoField.NANO_OF_SECOND)); // 789

Первый метод getEpochSecond() возвращает long значение, в котором хранятся единицы секунд. Два других работают аналогично, но метод 
get() возвращает значение указанной единицы измерения как int, а метод getLong() возвращает long. Поскольку ofEpochSecond() не использует 
миллисекунды, get(ChronoField.MICRO_OF_SECOND) и get(ChronoField.MILLI_OF_SECOND) возвращают ноль. Вызовы тех же методов с теми же 
аргументами не возвращали бы ноль, если бы модуль Instant был создан с использованием метода ofEpochMilli().

Обратите внимание, что оба метода get() и getLong() принимают только те единицы ChronoField, которые вы видите в приведенном выше коде. 
Передача других типов вызовет исключение UnsupportedTemporalTypeException.

Хотя Instant и LocalDateTime являются единицами даты и времени, они совершенно разные по своей природе. Instant — это представление 
момента на временной шкале относительно java epoch. LocalDateTime представляет собой комбинацию календарной даты и времени. 
Instant хранит свое значение в секундах и наносекундах, а LocalDateTime хранит его как пару объектов LocalDate и LocalTime. Наконец, 
LocalDateTime не содержит никакой информации о часовом поясе, но если вы создадите его объект с помощью метода now(), он будет создан в 
зависимости от зоны вашей системы по умолчанию. С другой стороны, Instant содержит эту информацию и в любом случае показывает зону 
GMT0 по умолчанию.

Instant instant = Instant.now(); // System time zone independent, shows GMT0
LocalDateTime dateTime = LocalDateTime.now(); // System time zone dependent


===================================================ZonedDateTime and OffsetDateTime========================================================
Вы, наверное, уже знаете, что время в мире разделено на часовые пояса. В программировании часто бывают ситуации, когда нужно работать с 
определенным часовым поясом. Базовые классы LocalTime и LocalDateTime не обрабатывают часовые пояса. Для этого в Java реализованы 
специальные классы, позволяющие работать со временем с учетом разных часовых поясов. Это классы даты и времени ZonedDateTime и 
OffsetDateTime. В этой теме вы познакомитесь с этими классами, узнаете об их назначении и о том, как с ними работать. Они очень похожи 
на класс Instant, поэтому, если вы знакомы с этим классом, вам будет проще ориентироваться в этой теме.

Прежде чем изучать упомянутые выше классы, давайте сначала изучим остальные три, которые позволяют им работать с часовыми поясами. Это 
классы ZoneId, ZoneRules и ZoneOffset. 

- ZoneId — это класс, описывающий часовой пояс как фиксированное смещение, например, +04:00, GMT+4 или UTC+04:00, или регион, такой как 
Asia/Yerevan и т. д. Этот класс связан с классом ZoneRules, который определяет, когда и как изменяется смещение. Класс ZoneId показывает 
не только текущие правила часового пояса, но и прошлые правила. Например, с 2022 года в Армении не используется летнее время, но в 1999 
оно существовало:

LocalDateTime pastSummerTime = LocalDateTime.of(1999, 9, 15, 13, 00);
LocalDateTime pastWinterTime = LocalDateTime.of(1999, 1, 15, 13, 00);

LocalDateTime summerTime2022 = LocalDateTime.of(2022, 9, 15, 13, 00);
LocalDateTime winterTime2022 = LocalDateTime.of(2022, 1, 15, 13, 00);

System.out.println(pastSummerTime.atZone(ZoneId.of("Asia/Yerevan"))); // 1999-09-15T13:00+05:00[Asia/Yerevan]
System.out.println(summerTime2022.atZone(ZoneId.of("Asia/Yerevan"))); // 2022-09-15T13:00+04:00[Asia/Yerevan]

System.out.println(pastWinterTime.atZone(ZoneId.of("Asia/Yerevan"))); // 1999-01-15T13:00+04:00[Asia/Yerevan]
System.out.println(winterTime2022.atZone(ZoneId.of("Asia/Yerevan"))); // 2022-01-15T13:00+04:00[Asia/Yerevan]

Как видите, есть разница в часовом поясе в два года. Теперь давайте разберемся, как класс ZoneId получает информацию о часовых поясах:

LocalDateTime  past = LocalDateTime.of(1999, 9, 15, 13, 00);
LocalDateTime  by2022 = LocalDateTime.of(2022, 9, 15, 13, 00);
ZoneRules  rules = ZoneId.of("Asia/Yerevan").getRules();

System.out.println(ZoneId.of("Asia/Yerevan").getRules()); // ZoneRules[currentStandardOffset=+04:00]
System.out.println("Fixed Offset: "  + rules.isFixedOffset()); // Fixed Offset: false
System.out.println("Past summer offset: "  + rules.getOffset(past)); // Past summer offset: +05:00
System.out.println("Current summer offset: "  + rules.getOffset(by2022)); // Current summer offset: +04:00

Пример выше ясно показывает назначение класса ZoneRules. Внутри класса ZoneId есть метод getRules(), возвращающий объект ZoneRules, 
который дает нам доступ к другим методам ZoneRules.

- ZoneOffset представляет фиксированное смещение часового пояса. Его значение может меняться в зависимости от времени года, если в 
указанном регионе используется метод перехода на летнее время.

ZoneOffset zoneOffset = ZoneOffset.of("+04:00");
ZoneOffset zoneOffsetHours = ZoneOffset.ofHours(4);
ZoneOffset zoneOffsetHoursMinutes = ZoneOffset.ofHoursMinutes(4, 30);

Он расширяет ZoneId и описывает время, на которое данный часовой пояс отличается от времени по Гринвичу. Если у одного региона может 
быть несколько смещений, то одно смещение может представлять несколько регионов (стран, городов).

Обратите внимание, что есть регионы, где смещение содержит не только часы, но и минуты:

System.out.println(ZoneId.of("Iran").getRules()); // Iran ZoneRules[currentStandardOffset=+03:30]
System.out.println(ZoneId.of("Asia/Kolkata").getRules()); // ZoneRules[currentStandardOffset=+05:30]

Теперь, когда вы познакомились с классами, предоставляющими операции с часовыми поясами, давайте узнаем, как использовать их для 
создания модулей ZonedDateTime и OffsetDateTime. Вы изучите три метода: of(), from() и parse(). Это общие методы пакета java.time. 
Первый метод имеет множество вариаций по количеству и типу принимаемых параметров. Мы рассмотрим некоторые из них, а другие вы легко 
сможете изучить самостоятельно.

LocalDate localDate = LocalDate.of(1991, 4, 15);
LocalTime localTime = LocalTime.of(18,30);
        
LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);
ZoneId zoneId = ZoneId.of("Asia/Yerevan");
ZoneOffset zoneOffset = ZoneOffset.of("+04:00");

System.out.println(ZonedDateTime.of(localDate, localTime, zoneId)); // 1991-04-15T18:30+04:00[Asia/Yerevan]
System.out.println(ZonedDateTime.ofInstant(Instant.EPOCH, zoneId)); // 1970-01-01T04:00+04:00[Asia/Yerevan]

System.out.println(OffsetDateTime.of(localDateTime, zoneOffset)); // 1991-04-15T18:30+04:00
System.out.println(OffsetDateTime.ofInstant(Instant.EPOCH, zoneId)); // 1970-01-01T04:00+04:00

Как видите, вы можете получить необходимые единицы из объекта Instant. Аналогичный подход реализован в классе Instant. 
Можно создать свои единицы, передав объекты ZonedDateTime или OffsetDateTime в метод Instant.from() и получить Instant. С помощью 
метода from() вы можете создавать объекты одного класса, передавая в качестве аргумента объект другого класса:

ZonedDateTime zonedDateTime1 = ZonedDateTime.from(OffsetDateTime.now());
ZonedDateTime zonedDateTime2 = ZonedDateTime.from(Instant.now());

OffsetDateTime offsetDateTime1 = OffsetDateTime.from(ZonedDateTime.now());
OffsetDateTime offsetDateTime2 = OffsetDateTime.from(LocalTime.now());

Метод parse() ведет себя как тот же метод из классов Period, Duration или Instant. Он принимает текст и анализирует его в 
соответствующий экземпляр класса.

ZonedDateTime.parse("1991-04-15T18:30+04:00[Asia/Yerevan]");
OffsetDateTime.parse("1970-01-01T04:00+04:00");

В этом разделе вы рассмотрите примеры с различными методами. Вы поймете, как использовать методы, знакомые вам по классу Instant, а 
также некоторые другие новые методы. Давайте начнем с изучения того, как сравнивать единицы этих классов. Первый подход описан ниже:

LocalDate localDate = LocalDate.of(1991, 4, 15);
LocalTime localTime = LocalTime.of(18,30);
        
LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);
ZoneId zoneId = ZoneId.of("Asia/Yerevan");
ZoneOffset zoneOffset = ZoneOffset.from(LocalDateTime.now().atZone(zoneId));

// unit1.toInstant().isBefore(unit2.toInstant())
ZonedDateTime.of(localDateTime, zoneId).isBefore(ZonedDateTime.of(LocalDateTime.now(), zoneId));
// unit1.toInstant().isAfter(unit2.toInstant())
ZonedDateTime.of(localDateTime, zoneId).isAfter(ZonedDateTime.of(LocalDateTime.now(), zoneId));

// unit1.toInstant().isBefore(unit2.toInstant())
OffsetDateTime.of(localDateTime, zoneOffset).isBefore(OffsetDateTime.of(LocalDateTime.now(), zoneOffset));
// unit1.toInstant().isAfter(unit2.toInstant())
OffsetDateTime.of(localDateTime, zoneOffset).isAfter(OffsetDateTime.of(LocalDateTime.now(), zoneOffset));

В комментариях к приведенному выше примеру вы можете увидеть, как на самом деле методы isBefore() и isAfter() сравнивают объекты. 
Другой метод сравнения — это реализация Comparable#compareTo(), которая, вероятно, вам знакома. Для единиц ZonedDateTime он работает, 
как и ожидалось, возвращая -1, 0 или 1, но при работе с единицами OffsetDateTime возвращает разницу в годах:

LocalDate localDate1 = LocalDate.of(1991, 4, 15);
LocalTime localTime1 = LocalTime.of(18,30);

LocalDate localDate2 = LocalDate.of(1995, 5, 21);
LocalTime localTime2 = LocalTime.of(18,30);

LocalDateTime localDateTime1 = LocalDateTime.of(localDate1, localTime1);
LocalDateTime localDateTime2 = LocalDateTime.of(localDate2, localTime2);

ZoneOffset zoneOffset = ZoneOffset.of("+04:00");

OffsetDateTime offsetDateTime1 = OffsetDateTime.of(localDateTime1, zoneOffset);
OffsetDateTime offsetDateTime2 = OffsetDateTime.of(localDateTime2, zoneOffset);

System.out.println(offsetDateTime1.compareTo(offsetDateTime2)); // -4
System.out.println(offsetDateTime2.compareTo(offsetDateTime1)); // 4

Следующая пара также заслуживает внимания. Оба выполняют сравнение на равенство, но по-разному:

LocalDate localDate = LocalDate.of(1991, 4, 15);
LocalTime localTime = LocalTime.of(18,30);
LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);

ZoneId zoneId = ZoneId.of("Asia/Yerevan");
ZoneOffset zoneOffset = ZoneOffset.from(LocalDateTime.now().atZone(zoneId));

ZonedDateTime zonedDateTime1 = ZonedDateTime.of(localDateTime, zoneOffset);
ZonedDateTime zonedDateTime2 = ZonedDateTime.of(localDateTime, zoneId);

System.out.println(zonedDateTime1.equals(zonedDateTime2)); // false
// unit1.toInstant().equals(unit2.toInstant())
System.out.println(zonedDateTime1.isEqual(zonedDateTime2)); // true

OffsetDateTime offsetDateTime1 = OffsetDateTime.ofInstant(Instant.ofEpochSecond(0), ZoneOffset.of("+03:00"));
OffsetDateTime offsetDateTime2 = OffsetDateTime.ofInstant(Instant.EPOCH, zoneId);

System.out.println(offsetDateTime1.equals(offsetDateTime2)); // false
// unit1.toInstant().equals(unit2.toInstant())
System.out.println(offsetDateTime1.isEqual(offsetDateTime2)); // true

При сравнении методом isEqual() вы сравниваете моменты на временной шкале, где часовой пояс не имеет значения. Что касается сравнения 
по equals(), то оно требует сравнения по всем значениям полей объекта, и вы получите ложный результат.

Эти два класса, как и другие из того же пакета, предоставляют различные варианты метода get(), такие как getMonth(), getHour(), 
getSecond(), getZone(), getOffset() и т. д. Вы уже должны быть знакомы с ними, поэтому давайте пропустим примеры кода для этих методов. 
То же самое можно сказать и о методах minus(), plus() и until(). На практике вы будете сталкиваться с ситуациями, когда вам нужно будет 
получить единицу даты-времени из другой единицы, изменив часовой пояс.

ZoneId zone0 = ZoneId.of("GMT+0");
ZoneId londonZone = ZoneId.of("Europe/London");
ZoneId yerevanZone = ZoneId.of("Asia/Yerevan");
ZoneOffset offset0 = ZoneOffset.of("+00:00");
ZoneOffset londonOffset = ZoneOffset.of("+01:00");
ZoneOffset yerevanOffset = ZoneOffset.of("+04:00");
        
LocalDateTime localDateTime = LocalDateTime.of(1991, 4, 15, 13, 00);
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, yerevanZone);
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, yerevanOffset);

System.out.println(zonedDateTime.withZoneSameInstant(zone0)); // 1991-04-15T09:00Z[GMT]
System.out.println(zonedDateTime.withZoneSameInstant(londonZone)); // 1991-04-15T10:00+01:00[Europe/London]
System.out.println(zonedDateTime.withZoneSameLocal(londonZone)); // 1991-04-15T13:00+01:00[Europe/London]

System.out.println(offsetDateTime.withOffsetSameInstant(offset0)); // 1991-04-15T09:00Z
System.out.println(offsetDateTime.withOffsetSameInstant(londonOffset)); // 1991-04-15T10:00+01:00
System.out.println(offsetDateTime.withOffsetSameLocal(yerevanOffset)); // 1991-04-15T13:00+01:00

Для этой цели можно использовать два метода. withZoneSameInstant() возвращает копию объекта, вычисляя его Instant и изменяя часовой пояс, 
а withZoneSameLocal() возвращает копию той же даты и времени, но с измененным часовым поясом.

Старый класс java.util.Date не представлял никаких часовых поясов, а всего лишь несколько миллисекунд с Epoch Java. Используя его, 
разработчики часто сталкивались с трудностями при работе с часовыми поясами. Начиная с Java 8, новые дополнения java.time решили многие 
проблемы, которые помогают разработчикам обрабатывать операции, связанные с часовыми поясами и переходом на летнее время.





=============================================================================================================

IS-A - позволяет проверить расширяет ли одна сущность другую ( треугольник - фигура, кот - семейство кошачих)

Перегрузка метода - наличие нескольких методов с одним именем, но разными наборами аргументов(полиморфизм не
задействуется)

instanceof - оператор для проверки типа переменной
if (o instanceof Dog) {Dog d = (Dog) o;}

ключевое слово abstract необходим для создания абстрактного класса, чтобы не создавались объекты этого
класса:
- абстрактный класс может содержать абстрактные и необстрактные методы
- если в классе есть хотя бы 1 абстрактный метод, то он должен быть абстрактным
- у абстрактного метода нет тела
- все абстрактные методы должны быть реализованы в первом конкретном подклассе

ключевое слово interface при создании класса решает проблему множественного наследования(все методы делаются
абстрактными, подклассы будут обязаны переопределить методы в первом конкретном классе)
public interface(вместо class) Pet{}
public class Dog extends(расширяет) Canine implements(исп вслед за изменением интерфейса) Pet{}
Класс может использовать несколько интерфейсов
public class Dog extends Animal implements Pet, Saveable, Paintable{}

ключевое слово super может запустить из самого дочернего класса вариант метода из родительского класса
super.runReport();

2
public abstract class Top{}
public class Tip extends Top{}
3
public abstract class Fee{}
public abstract class Fi extends Fee{}
4
public interface Foo{}
public class Bar implements Foo{}
public class Baz extends Bar{}
5
public interface Zeta{}
public interface Beta{}
public class Alpha implements Zeta{}
public class Delta extends Alpha implements Beta{}

Статические методы используют только статические переменные
Статические методы используют только статические методы
У статической переменной одно и то же значение для всех экземпляров класса
Статические переменные общедоступны. Все экземпляры одного класса содержат общую копию статической переменной
Статические переменные в классе инициализируются до того, как станет возможным создать объект этого класса
Доступ к статическому методу и переменной получают через имя класса Player.playCount; Player.play();

Статические переменные с ключевым словом final являются константами и должны быть написаны в верхнем 
регистре public static final double PI = 3,141592
Константы должны быть проинициализированы:
1) public static final double PI = 3,141592
2) public class Bar {                            <- статическая инициализация
      public static final double BAR_SIGN;

      static{
	  BAR_SIGN = (double) Math.random();
}
} 

Финализированный метод не может быть переопределён
Финализированный класс не может быть расширен(унаследован дочерними классами)

=============================================================Математические методы:=================================================
Math.random()
Возвращает переменную типа double между 0.0 и 1.0(не включительно)
double r1 = Math.random();
int r2 = (int) (Math.random() * 5);

Math.abs()
Возвращает переменную типа double в виде абсолютного значения аргумента. Метод перегружен - если передать
int, то будет возвращён int, если double, то double
int x = Math.abs(-240); // Возвращает 240
double d = Math.abs(240.45); // Возвращает 240.45

Math.round()
Возвращает значение типа int или long(в зависимости от типа аргумента - float или double), округлённое до
ближайшего целого
int x = Math.round(-24.8f); // Возвращает -25
int y = Math.round(24.45f); // Возвращает 24

Math.min()
Возвращает наименьший из двух аргументов. Метод перегружен и может принимать значения типов int, long, float
или double
int x = Math.min(24,240); // Возвращает 24
double y = Math.min(90876.5, 90876.49); // Возвращает 90876.49

Math.max()
-//-
int x = Math.max(24,240);

================================================Преобразование String в значение простого типа=====================================
String s = "2";
int x = Integer.parseInt(s);
double d = Double.parseDouble("420.24");
boolean b = new Boolean("true").booleanValue();

======================================================Преобразование числа в String================================================

double d = 42.5;
String doubleString = "" + d;

double d = 42.5;
String doubleString = Double.toString(d);

===============================================================Форматизация========================================================
%[номер аргумента] [флаги] [ширина] [.разрядность] тип
format("%,6.1f", 42.000);

a += b+c аналогично a=a+b+c

Блок try/catch необходим для обработки исключений
import javax.sound.midi.*
public class MusicTest1{
	public void play(){
		try{
			Sequencer sequencer = MidiSystem.getSequencer();//Помещаем опасные строки в блок try
			System.out.println("Успешно получили синтезатор");
		   } catch (MidiUnavailableException ex) { //блок catch на случай, если произойдёт исключительная ситуация, т.е. если методом getSequencer() будет выдано исключение MidiUnavailableException 
		   	System.out.println("Неудача");
		   }
}
}

throws объявляет, что метод выбрасывает BadException

public void takeRisk() throws BadException{
	if (abandonAllHope) {
	  throw new BadException();
}
}

public void crossFingers() {
	try {
	  anObject.takeRisk();
        } catch (BadException ex) {
	  System.out.println("Aax!");
	  ex.printStackTrace(); // Если нельзя справиться с исключением, получаем трассировку стека
}
}

Finally - блок кода, который должен выполниться независимо от того, было ли выброшено исключение

try {
  turnOvenOn();
  x.bake();
} catch (BakingException ex) {
	ex.printStackTrace();
} finally {
	turnOvenOff();
}
Если блоки try/catch содержат return, поток перейдёт к finally, после чего вернётся к return

Нельзя использовать блоки catch или finally без try
Нельзя добавлять код между блоками try и catch
За блоком try должны следовать catch или finally
При использовании блока try только с finally всё равно нужно объявить исключение
void go() throws FooException{
	try {
	   x.doStuff();
        } finally { }
}

===================================================================================================================================
====================================================================GUI============================================================
===================================================================================================================================
import javax.swing.*
JFrame frame = new JFrame(); //создаём фрейм(окно)
JButton button = new JButton("click me"); // создаём виджет(кнопку, поле ввода и тд)
frame.getContentPane().add(button); // добавляем виджет во фрейм
frame.setSize(300, 300);
frame.setVisible(true); //выводим фрейм на экран, присваиваем размер и делаем видимым
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //завершает работу программы при закрытии окна 
(если не добавить, то приложение будет висеть на экране вечно)
источник события - объект(кнопка, переключатель), кторый запускает событие
чтобы связать событие с источником, необходимо вызвать регистрационный метод источника. Методы для
регистрации всегда принимают следующий вид: add<ТипСобытия>Listener (button.addActionListener(this);)

frame.getContentPane().add(BorderLayout.CENTER, button) //WEST, EAST, SOUTH, NORTH

public void changeIt() {			//изменить текст кнопки после нажатия на неё
	button.setText("I've been clicked!");
}

import java.awt.event.* //импорт пакета с ActionListener и ActionEvent

Внутренний класс может использовать все методы и переменные внешнего класса даже если те являются 
приватными. Внутренний класс использует эти переменные и методы, как будто они объявлены во внутреннем 
классе.
- внутренний объект должен быть привязан в определённому внешнему объекту в куче
class MyOuterClass{
    private int x;
	class MyInnerClass{
		void go(){
		    x = 42;		
}
}
}

Создать экземпляр внутреннего класса из кода запущенного за пределами внешнего класса:
class Foo{
	public static void main (String[] args) {
		MyOuter outerObj = new MyOuter();
		MyOuter.MyInner innerObj = outerObj.new MyInner();
}
}

Виджет - это компонент и наследует класс javax.swing.JComponent

=============================================================Диспетчер компановки====================================================
JPanel panelA = new JPanel();
JPanel panelB = new JPanel();
panelB.add(new JButton("Кнопка 1");
panelB.add(new JButton("Кнопка 2"));
panelB.add(new JButton("Кнопка 3"));
panelA.add(panelB);
Диспетчер компановки панели В управляет размером и расположением трёх кнопок, а диспетчер панели А
управляет размером и расположением панели В.

3 вида Диспетчеров:
1) BorderLayout - делит фоновый компонент на пять областей, в каждую область можно добавить один 
компонент, является диспетчером компановки фрейма по умолчанию(находится в пакете java.awt.*)
2) FlowLayout - каждый компонент имеет желаемый размер и все они размещаются слква направо, в порядке
добавления, с возможностью переноса на новую строку. Когда компонент не помещается по горизонтали, он 
переносится на следующую строку в компановке. Является диспетчером для панели по умолчанию
3) BoxLayout - все компоненты имеют собственный размер и располагаются в порядке добавления, позволяет
расположить компоненты вертикально(сверху вниз по одному на строку)
panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
//изменяем диспетчер компановки на новый экземпляр BoxLayout
//конструктору диспетчера BoxLayout нужно знать какие компоненты он размещает(панель) и какую ось
использовать(Y_AXIS вертикальная)

==============================================Запись сериализованного объекта в файл:==============================================
1) создаём объект FileOutputStream
FileOutputStream fileStream = new FileOutputStream("MyGame.ser");
//создаём объект FileOutputStream. Этот объект знает как подключиться к файлу и как создать его
2) Создаём ObjectOutputStream
ObjectOutputStream os = new ObjectOutputStream(fileStream);
// ObjectOutputStream позволит записывать объекты, но не сможет напрямую подключаться к файлу. Ему
потребуется помощник. Это называется связыванием одного потока с другим
3) Записываем объект
os.writeObject(one);   // Сериализуем объекты, на которые указывают ссылки one, two, three и записываем
os.writeObject(two);   // их в файл MyGame.ser
os.writeObject(three);
4) Закрываем ObjectOutputStream
os.close();
// Закрывая поток верхнего уровня, мы закрываем и исходный поток, FileOutputStream и файл закроются
автоматически

FileOutputStream записывает байты в файл -> ObjectOutputStream преобразует объекты в данные, которые
могут быть записаны в поток

Чтобы класс был сериализуемым необходимо добавить интерфейс Serializable
import java.io.* // Интерфейс находится в этом пакете
public class Box implements Serializable

Если нет необходимости сохранять переменную в сериализуемом классе её необходимо пометить как transient(переходный)
transient String currentID;

=====================================================Десериализация(восстановление) объекта:=======================================
1) Создаём объект FileInputStream
FileInputStream fileStream = new FileInputStream("MyGame.ser");
// Создаём объект FileInputStream. Он знает как соединиться с существующим файлом
// Если файла MyGame.ser не существует, то будет выброшено исключение
2) Создаём ObjectInputStream
ObjectInputStream os = new ObjectInputStream(fileStream);
// ObjectInputStream позволяет прочитать объекты, но не может напрямую соединиться с файлом. Ему нужно
подключиться к потоку соединения, к FileInputStream
3) Читаем объекты
Object one = os.readObject();   // Каждый раз когда мы вызываем метод readObject(), мы получаем следующий
Object two = os.readObject();   // объект в потоке. В итоге мы будем прочитывать их в том же порядке, в 
Object three = os.readObject(); // котором они были записаны
4) Приводим объекты
GameCharacter elf = (GameCharacter) one;
GameCharacter troll = (GameCharacter) two;
GameCharacter magician = (GameCharacter) three;
// Возвращаемое значение метода readObject() имеет тип Object, так что нужно привести его обрактно
к типу, которому оно действительно принадлежит
5) Закрываем ObjectInputStream
os.close()

Статические переменные не сериализуются

Запись строки в текстовый файл:
import java.io.* - необходим для fileWriter
class WriteAFile{
	public static void main(String[] args) {
		try {
			FileWriter writer = new FileWriter("Foo.txt");
			writer.write("Привет, фу")
			writer.close();
} catch(IOException ex) {ex.printStackTrace();}
}
}

=======================================================Чтение из текстового файла:=================================================
import java.io.*
class ReadAFile{
	public static void main(String[] args) {
		try{
			File myFIle = new File("MyText.txt");
			FileReader fileReader = new FileReader(fileReader); 
//FileReader - поток соединения для символов, который подключается к текстовому файлу
			BufferedReader reader = new BufferedReader(fileReader);
			String line = null;
//Переменная для временного хранения каждой строки в процессе чтения
			while((line = reader.readLine()) !=null) {
				System.out.println(line);
//Прочитай строку текста и присвой её переменной line, пока эта переменная не пуста, выводи на экран 
только что прочитанную строку
}
reader.close();
} catch(Exception ex) {ex.printStackTrace()}
}
}

Класс java.io.File представляет файл на диске, но не представляет содержимое файла. Объект File хранит
имс или путь файла или каталога на диске, но не предоставляет доступ к данным.
1) Создать объект File, представляющий существующий файл
File f = new File("MyCode.txt");
2) Создать новый каталог
File dir = new File("Chapter7);
dir.mkdir();
3) Вывести содержимое каталога:
if (dir.isDirectory()) {
	String[] dirContents = dir.list();
	for (int i = 0; i < dirContents.length; i++) {
		System.out.println(dirContents[i]);
}
}
4) Получить абсолютный путь файла или каталога:
System.out.println(dir.getAbsolutePath());
5) Удалить файл или каталог
boolean isDeleted = f.delete();

======================================Метод split() позволяет разбивать строку на части===========================================
текст 1 / текст 2
String toTest = "Текст 1/текст 2";
String[] result = toTest.split("/");
for (String token:result) {System.out.println(token);}

=======================================================Создание сокета (сетевого)===================================================
класс Socket находится в java.net.*
Socket chatSocket = new Socket("196.164.1.103", 5000)

========================================================Отправка сообщения сервером================================================
1) Создаём сокет и связываемся с сервером
Socket chatSocket = new Socket("127.0.0.1", 5000);
2) Создаём InputStreamReader и связываем его с низкоуровневым потоком через сокет
InputStreamReader stream = new InputStreamReader(chatSocket.hetInputStream());
3) Создаём BufferedReader и считываем данные
BufferedReader reader = new BufferedReader(stream);
String message = reader.readLine();

Сервер -> байты полученные от сервера -> InputStreamReader(байты преобразованы в символы) ->
-> BufferedReader(буферизованные символы) -> клиент

=====================================================Отправка сообщения клиентом===================================================
1) Создаём сокет и связываемся с сервером
2) Создаём PrintWriter и связываем его с низкоуровневым исходящим потоком, полученным из сокета
PrintWriter writer = new PrintWriter(chatSocket.getOutStream());
3) Записываем(выводим) что-нибудь
writer.println("Текст") - добавляет символ переноса строки в конце данных которые шлёт
writer.print("Текст 2") - не добавляет символ переноса строки

Клиент -> PrintWriter(сообщение) -> исходящий поток сокета(байты) -> сервер

==============================================================Создание сервера======================================================
1) Серверное приожение создаёт объект ServerSocket, указывая порт
ServerSocket serverSock = new ServerSocket(4242);
// Сервер начинает отслеживать входящие клиентские запросы на порту 4242
2) Клиент создаёт сокет и связывается с серверным приложением:
Socket sock = new Socket("190.165.1.103", 4242);
3) Сервер создаёт новый сокет для общения с этим клиентом, освобождая порт 4242 для новых клиентов
Socket sock = serverSock.accept();

=================================================================Многопоточность==================================================
1) Создаём объект Runnable (задачу для потока)
Runnable threadJob = new MyRunnable();
2) Создаём объект Thread (исполнитель) и передаём ему Runnable
Thread myThread = new Thread(threadJob);
// Создание нового потока, содержащего свой стек вызовов
3) Запускаем поток
myThread.start();
// При запуске поток берёт метод run() из объекта Runnable и помещает его на дно нового стека
// Интерфейс Runnable описывает один метод public void main run()

public class MyRunnable implements Runnable {
	public void run() {go();}
// В метод run(без аргументов) помещается задача, которую поток должен выполнить.Этот метод появляется на дне нового стека
	public void go() {doMore();}
	public void doMore() {System.out.println("Вершина стека");}
}
class ThreadTester {
	public static void main(String[] args) {
		Runnable threadJob = new MyRunnable();
		Thread myThread = new Thread(threadJob);
//Передаём экземпляр Runnable в конструктор Thread. Благодаря этому поток знает, какой метод нужно 
поместить на дно нового стека
		myThread.start();
		System.out.println("Возвращаемся в метод main");
}
}

Лучший способ чередовать потоки - метод sleep(), он выбрасывает исключения
try{
Thread.sleep(2000); //число в скобках - количество милисекунд сна
} catch(InterruptedException ex) {ex.printStackTrace()};

Чтобы метод мог выполняться одновременно только в одном потоке, необходимо использовать ключевое слово
synchronized
synchronized void makeWithdrawal(int amount){}

===========================================================Коллекции:==============================================================
TreeSet хранит элементы отсортированными и предотвращает дублирование
HashMap хранить элементы с помощью пар ключ/значение
LinkedList обеспечивает хорошую производительность, когда элементы вставляются и удаляются посередине
коллекции
HashSet предотвращает дублирование и позволяет быстро найти элемент
LinkedHashMap HashMap, который умеет запоминать порядок элементов(пары ключ/значение), можно обратиться
к последнему используемому элементу

======================================================Generics (обобщения):========================================================
1) Создание экземпляров обобщённых классов  new ArrayList<Song>()
2) Объявление и инициализация переменных, имеющих обобщённый тип 
List<Song> songlist = new ArrayList<Song>()
3) Объявление и вызов методов, которые принимают значения обобщённых типов
void foo(List<song> list)
x.foo(songList)

===================================================Создание исполняемого архива JAR================================================
1) Все class-файлы находятся в директории classes
2) Создать файл manifest.txt, который хранит инфо о классе с методом main()
файл должен содержать строку "Main-Class: MyApp" (добавлять .class в конце не нужно)
3) Запустить утилиту jar, чтобы создать jar файл с содержимым директории classes и добавить манифест
cd MiniProject/classes
jar -cvmf manifest.txt app1.jar *.class
или
jar -cvmf manifest.txt app1.jar MyApp.class

Запуск jar архива
java -jar app1.jar

===========================================Создание исполняемого архива JAR с пакетами внутри======================================
1) Все файлы с классами находятся внутри структуры пакета, на уровень ниже директории classes
2) Создать файл manifest.txt, в кот указывается main() класс и поместить в каталог classes
Main-Class: com.headfirstjava.PackageExercise(в конце строки необходимо нажать enter)
3) Запустить утилиту jar
cd MyProject/classes
jar -cvmf manifest.txt packEx.jar com
4) Запуск исполняемого java архива
java -jar packEx.jar

=========================================================Компиляция и запуск пакета================================================
cd MyProject/source
javac -d ../classes com/headfirstjava/PackageExercise.java
или
javac -d ../classes com/headfirstjava/*.java (чтобы скомпилировать все исходные файлы)
java com.headfirstjava.PackageExercise (запуск)

=========================================================Вывод содержимого jar архива==============================================
jar -tf packEx.jar (-tf table file, покажи таблицу файла jar)

============================================================Распаковка jar архива==================================================
jar -xf packEx.jar (-xf extract file)








===================================================================================================================================
========================================================JetBrains Academy============================================================
===================================================================================================================================
Reading data with a scanner

1) import java.util.Scanner;
2) Scanner scanner = new Scanner(System.in);
3)
String name = scanner.next(); //считывает одно слово

System.out.println("Hello, " + name +"!");
или
String name = scanner.nextLine(); //считывает строку

System.out.println("Hello, " + name +"!");
или
int a = scanner.nextInt(); //считывает целое число
int b = scanner.nextInt();
int sum = a + b;
System.out.println(sum);


=========================================================Арифметические операции===================================================
addition +
subtraction -
multiplication *
integer division / (целочисленное деление)
remainder % (остаток от деления)

Деление, чтобы результат получился с дробным остатком (делитель должен быть типа double, чтобы получилось)
public class Main {

    public static double divide(long a, long b) {
        double one = b;
        double result = a / one;
        return result;
    }

    /* Do not change code below */
    public static void main(String[] args) {
        final Scanner scanner = new Scanner(System.in);
        final long a = scanner.nextLong();
        final long b = scanner.nextLong();
        System.out.println(divide(a, b));
    }
}

=============================================================класс Math===========================================================
документация класса https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

1) Метод Math.min(..., ...) возвращает меньшее значение двух аргументов
int min = Math.min(11, 81); // min is 11

2) Метод Math.max(..., ...) возвращает большее значение двух аргументов
int max = Math.max(20, 30); // max is 30

3) Метод Math.abs(...) возвращает модуль числа
int abs = Math.abs(-10); // abs is 10
double dabs = Math.abs(-10.33); // dabs is 10.33

4) Метод Math.floor(...) возвращает число округлённое в меньшую сторону
double floor = Math.floor(3.78); // floor is 3.0

5) Метод Math.ceil(...) возвращает число округлённое в большую сторону
double ceil = Math.ceil(4.15); // ceil is 5.0

6) Метод Math.sqrt(...) возвращает квадратный корень из аргумента
double sqrt = Math.sqrt(2); // sqrt is 1.4142...

7) Метод Math.cbrt(...) возвращает кубический корень аргумента
double cbrt = Math.cbrt(27.0); // cbrt is 3.0

8) Метод Math.pow(..., ...) возвращает значение первого аргумента, возведенное в степень второго аргумента.
double square = Math.pow(5, 2); // the square of 5 is 25.0
double cube = Math.pow(2, 3); // the cube of 2 is 8.0

9) Метод Math.sin(...) возвращает синус заданного угла в радианах
double sin = Math.sin(pi / 2); // sin90°  is 1.0

10) Метод Math.cos(...) возвращает Косинус заданного угла в радианах
double cos = Math.cos(pi); // cos180° is -1.0

11) Метод Math.toRadians(...) преобразует угол, измеренный в градусах, в угол, измеренный в радианах (приблизительно)
double grad = Math.toRadians(30); // grad is 0.5235...

12) Метод Math.random() возвращает двойное значение с положительным знаком, больше или равным 0.0 и меньше 1.0
double random = Math.random(); // a random value >= 0.0 and < 1.0

Помимо функций, класс Math в Java содержит две общие константы:
- Math.PI отношение длины окружности к ее диаметру (число Pi)
double pi = Math.PI; // pi is 3.1415...
- Math.E является основанием натурального логарифма
double e = Math.E; // e is 2.71828...

==========================================================класс Random=============================================================
Класс Random может генерировать случайные значения различных типов, такие как int, long, double и даже boolean. Мы рассмотрим, 
как использовать этот класс для чисел

Прежде всего, необходимо импортировать класс Random
import java.util.Random;

Есть два конструктора для создания объекта этого класса:
1) Random random = new Random();
2) Random(long seed) создает новый псевдослучайный генератор с заданным начальным значением его внутреннего состояния
Random random = new Random(100000);
System.out.println(random.nextInt(5)); // it may print 0, 1, 2, 3, 4
System.out.println(random.nextInt(5)); // it may print 0, 1, 2, 3, 4
В этом случае при многократном запуске программы мы всегда будем получать на выходе одни и те же числа.

Методы:
1) int nextInt() возвращает псевдослучайное значение типа int;

2) int nextInt(int n) возвращает псевдослучайное значение типа int в диапазоне от 0 (включительно) до n (не включая n);
Random random = new Random();
System.out.println(random.nextInt(5)); // it may print 0, 1, 2, 3, 4

3) long nextLong() возвращает псевдослучайное значение типа long;
4) double nextDouble() возвращает псевдослучайное значение типа double в диапазоне от 0.0 до 1.0
5) void nextBytes(byte[] bytes) генерирует случайные байты и помещает их в предоставленный пользователем массив байтов

Пример расчёт рандомных чисел в заданном диапазоне:

import java.util.*;

public class RandomNumbersDemo {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int lower = scanner.nextInt();
        int upper = scanner.nextInt();
        Random random = new Random();

        int intervalLength = upper - lower + 1;

        System.out.println(random.nextInt(intervalLength) + lower);
        System.out.println(random.nextInt(intervalLength) + lower);
        System.out.println(random.nextInt(intervalLength) + lower);
        System.out.println(random.nextInt(intervalLength) + lower);
    }
}

input: 20 30
output:
25
26
30
20

=======================================Рандомное число из строки (Random from string)==============================================
public static String shuffle(String text) {
        char[] characters = text.toCharArray();
        for (int i = 0; i < characters.length; i++) {
            int randomIndex = (int)(Math.random() * characters.length);
            char temp = characters[i];
            characters[i] = characters[randomIndex];
            characters[randomIndex] = temp;
        }
        return new String(characters);
    }
========================================================================Char=======================================================
использование юникода
char ch = '\u0040'; // it represents '@'
System.out.println(ch); // @
The char type has a minimum value encoded as '\u0000' and the maximum value encoded as '\uffff'

It is also possible to initialize a char with a positive integer number.

char ch = 64;
System.out.println(ch); // @
The number 64 just corresponds to the Unicode hexadecimal code '\u0040'.
Any char variable may be considered as an unsigned integer value in the range from 0 to 65535.

'\n' is the newline character;
'\t' is the tab character;
'\r' is the carriage return character;
'\\' is the backslash character itself;
'\'' is the single quote mark;
'\"' is the double quote mark.
Here are several examples:
System.out.print('\t'); // makes a tab
System.out.print('a');  // prints 'a'
System.out.print('\n'); // goes to the new line
System.out.print('c');  // prints 'c'
This code prints:
  a
c


Метод Character.getNumericValue() - возвращает int значение, которое представляет собой char
char charValue = '2';
int intValue = Character.getNumericValue(charValue); // 2

Scanner scanner = new Scanner(System.in);
        String input = scanner.next();
        int sum1 = 0;
        int sum2 = 0;
        for (int i = 0; i < 6; i++) {
            char ch = input.charAt(i);
            if (i < 3) {
                sum1 += Character.getNumericValue(ch);
            } else {
                sum2 += Character.getNumericValue(ch);
            }
        }

ASCII Table(unicode)
Dec  = Decimal Value
Char = Character

'5' has the int value 53
if we write '5'-'0' it evaluates to 53-48, or the int 5
if we write char c = 'B'+32; then c stores 'b'

https://www.asciitable.com/


Dec  Char                           Dec  Char     Dec  Char     Dec  Char
---------                           ---------     ---------     ----------
  0  NUL (null)                      32  SPACE     64  @         96  `
  1  SOH (start of heading)          33  !         65  A         97  a
  2  STX (start of text)             34  "         66  B         98  b
  3  ETX (end of text)               35  #         67  C         99  c
  4  EOT (end of transmission)       36  $         68  D        100  d
  5  ENQ (enquiry)                   37  %         69  E        101  e
  6  ACK (acknowledge)               38  &         70  F        102  f
  7  BEL (bell)                      39  '         71  G        103  g
  8  BS  (backspace)                 40  (         72  H        104  h
  9  TAB (horizontal tab)            41  )         73  I        105  i
 10  LF  (NL line feed, new line)    42  *         74  J        106  j
 11  VT  (vertical tab)              43  +         75  K        107  k
 12  FF  (NP form feed, new page)    44  ,         76  L        108  l
 13  CR  (carriage return)           45  -         77  M        109  m
 14  SO  (shift out)                 46  .         78  N        110  n
 15  SI  (shift in)                  47  /         79  O        111  o
 16  DLE (data link escape)          48  0         80  P        112  p
 17  DC1 (device control 1)          49  1         81  Q        113  q
 18  DC2 (device control 2)          50  2         82  R        114  r
 19  DC3 (device control 3)          51  3         83  S        115  s
 20  DC4 (device control 4)          52  4         84  T        116  t
 21  NAK (negative acknowledge)      53  5         85  U        117  u
 22  SYN (synchronous idle)          54  6         86  V        118  v
 23  ETB (end of trans. block)       55  7         87  W        119  w
 24  CAN (cancel)                    56  8         88  X        120  x
 25  EM  (end of medium)             57  9         89  Y        121  y
 26  SUB (substitute)                58  :         90  Z        122  z
 27  ESC (escape)                    59  ;         91  [        123  {
 28  FS  (file separator)            60  <         92  \        124  |
 29  GS  (group separator)           61  =         93  ]        125  }
 30  RS  (record separator)          62  >         94  ^        126  ~
 31  US  (unit separator)            63  ?         95  _        127  DEL

===============================================floating-point types (десятичные числа)=============================================
Java имеет два основных типа для представления десятичных чисел: float и double. Они называются типами с плавающей точкой. На 
самом деле эти типы не могут представлять произвольное десятичное число, поскольку они поддерживают только ограниченное число 
значащих десятичных цифр (6-7 для float и 14-16 для double). Кроме того, double может представлять более широкий диапазон чисел, 
чем float.

В программе double выглядит как 5.2, где символ точки разделяет целые и дробные части числа.
double zero = 0.0;
double one = 1.0;
double negNumber = -1.75;
double pi = 3.1415;

Также можно присвоить int значение double переменной
double one = 1;
System.out.println(one); // 1.0 or 1,0

Если вы хотите объявить и инициализировать переменную float, вы должны пометить присвоенное значение 
специальной буквой f (float literal):
float pi = 3.1415f;
float negValue = -0.15f;

Оба типа могут хранить только ограниченное количество значащих десятичных цифр:
float f = 0.888888888888888888f; // a value with a lot of decimal digits
System.out.println(f);           // it only prints 0.8888889

Типы с плавающей запятой имеют своеобразный способ отмечать значения с помощью мантиссы:
double eps = 5e-3; // means 5 * 10^(-3) = 0.005
double n = 0.01e2; // means 0.01 * 10^2 = 1.0

Для операндов double и float оператор / выполняет деление, а не целочисленное деление.
double squaredPi = pi * pi; // 9.86902225
System.out.println(squaredPi / 2); // 4.934511125

Обратите внимание на важную вещь, которую новички часто упускают:
double d1 = 5 / 4; // 1.0
double d2 = 5.0 / 4; // 1.25

В разных системах могут использоваться разные разделители: точки или запятые. Чтобы использовать точки, можно воспользоваться
следующим сканером:
Scanner scanner = new Scanner(System.in).useLocale(Locale.US);

==========================================================================String===================================================
Можно создать объект класса String используя в конструкторе строку StringBuilder
StringBuilder a = new StringBuilder("Hello");
String b = new String(a);

Any string has two useful methods:

length() returns the number of characters in the string;

charAt(int index) returns a character by its index;
Here is an example:

String s = "Hi, all";

int len = s.length(); // the len is 7

char theFirstChar = s.charAt(0);  // 'H' has the index 0

char theFifthChar = s.charAt(4); // 'a' has the index 4

char theLastChar = s.charAt(s.length() - 1); // 'l' has the index 6

Можно перебирать символы строки с помощью цикла (while, do-while, for-loop).
String scientistName = "Isaac Newton";

for (int i = 0; i < scientistName.length(); i++) {
    System.out.print(scientistName.charAt(i) + " "); // print the current character
}

The code outputs:
I s a a c   N e w t o n 

The standard library of Java provides a lot of useful methods for processing strings:

isEmpty() returns true if the string is empty, otherwise – false;
toUpperCase() returns a new string in uppercase;
toLowerCase() returns a new string in lowercase;
startsWith(prefix) returns true if the string starts with the given string prefix, otherwise, false;
endsWith(suffix) returns true if the string ends with the given string suffix, otherwise, false.
contains(...) returns true if the string contains the given string or character;
substring(beginIndex, endIndex) returns a substring of the string in the range: beginIndex, endIndex - 1;
replace(old, new) returns a new string obtained by replacing all occurrences of old with new that can be chars or strings.
indexOf("the") возвращает индекс искомого текста

replaceAll(String regex, String replacement) данный метод заменяет в строке все вхождения подстроки regex на replacement.
в данном методе можно использовать регулярные выражения:
\D — шаблон, описывающий любой нецифровой символ;
\d — определяет любой цифровой символ, который также можно описать как [0-9];
[a-zA-Z] — шаблон, описывающий латинские символы от a до z, без учёта регистра;
Пример:
input.replaceAll("\\d",""); - удаляем все цифры в строке input

trim() returns a copy of the string obtained by omitting the leading and trailing whitespace. Note that whitespace includes not 
only space character, but mostly everything that looks empty: tab, carriage return, newline character, etc.

See the following example to better understand these methods:

String text = "The simple text string";
boolean empty = text.isEmpty(); // false
String textInUpperCase = text.toUpperCase(); // "THE SIMPLE TEXT STRING"
boolean startsWith = textInUpperCase.startsWith("THE"); // true
/* replace all space characters with empty strings */
String noSpaces = textInUpperCase.replace(" ", ""); // "THESIMPLETEXTSTRING"
String textWithWhitespaces = "\t text with whitespaces   !\n  \t";
String trimmedText = textWithWhitespaces.trim(); // "text with whitespaces   !"

String firstName = "John";
String lastName = "Smith";
// concatenation using the "+" operator
String fullName1 = firstName + " " + lastName; // "John Smith"
// concatenation using the concat method 
String fullName2 = firstName.concat(" ").concat(lastName); // "John Smith"

=====================================================StringBuilder=================================================================
Обратите внимание, что если у вас есть объект StringBuilder, вы можете получить String, используя метод toString!!!!!!!!!!!!!!!!!!!

Для класса StringBuilder метод equals() работает также как == , т.е. сравниваются адреса в ссылочных переменных

Можно создать объект класса String используя в конструкторе строку StringBuilder
StringBuilder a = new StringBuilder("Hello");
String b = new String(a);

Как вы, возможно, знаете, в Java строки неизменяемы. Это означает, что после создания строка не может быть изменена. Если мы хотим 
изменить содержимое строкового объекта, мы должны создать новую строку. Это может быть не лучшим способом, когда мы выполняем много
модификаций, потому что каждая операция создает новый объект, который плохо влияет на производительность.

К счастью, существует специальный класс StringBuilder, который используется для создания изменяемых строковых объектов. Объект 
этого класса похож на обычную строку, за исключением того, что он может быть изменен. Например, лучше использовать StringBuilder, 
чем String, где во время выполнения выполняется много конкатенаций.

Обратите внимание, что нам не нужно ничего импортировать, чтобы использовать этот класс в программах.

Можно создать пустой объект StringBuilder
StringBuilder empty = new StringBuilder();
System.out.println(empty); // ""

или передать ему строку:
StringBuilder sb = new StringBuilder("Hello!");
System.out.println(sb); // "Hello!"

Методы:
1) int length() - возвращает длину (количество символов), как для обычной строки. Этот метод не изменяет объект.
StringBuilder sb = new StringBuilder("I use Java");
System.out.println(sb.length()); // 10

2) char charAt(int index) возвращает символ, расположенный в указанном индексе. Первый символ имеет индекс 0. Этот метод не 
изменяет объект.
StringBuilder sb = new StringBuilder("I use Java");
System.out.println(sb.charAt(0)); // 'I'
System.out.println(sb.charAt(6)); // 'J'

3) void setCharAt(int index, char ch) заменяет символ, расположенный в указанном индексе, на ch.
StringBuilder sb = new StringBuilder("start");
sb.setCharAt(1, 'm');
System.out.println(sb); // "smart"

4) StringBuilder deleteCharAt(int index) удаляет символ в указанной позиции.
StringBuilder sb = new StringBuilder("dessert");
sb.deleteCharAt(2);
System.out.println(sb); // "desert"

5) StringBuilder append(String str) связывает данную строку с концом вызывающего объекта StringBuilder. Есть также несколько 
перегруженных методов, чтобы использовать примитивные типы и даже массивы символов.
StringBuilder sb = new StringBuilder("abc");
sb.append("123");
System.out.println(sb); // "abc123"

Кроме того, можно вызвать этот метод несколько раз для одного и того же объекта в одном и том же операторе, поскольку этот метод 
возвращает измененный объект.
StringBuilder messageBuilder = new StringBuilder(); // empty

messageBuilder
        .append("From: Kate@gmail.com\n")
        .append("To: Max@gmail.com\n")
        .append("Text: I lost my keys.\n")
        .append("Please, open the door!");

System.out.println(messageBuilder);

Вывод:
From: Kate@gmail.com
To: Max@gmail.com
Text: I lost my keys.
Please, open the door!

6) StringBuilder insert(int offset, String str) вставляет данную строку в существующий объект StringBuilder в заданной позиции, 
обозначенной смещением. Метод имеет много перегрузок для разных типов.
StringBuilder sb = new StringBuilder("I'm a programmer.");
sb.insert(6, "Java ");
System.out.println(sb); // I'm a Java programmer.

7) StringBuilder replace(int start, int end, String str) заменяет подстроку из указанного строкового индекса (включительно) в 
конечный индекс (не включительно) заданной строкой.
StringBuilder sb = new StringBuilder("Let's use C#");
sb.replace(10,12,"Java");
System.out.println(sb); // Let's use Java

8) StringBuilder delete(int start, int end) удаляет подстроку от начального индекса (включительно) до конечного индекса (не включительно).
StringBuilder sb = new StringBuilder("Welcome");
sb.delete(0,3);
System.out.println(sb); // "come"

9) StringBuilder reverse() заставляет эту последовательность символов заменяться обратной последовательностью.
StringBuilder sb = new StringBuilder("2 * 3 + 8 * 4");
sb.reverse();
System.out.println(sb); // "4 * 8 + 3 * 2"

10) length() and capacity()
Есть два метода, которые нельзя путать: length() и capacity(). length() возвращает фактическое количество символов, когда capacity() 
возвращает объем памяти, доступный для вновь вставленных символов,за пределами которого произойдет выделение. capacity() является 
частью внутреннего представления StringBuilder, и ее значение будет динамически изменяться.
StringBuilder sb = new StringBuilder(); // initial capacity is 16

System.out.println(sb.length());   // 0
System.out.println(sb.capacity()); // 16

sb.append("A very long string");

System.out.println(sb.length());   // 18
System.out.println(sb.capacity()); // 34

Можно указать емкость при создании объекта StringBuilder, но это не очень часто используется.:
StringBuilder sb = new StringBuilder(30);

System.out.println(sb.length());   // 0
System.out.println(sb.capacity()); // 30

11) indexOf(String s) -> int
    indexOf(String s, int fromidex) -> int

12) substring(int beginindex) -> String
    substring(int beginindex, int endindex) -> String

13) subsequence(int start, int end) -> CharSequence
похож на substring() только возвращает Char последовательность символов

====================================================String и массив================================================================
Преобразование между строками и символьными массивами возможно с помощью специальных методов, таких как valueOf() или toCharArray():
char[] chars = { 'A', 'B', 'C', 'D', 'E', 'F' };

String stringFromChars = String.valueOf(chars); // "ABCDEF"

char[] charsFromString = stringFromChars.toCharArray(); // { 'A', 'B', 'C', 'D', 'E', 'F' }

String theSameString = new String(charsFromString); // "ABCDEF"

Также можно использовать метод split()
String text = "Hello";
String[] parts = text.split(""); // {"H", "e", "l", "l", "o"}

В скобках метода split() указывается разделитель. Если указать split(" "), то разделителем будут пробелы (причём, сам разделитель
не отображается в итоговом массиве)
String sentence = "a long text";
String[] words = sentence.split(" "); // {"a", "long", "text"}

Если указать split("-"), то разделителем будут - (причём, сам разделитель не отображается в итоговом массиве)
String number = "+1-213-345-6789";
String[] parts = number.split("-"); // {"+1", "213", "345", "6789"}

Обратите внимание, что все части все еще являются типом String, независимо от того, как они выглядят!
Выбирайте разделитель с умом, иначе вы можете получить некоторые предложения, начинающиеся с пробела:
String text = "That's one small step for a man, one giant leap for mankind.";
String[] parts = text.split(","); // {"That's one small step for a man", " one giant leap for mankind."}

Пример: поиск колличества повторяющихся субстрок в строке:
class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String input2 = scanner.next();
        int count = (input.split(input2, -1).length) - 1;
        System.out.println(Arrays.toString(input.split(input2, -1)));
        System.out.println(count);

    }
} 

=======================================Для сравнения строк с типои String используются методы:====================================
equals(other)
equalsIgnoreCase(other)
Примеры
String first = "first";
String second = "second";
String anotherFirst = "first";
String secondInUpperCase = "SECOND";
System.out.println(first.equals(second)); // false, the strings have different values
System.out.println(first.equals(anotherFirst)); // true, the strings have the same value
System.out.println(second.equals(secondInUpperCase)); // false, the strings have different cases
System.out.println(second.equalsIgnoreCase(secondInUpperCase)); // true, it ignores cases 


==============================================Логические операторы в порядке убывания:=============================================
! (NOT), ^ (XOR), && (AND), || (OR).


Java provides six relational operators to compare numbers:
== (equal to)
!= (not equal to)
> (greater than)
>= (greater than or equal to)
< (less than)
<= (less than or equal to)
У реляционных операторов приоритет выше чем у логических


Ternary operator
int max = a > b ? a : b; //result = condition ? trueCase : elseCase;
condition имеет тип boolean
если condition = true , то trueCase
если condition = false, то elseCase

идентично записи с помощью цикла
int a = 1;
int b = 2;
int max;
if (a > b) {
    max = a;
} else {
    max = b;
}

==================================Цикл for (используется если нам известно количество итераций)====================================
Схема:
for (initialization; condition; modification) {
    // do something
} 
Примеры:
1)
int n = 9;
for (int i = 0; i <= n; i++) {
    System.out.print(i + " "); // here, space is used to separate numbers
}
2)
int startIncl = 1, endExcl = 11;

int sum = 0;
for (int i = startIncl; i < endExcl; i++) {
    sum += i;
}

System.out.println(sum); // it prints "55"
3)
int i = 10;
for (; i > 0; i--) {
    System.out.print(i + " ");
}
4) Бесконечный цикл
for (;;) {
    // do something
}
5) Цикл внутри цикла
for (int i = 1; i < 10; i++) {
    for (int j = 1; j < 10; j++) {
        System.out.print(i * j + "\t");
    }
    System.out.println();
}

===============================Цикл do while - сначала выполняется тело цикла, а затем происходит проверка=========================

do {
    // body: do something
} while (condition);

Пример:
public class DoWhileDemo {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int value;
        do {
            value = scanner.nextInt();
            System.out.println(value);
        } while (value != 0);
    }
}
Input numbers:
1 2 4 0 3

The program prints:
1
2
4
0



=====================================================Неявное привидение простых типов:==============================================
from int to long:
int num = 100;
long bigNum = num; // 100L

from long to double:
long bigNum = 100_000_000L;
double bigFraction = bigNum; // 100000000.0

from short to int:
short shortNum = 100;
int num = shortNum; // 100

from char to int:
char ch = '?';
int code = ch; // 63


==========================================================Выход из цикла:==========================================================
1) break - завершает цикл, в котором находится
for (int i = 0; i < 10; i++) { // данный цикл не будет завершён
    for (int j = 0; j < 10; j++) {    //данный цикл будет завершён
        System.out.print(j + " ");
        if (i == j) {
            break;
        }
    }
    System.out.println();
}

2) Булева переменная stopped
boolean stopped = false;
for (int i = 0; (i < 10) && !stopped; i++) {
    for (int j = 0; j < 10; j++) {
        System.out.print(j + " ");
        if (i == j) {
            stopped = true;
            break;
        }
     }
    System.out.println();
}

Ключевое слово continue

1) цикл for (после continue переходит к строке с инкрементом/деинкрементом)
int n = 10;
for (int i = 0; i < n; i++) {
    if (i % 2 != 0) {
        continue;
    }
    System.out.print(i + " ");
}
The output:
0 2 4 6 8

2) цикл while и do-while(после continue переходит к условию)

1
1
2
2
3
3
4
4


================================================================Switch=============================================================
switch (action) {
    case 1:
        System.out.println("Starting a new game...");
        break;
    case 2:
        System.out.println("Loading a saved game");
        break;
    case 3:
        System.out.println("Displaying help...");
        break;
    case 4:
        System.out.println("Exiting...");
        break;
    default:
        System.out.println("Unsuitable action, please, try again");
}

Начиная с 14 версии java для switch введено новое ключевое слово "yield" оно равноценно return
int count = switch (day) {
    case "Monday":
        yield 1;
    case "Tuesday":
        yield 2;
    ...

    default:
        yield -1;
};

Чтобы зациклить switch, можно использовать цикл while
boolean check = false
while(check == false){
	switch(...){
		код
    }
}

==============================================Сравнение ссылочных переменных с помощью equals======================================
String s1 = new String("java");
String s2 = new String("java");
String s3 = s2;

System.out.println(s1.equals(s2)); // true
System.out.println(s2.equals(s3)); // true

================================================================Массивы=============================================================
https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html

1) Создание массива

int[] numbers = { 1, 2, 3, 4 }; // instantiating and initializing an array of 1, 2, 3, 4
или
int a = 1, b = 2, c = 3, d = 4;
int[] numbers = { a, b, c, d }; // instantiating and initializing an array of 1, 2, 3, 4
или
int n = ...; // n is a length of an array
int[] numbers = new int[n];
или
int[] numbers; // declaration
numbers = new int[n]; // instantiation and initialization with default values
или
float[] floatNumbers; // declaration 
floatNumbers = new float[] { 1.02f, 0.03f, 4f }; // instantiation and initialization

2) Длина массива

int[] array = { 1, 2, 3, 4 }; // an array of numbers
        
int length = array.length; // number of elements of the array
        
System.out.println(length); // 4

3) Установка значения 
array[index] = val;

4) Получение значения
val = array[index];

Пример:
int[] numbers = new int[3]; // numbers: [0, 0, 0]
numbers[0] = 1; // numbers: [1, 0, 0]
numbers[1] = 2; // numbers: [1, 2, 0]
numbers[2] = numbers[0] + numbers[1]; // numbers: [1, 2, 3]

5) Класс Arrays, необходимо импортировать import java.util.Arrays;

- конвертирование типа массива в String с помощью метода Arrays.toString(array)
byte[] famousNumbers = { 0, 1, 2, 4, 8, 16, 32, 64 };
String arrayAsString = Arrays.toString(famousNumbers); // [0, 1, 2, 4, 8, 16, 32, 64]
System.out.println(arrayAsString);

- сортировка массива с помощью метода Arrays.sort(array)
long[] bigNumbers = { 200000000L, 400000000L, 100000000L, 300000000L }; // it's unsorted
Arrays.sort(bigNumbers); // sorting whole array 
System.out.println(Arrays.toString(bigNumbers)); // [100000000, 200000000, 300000000, 400000000]

- сравнение массивов(массивы равны если имеют одинаковое количество элементов расположенных в одинаковом порядке)
int[] numbers1 = { 1, 2, 5, 8 };
int[] numbers2 = { 1, 2, 5 };
int[] numbers3 = { 1, 2, 5, 8 };
System.out.println(Arrays.equals(numbers1, numbers2)); // it prints "false"
System.out.println(Arrays.equals(numbers1, numbers3)); // it prints "true"

- заполнение всего массива или его части некоторыми значениями c помощью метода Arrays.fill
Arrays.fill(название массива, индекс первого элемента который должен быть заполнен указанным значением(включая его), индекс последнего элемента(не включая его), устанавливаемое значение)
Пример:
int numbers[] = { 1, 2, 3, 4, 5 };
Arrays.fill(numbers, 1, 5, 10); //[1, 10, 10, 10, 10]

System.out.println(Arrays.toString(numbers));
int size = 10;
char[] characters = new char[size];
// It takes an array, start index, end index (exclusive) and the value for filling the array
Arrays.fill(characters, 0, size / 2, 'A'); 
Arrays.fill(characters, size / 2, size, 'B');
System.out.println(Arrays.toString(characters)); // it prints [A, A, A, A, A, B, B, B, B, B]

- поиск значения в массиве (корректно работает только в отсортированном массиве)
Arrays.binarySearch(array, value) -> возвращает индекс искомого элемента

===============================================Заполнение массива с помощью цикла==================================================
Пример
int n = 10; // the size of an array
int[] squares = new int[n]; // creating an array with the specified size
System.out.println(Arrays.toString(squares)); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
/* iterating over the array */
for (int i = 0; i < squares.length; i++) {
    squares[i] = i * i; // set the value by the element index 
}
System.out.println(Arrays.toString(squares)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

=================================================Проверка сортировки массива=======================================================
Пример:
int[] numbers = { 1, 2, 3, 4, 5, 10, 6 }; // the order is broken

boolean broken = false; // suppose the array is well-ordered

/* iterating over the array */
for (int i = 1; i < numbers.length; i++) {
    
    if (numbers[i] < numbers[i - 1]) { // if the order is broken
        broken = true; // write a result
        break;         // terminate the loop
    }
}

if (broken) {
    System.out.println("BROKEN");
} else {
    System.out.println("OK");
}

========================================Создание массива из данных, введённых пользователем========================================
Пример:
Scanner scanner = new Scanner(System.in);       
int len = scanner.nextInt(); // reading a length
int[] array = new int[len];  // creating an array with the specified length
        
for (int i = 0; i < len; i++) {
    array[i] = scanner.nextInt(); // read the next number of the array
}
System.out.println(Arrays.toString(array)); // output [101, 102, 504, 302, 881]

=============================================Специальный вид цикла for для массивов================================================
Макет:
for (type var : array) { 
    //statements using var
}

Пример 1:
char[] characters = { 'a', 'b', 'c', 'a', 'b', 'c', 'a' };
int counter = 0;
for (char ch : characters) {
    if (ch == 'a') {
        counter++;
    }
}
System.out.println(counter); // it outputs "3"

Тот же пример со стандартным циклом for:
char[] characters = {'a', 'b', 'c', 'a', 'b', 'c', 'a'};
int counter = 0;
for (int i = 0; i < characters.length; i++) {
    if (characters[i] == 'a') {
        counter++;
    }
}
System.out.println(counter); // it outputs "3"

=========================================================Массив с массивами========================================================
Пример:
int[][] twoDimArray = {
        {1, 2, 3, 1}, // first array of int
        {3, 4, 1, 2}, // second array of int
        {4, 4, 1, 0}  // third array of int
};
int number = twoDimArray[0][2]; // it is 3

Массивы включённые в массив могут иметь разный размер:
int[][] twoDimArray = new int[3][];

twoDimArray[0] = new int[] { 1, 2, 3, 4 }; // the length is 4
twoDimArray[1] = new int[] { 5, 7, 3};     // the length is 3
twoDimArray[2] = new int[] { 8 };          // the length is 1

// let's output the array
for (int i = 0; i < twoDimArray.length; i++) {
    System.out.println(Arrays.toString(twoDimArray[i]));
}
Вывод:
[1, 2, 3, 4]
[5, 7, 3]
[8]

Тройной массив:
Пример 1:

int[][][] cubic = new int[3][4][5]; // a three-dimensional array (cube)    

int current = 1; // it stores a value to fill elements

for (int i = 0; i < 3; i++) { // iterating through each 2D array ("table" or "matrix")
    for (int j = 0; j < 4; j++) { // iterating through each 1D array ("vector") array of a "matrix"
        for (int k = 0; k < 5; k++) { // iterating through each element of a vector
            cubic[i][j][k] = current; // assign a value to an element
        }
    }
    current++; // get the next value to the next "matrix"
}
        
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        for (int k = 0; k < 5; k++) {
            System.out.print(cubic[i][j][k] + " ");
        }
        System.out.println();
    }
    System.out.println();
}
This code prints:

1 1 1 1 1 
1 1 1 1 1 
1 1 1 1 1 
1 1 1 1 1 

2 2 2 2 2 
2 2 2 2 2 
2 2 2 2 2 
2 2 2 2 2 

3 3 3 3 3 
3 3 3 3 3 
3 3 3 3 3 
3 3 3 3 3 

Пример 2:

// this code fills the 3-dimensional array
int current = 1;
for (int[][] dim2Array : cubic) {     // for each 2-dim array
    for (int[] vector : dim2Array) {  // for each 1-dim array (vector) of 2-dim array
        Arrays.fill(vector, current); // fill the vector
    }
   current++; // the next current
}

// this code prints all 2-dimensional arrays
for (int[][] dim2Array : cubic) {
    for (int[] vector : dim2Array) {
        System.out.println(Arrays.toString(vector));
    }
    System.out.println();
}
This code prints three 2-dim arrays:

[1, 1, 1, 1, 1]
[1, 1, 1, 1, 1]
[1, 1, 1, 1, 1]
[1, 1, 1, 1, 1]

[2, 2, 2, 2, 2]
[2, 2, 2, 2, 2]
[2, 2, 2, 2, 2]
[2, 2, 2, 2, 2]

[3, 3, 3, 3, 3]
[3, 3, 3, 3, 3]
[3, 3, 3, 3, 3]
[3, 3, 3, 3, 3]



===================================================================================================================================
================================================================Методы=============================================================
===================================================================================================================================
1) Модификаторы метода

Первые слова-это так называемые модификаторы. В Java существует два типа модификаторов: модификаторы доступа и модификаторы 
отсутствия доступа.
Модификаторы доступа определяют видимость метода. На данный момент мы используем модификатор public, что означает, что 
нет никаких ограничений для вызова метода даже из других классов.

Модификаторы без доступа предоставляют JVM информацию об их поведении. Модификатор static означает, что метод принадлежит классу 
и к нему можно получить доступ без создания какого-либо объекта. Этот тип метода называется статическим методом.

Если метод объявлен без статического модификатора, это означает, что метод может быть вызван только через объект этого класса или 
с его экземпляром. Такие методы называются методами экземпляра.

2) Параметры метода
В скобках после имени метода мы определяем тип, число и порядок параметров. Это отражает то, как они будут передаваться методу при 
его вызове. Взгляните на эти подписи:

convertEuroToDollars(double dlrRate, long eur);

countMonthlySpendings(long food, long rent, long fun); 

replace(char a, char b);

Существуют также методы, которым не передаются значения. Эти методы известны как непараметризованные.

4) Тело метода

Прежде чем метод завершит свое выполнение и завершит работу, он возвращает значение, известное как возвращаемое значение. 
Результатом выполнения метода может быть значение примитивных типов, таких как int, float, double, boolean, или ссылочных типов, 
таких как String. Взгляните на наш метод countSeeds с возвращаемым значением int:

public static int countSeeds(int parrotWeight, int parrotAge) {   
    return parrotWeight / 5 + parrotAge; // it returns an int
}

Методы не обязательно должны возвращать значение. Если мы хотим, чтобы метод не возвращал значение, а выполнял только операции, 
в качестве типа возвращаемого значения используется ключевое слово void:

public static void countSeeds(int parrotWeight, int parrotAge) {
    System.out.println("give your parrot" + parrotWeight / 5 + parrotAge + 
    "g of seeds per day");
}
// this method just prints the line, so it returns no value

Хотя методы с типом void ничего не возвращают, вы все равно можете использовать return для выхода из метода. Обычно это применимо 
к методам с условиями. Посмотри:

public static void isPositive(int num) {
    if (num > 0) {
        System.out.println("the number is positive");
    } else {
        return;
    }
}

Помните, что если вы попытаетесь вернуть значение из метода с типом возвращаемого значения void, то возникнет ошибка компиляции!

При передаче переменной примитивного типа в метод создается копия этой переменной с тем же значением. Внутри метода обрабатывается 
только эта копия. Любые изменения в этой копии не повлияют на переданную переменную.

public static void main(String[] args) {
    int portion = 100;   
    addSeeds(portion); // try to change portion 

    // now let's print a portion
    System.out.println(portion);
    // 100, because the method didn't change portion, only its copy
}

public static void addSeeds(int portion) {
    portion += 50;
    System.out.println("The increased portion is " + portion); 
}
Вывод:
The increased portion is 150
100


============================================================Метод Main==============================================================
public static void main(String[] args)

- ключевое слово public указывает на то, что метод может быть вызван отовсюду;
- ключевое слово static указывает, что метод может быть вызван без создания экземпляра класса;
- ключевое слово void указывает на то, что метод не возвращает никакого значения;
- переменная массива args содержит аргументы, введенные в командной строке, массив пуст, если аргументов нет.

Ваша программа не может быть скомпилирована. Это тот случай, когда объявление основного метода нарушает синтаксис Java:
invalid method declaration: no returning value (even void).
public static main(String[] args)
invalid method declaration: a mistake in the keyword (pubic instead of public).
pubic static void main(String[] args)

Программа может быть скомпилирована, но не может быть запущена. Это тот случай, когда основной метод имеет правильное объявление 
как обычный метод, но не удовлетворяет специфическому требованию основного метода:
invalid arguments (should be String[] args)
public static void main(String args) {
    System.out.println("Hello, Java");
}
the method declaration has no keyword static
public void main(String[] args) { 
    System.out.println("Hello, Java");
} 

===================================================Массив как параметр метода======================================================
Параметр типа массива выглядит как параметр примитивного типа. Но есть одно важное отличие, связанное с тем, что массив является 
ссылочным типом. При передаче значения примитивного типа в метод создается копия этого значения. Когда вы передаете массив методу, 
создается копия ссылки, но значение остается тем же самым. Это означает, что если вы измените фактическое значение 
(элементы массива) в теле метода, вы увидите эти изменения вне метода.
Пример:
public static void swapFirstAndLastElements(int[] nums) { // nums is an array
    if (nums.length < 1) {
        return; // it returns nothing, i.e. just exits the method
    }

    int temp = nums[nums.length - 1]; // save the last element in temporary local variable
    nums[nums.length - 1] = nums[0];  // now, the last element is the first
    nums[0] = temp;                   // now, the first element is the previous last
}

public static void main(String[] args) {

    int[] numbers = { 1, 2, 3, 4, 5 }; // numbers

    System.out.println(Arrays.toString(numbers)); // before swapping

    swapFirstAndLastElements(numbers); // swapping

    System.out.println(Arrays.toString(numbers)); // after swapping
}
The output is:

[1, 2, 3, 4, 5]
[5, 2, 3, 4, 1] 

=====================================================Varargs аргументы метода======================================================
Методу можно передать произвольное число однотипных аргументов с помощью специального синтаксиса varargs (аргументы переменной 
длины). Эти аргументы указываются тремя точками после типа. В теле метода этот параметр можно обработать как обычный массив 
указанного типа.
Следующий метод принимает целочисленный параметр vararg и выводит количество аргументов в стандартном выводе, используя свойство 
length массивов:

public static void printNumberOfArguments(int... numbers) {
    System.out.println(numbers.length);
}

Как видите, здесь особый синтаксис ... используется для указания параметра vararg.
Теперь вы можете вызвать метод, передающий несколько целых чисел или массив ints.

printNumberOfArguments(1);
printNumberOfArguments(1, 2);
printNumberOfArguments(1, 2, 3);
printNumberOfArguments(new int[] { }); // no arguments here
printNumberOfArguments(new int[] { 1, 2 });

This code outputs:
1
2
3
0
2

Если метод имеет более одного параметра, параметр vararg должен быть последним параметром в объявлении метода.
public static void method(int a, double... varargs) { /* do something */ }

============================================Форматированный вывод(Formatted output)================================================
1) метод printf() 
Метод printf() обычно состоит из двух частей. Во-первых, вы даете строку, которую хотите отформатировать, в качестве первого 
атрибута. Сама эта строка содержит правила для ее форматирования с помощью спецификаторов формата. Некоторые примеры 
спецификаторов формата - %d, %s и т. д. Во второй части вы даете список аргументов, который Java может использовать для 
форматирования строки в соответствии со спецификаторами формата.

Пример 1:

System.out.printf("My Name is %s. I was born in %d", "Mike", 1998);

- Первая часть "My Name is %s. I was born in %d" , где %s и %d являются спецификаторами формата.
- Вторая часть - это список аргументов: "Mike", 1998

Пример 2: Вы можете отобразить целое число с помощью спецификатора формата %d.

public static void main(String[] args){
    System.out.printf("Display a Number %d", 15000);
}
Java заменит 15000 вместо %d.

Пример 3: если вы хотите, чтобы в выходных данных отображалось несколько целых чисел, используйте несколько спецификаторов %d.

public static void main(String[] args){
    System.out.printf("Sum of %d and %d is %d", 15, 40, 55);
}
Java заменит каждый аргумент вместо %d соответственно, начиная слева и выведет: Sum of 15 and 40 is 55

Пример 4: Если вы хотите отобразить значение с плавающей запятой, используйте спецификатор %f.

public static void main(String[] args){
    System.out.printf("Display a Number %f", 15.23);
}
Вывод: Display a Number 15.230000

Чтобы управлять количеством отображаемых знаков после запятой необходимо их указать в спецификаторе:

public static void main(String[] args){
    System.out.printf("Display a Number %.2f", 15.23);
}
Вывод: Display a Number 15.23

Пример 5: Если вы хотите напечатать char, используйте %c, для String, используйте %s.

public static void main(String[] args){
    char abbr = 'H';
    String element = "Hydrogen";
    System.out.printf("%c stands for %s", abbr, element);
}
Вывод: H stands for Hydrogen

Когда этот код запускается, значение переменной abbr заменит %c, а значение переменной element 
заменит %s.

2) String.format() метод
Метод format() в классе String работает очень похоже на метод printf (). Главное отличие здесь 
заключается в том, что вы возвращаете строку вместо того, чтобы печатать ее.

Пример 1:

public static void main(String[] args){
    int age = 22;
    String str = String.format("My age is %d", age);
    System.out.println(str);
}

Пример 2: Аналогичным образом можно форматировать и другие типы данных

public static void main(String[] args){
    int age = 22;
    char initial = 'M';
    String surname = "Anderson";
    double height = 1.72;

    String details = String.format("My name is %c. %s.%nMy age is %d.%nMy height is %.2f.", initial, surname, age, height);
    System.out.println(details);
}
Вы можете видеть, что в этом примере мы использовали четыре типа типов данных. Java заменит 
%c, %s, %d, %f на инициал, фамилию, возраст и рост соответственно. символ новой строки %n переходит 
на новую строку каждый раз, когда он был использован. 

Вывод нашего кода таков:
My name is M. Anderson.
My age is 22.
My height is 1.72.

===============================================================Константы===========================================================
Обычно имя константы указывают верхним регистром, соединяя несколько слов нижним подчёркиванием
Если константа является локальной, то записываются в нижнем регистре
Если константе не было присвоено значение перед ее использованием, компилятор выдаст ошибку.

Пример 1:

final double PI = 3.1415;
final String HELLO_MSG = "Hello";

Пример 2: константа может быть переназначена в обычную переменную

final int count = 10;
int cnt = count;
cnt = 20; // no errors here, cnt is not final

=================================================Ссылочные переменные как константы================================================
Ключевое слово final может быть использовано со ссылочными переменными. В этом случае ключевое слово final означает, что невозможно
переназначить ссылочную переменную на другой объект.

final StringBuilder builder = new StringBuilder();
builder = new StringBuilder(); // error line

При этом можно изменить внутреннее состояние точки объекта final объектом, то есть константой является только 
сама переменная (эталон), а не объект, на который она ссылается.

final StringBuilder builder = new StringBuilder(); // ""
builder.append("Hello!"); // it works
System.out.println(builder.toString()); // Hello!

Как вы можете видеть, этот код изменил внутреннее состояние объекта ("" → "Hello!"), на который ссылается конечная переменная. 
Когда мы вызывали метод append (), мы изменяли не сам объект, а только значение его полей. метод append () - это одна из основных 
операций в StringBuilder, которая недоступна в String. Он преобразует свой аргумент в строку, а затем добавляет свои символы в 
последовательность символов.

Начиная с Java 11, также можно использовать final с var для использования автоматического вывода типа для константы.

final var FINAL_VAR = 10; // int
final var MSG = "Hello!"; // String

========================================================Ошибки в программе=========================================================
1) Compile-time errors
- a syntax error: incorrect keyword, a forgotten symbol ; at the end of a statement;
- a bad source code file name;
- invoking a non-existing method;
Пример:
public class MyClass {

    public ztatic void main(String args[]) { //Неверное ключевое слово ztatic
        System.out.printn("Hello!"); //Неверно название метода printn
    }
}

2) Run-time errors
это ошибки, возникающие во время выполнения программы. Ошибки во время выполнения приведут к тому, что ваша программа будет вести 
себя неожиданно или даже может остановить выполнение.
- логические ошибки – когда программа выдает неверный результат из-за неправильности кода (например, вместо "Привет!" ваша программа выдает "Привет!");
- необработанные исключительные события, такие как деление на ноль, не найденные файлы и другие неожиданные случаи.

3) Проверка возможности конвертирования String в int
import java.util.Scanner;

public class NumberFormatExceptionDemo {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();

        if (input.matches("\\d+")) { // it checks the input line contains only digits
            int number = Integer.parseInt(input);
            System.out.println(number + 1);
        } else {
            System.out.println("Incorrect number: " + input);
        }
    }
}

4) NPE(null pointer exception)
Поскольку String-это обычный ссылочный тип, его переменная может быть нулевой. Если мы вызываем метод или применяем операцию к 
такой переменной, код выдает NPE.
Пример:

String someString = null; // a reference type can be null
int size = someString.length(); // NullPointerException (NPE)

Чтобы избежать исключения, мы должны явно проверить, является ли строка нулевой или нет, и в зависимости от результата выполнить 
другой код.
Пример:
String someString = null; // a reference type can be null
int size = str != null ? str.length() : 0; // if the string is empty, the size is 0
//result = condition ? trueCase : elseCase; 

5) Ошибки при сравнении String переменных
Очень распространенная ситуация возникает, когда мы пытаемся сравнить строковую переменную и строковый 
литерал.
Пример:

String str = null;
if (str.equals("abc")) { // it throws NPE
    System.out.println("The same");
}

String str = null;
if ("abc".equals(str)) { // no NPE here
    System.out.println("The same");
}

Но что, если у нас есть две переменные типа String? Любой из них может оказаться нулевым. В этом случае мы 
можем использовать специальный вспомогательный класс java.util.Objects
Пример:

String s1 = null;
String s2 = null;
if (Objects.equals(s1, s2)) { // no NPE here
    System.out.println("Strings are the same");
}

============================================Иерархия исключений (Hierarchy of exceptions)==========================================
Java-это прежде всего объектно-ориентированный язык. В такой парадигме все исключения рассматриваются как объекты специальных 
классов, организованных в иерархию классов.

Базовым классом для всех исключений является java.lang.Throwable. Этот класс предоставляет набор общих методов для всех исключений:
1) String getMessage() - возвращает подробное строковое сообщение этого объекта исключения;
2) Throwable getCause() - возвращает причину этого исключения или null, если причина не существует или неизвестна;
3) printStackTrace() - печать трассировки стека в стандартном потоке ошибок

Класс Throwable имеет 2 подкласса java.lang.Error и java.lang.Exception
1) подклассы класса Error представляют собой низкоуровневые исключения в JVM, например: OutOfMemoryError, StackOverflowError;
2) подклассы класса Exception имеют дело с исключительными событиями внутри приложений, такими как: RuntimeException, IOException;
3) класс RuntimeException-это специальный подкласс класса Exception. Он представляет собой непроверенные исключения,
 в том числе: ArithmeticException, NumberFormatException, NullPointerException.

Четыре основных класса исключений (Throwable, Exception, RuntimeException и Error) находятся в пакете java.lang. Их не нужно 
импортировать. Однако их подклассы могут быть помещены в разные пакеты.

Все исключения можно разделить на две группы: проверенные и непроверенные. Они функционально эквивалентны, но есть разница с точки 
зрения компилятора.
1) Проверяемые исключения (Checked exceptions) представлены классом Exception, исключая подкласс RuntimeException. Компилятор проверяет, ожидает ли 
программист появления таких исключений в программе или нет.
Если метод выдает проверенное исключение, это должно быть отмечено в объявлении с помощью специального ключевого слова throws. В 
противном случае программа не будет компилироваться.
Давайте взглянем на пример. Мы используем класс Scanner, как средство чтения из стандартного ввода, для чтения из файла:

public static String readLineFromFile() throws FileNotFoundException {
    Scanner scanner = new Scanner(new File("file.txt")); // java.io.FileNotFoundException
    return scanner.nextLine();
}

Здесь FileNotFoundException является стандартным проверяемым исключением. Этот конструктор класса Scanner объявляет исключение 
FileNotFoundException, поскольку мы предполагаем, что указанный файл может не существовать. Самое главное, что в методе есть одна 
строка, которая может вызвать исключение, поэтому мы помещаем ключевое слово throws в объявление метода.

2) Непроверяемые исключения (Unchecked exceptions) представлены классом RuntimeException и его подклассов. Компилятор не проверяет, 
ожидает ли программист появления таких исключений в программе.
Вот метод, который вызывает исключение NumberFormatException, когда входная строка имеет недопустимый формат (например, "abc").

public static Long convertStringToLong(String str) {
    return Long.parseLong(str); // It may throw NumberFormatException
}
Этот код всегда успешно компилируется без ключевого слова throws в объявлении. Исключения во время выполнения могут возникать в 
любом месте программы. Компилятор не требует, чтобы вы указывали исключения времени выполнения в объявлениях. Добавление их к 
объявлению каждого метода уменьшило бы ясность программы.

Класс Error и его подклассы также рассматриваются как непроверяемые исключения. Однако они образуют отдельный класс.

Проверяемые исключения (Exception, IOException, ClassNotFoundException)
Непроверяемые исключения (NullPointerException, RuntimeException, IndexOutOfBoundsException, ClassCastException)

==========================================Обработка исключений (Exception handling)================================================
Вот простой шаблон try-catch для обработки исключений:

try {
    // code that may throw an exception
} catch (Exception e) {
    // code for handling the exception
}

Блок try используется для обертывания кода, который может вызвать исключение. Этот блок может включать в себя все строки кода, 
включая вызовы методов.
Блок catch является обработчиком для указанного типа исключения и всех его подклассов. Этот блок выполняется, когда в блоке try 
возникает исключение соответствующего типа. Обратите внимание, что указанный тип в блоке catch должен расширять класс Throwable.
В представленном шаблоне блок catch может обрабатывать исключения класса Exception и всех производных от него классов.

Следующий пример демонстрирует поток выполнения с помощью try и catch.

System.out.println("before the try-catch block"); // it will be printed

try {
    System.out.println("inside the try block before an exception"); // it will be printed

    System.out.println(2 / 0); // it throws ArithmeticException

    System.out.println("inside the try block after the exception"); // it won't be printed
} catch (Exception e) {
    System.out.println("Division by zero!"); // it will be printed
}

System.out.println("after the try-catch block"); // it will be printed

The output:

before the try-catch block
inside the try block before an exception
Division by zero!
after the try-catch block

Замена Exception на ArithmeticException или RuntimeException в операторе catch не изменяет поток выполнения программы. Но замена 
его на NumberFormatException сделает обработчик неподходящим для исключения, и программа потерпит неудачу.

Когда исключение перехвачено блоком catch, можно получить некоторую информацию о нем:
try {
    double d = 2 / 0;
} catch (Exception e) {
    System.out.println(e.getMessage());
}

This code prints:

An exception occured: / by zero

Всегда можно использовать один обработчик для всех типов исключений:
try {
    // code that may throw exceptions
} catch (Exception e) {
    System.out.println("Something goes wrong");
}

Очевидно, что такой подход не позволяет нам выполнять различные действия в зависимости от типа возникшего исключения. К счастью, 
Java поддерживает использование нескольких обработчиков внутри одного блока try.
try {
    // code that throws exceptions
} catch (IOException e) {
    // handling the IOException and its subclasses    
} catch (Exception e) {
    // handling the Exception and its subclasses
}

Когда в блоке try возникает исключение, система выполнения определяет первый подходящий блок catch в соответствии с типом 
исключения. Соответствие идет сверху вниз.
Важно, что блок catch с базовым классом должен быть записан ниже всех блоков с подклассами. Другими словами, более 
специализированные обработчики (например, IOException) должны быть написаны раньше более общих (например, Exception). В противном 
случае код не будет компилироваться.

Начиная с Java 7, вы можете использовать синтаксис multi-catch для обработки нескольких исключений одним и тем же способом:
Обратите внимание, что альтернативы в операторе multi-catch не могут быть подклассами друг друга.
try {
    // code that may throw exceptions
} catch (SQLException | IOException e) {
    // handling SQLException, IOException and their subclasses
    System.out.println(e.getMessage());
} catch (Exception e) {
    // handling any other exceptions
    System.out.println("Something goes wrong");
}


Есть еще один возможный блок под названием finally. Все операторы, присутствующие в этом блоке, всегда будут выполняться независимо 
от того, происходит ли исключение в блоке try или нет.
try {
    // code that may throw an exception
} catch (Exception e) {
    // exception handler
} finally {
    // code always be executed
}
В этом шаблоне блок finally выполняется после блока catch.

Следующий пример иллюстрирует порядок выполнения оператора try-catch-finally.
try {
    System.out.println("inside the try block");
    Integer.parseInt("101abc"); // throws NumberFormatException
} catch (Exception e) {
    System.out.println("inside the catch block");
} finally {
    System.out.println("inside the finally block");
}

System.out.println("after the try-catch-finally block");

The output:

inside the try block
inside the catch block
inside the finally block
after the try-catch-finally block

Если мы удалим строку, которая вызывает исключение NumberFormatException, блок finally все равно будет выполнен после блока try.

Также возможно написать try and finally без блока catch, вообще. В этом шаблоне блок finally выполняется сразу после блока try.
try {
    // code that may throw an exception
} finally {   
    // code always be executed
}

=====================================Обработка исключений с помощью шаблона Try with resources=====================================
Мы уже упоминали, что входные потоки должны быть закрыты после того, как они были использованы. Давайте обсудим, что происходит, 
когда вы работаете с внешними ресурсами, как можно выполнить закрытие и почему это важно.
Когда создается входной поток, JVM уведомляет ОС о своем намерении работать с файлом. Если процесс JVM имеет достаточно разрешений 
и все в порядке, ОС возвращает файловый дескриптор — специальный индикатор, используемый процессом для доступа к файлу. Проблема в 
том, что количество файловых дескрипторов ограничено. Именно по этой причине важно уведомить ОС о том, что задание выполнено и 
удерживаемый файловый дескриптор может быть освобожден для дальнейшего повторного использования. В предыдущих примерах мы вызывали 
метод close для этой цели. Как только он вызывается, JVM освобождает все системные ресурсы, связанные с потоком.

Освобождение ресурсов работает, если JVM вызывает метод close, но вполне возможно, что этот метод вообще не будет вызван.
Посмотрите на пример:
Reader reader = new FileReader("file.txt");
// code which may throw an exception
reader.close();
Предположим, что что-то идет не так перед вызовом close и возникает исключение. Это приводит к ситуации, когда метод никогда не 
будет вызван и системные ресурсы не будут освобождены. Решить эту проблему можно с помощью конструкции try-catch-finally:
Reader reader = null;

try {
    reader = new FileReader("file.txt");
    // code which may throw an exception
} finally {
    reader.close();
}
Выброшенные исключения теперь не могут повлиять на вызов метода close.
К сожалению, это решение все еще имеет некоторые проблемы. То есть метод close потенциально может сам вызывать исключения. 
Предположим теперь, что есть два исключения: первое было вызвано внутри секции try, второе было брошено секцией finally. Это 
приводит к потере первого исключения вообще. Давайте посмотрим, почему это происходит:
void readFile() throws IOException {
    Reader reader = null;
    try {
        reader = new FileReader("file.txt");
        throw new RuntimeException("Exception1");
    } finally {
        reader.close(); // throws new RuntimeException("Exception2")
    }
}
Во-первых, try block выбрасывает исключение. Как мы знаем, блок finally вызывается в любом случае. В нашем примере метод close 
выдает исключение. Когда выброшено два исключения, какое из них выбрасывается за пределы метода? Это будет последнее: Исключение 2 
в нашем случае. Это означает, что мы никогда не узнаем, что try block вообще вызвал исключение.
Хорошо, мы не хотим потерять первое исключение, поэтому мы немного обновляем код и обрабатываем Exception2 сразу после его выброса:
void readFile() throws IOException {
    Reader reader = null;
    try {
        reader = new FileReader("file.txt");
        throw new RuntimeException("Exception1");
    } finally {
        try {
            reader.close(); // throws new RuntimeException("Exception2")
        } catch (Exception e) {
            // handle the Exception2
        }
    }
}
Теперь кусок кода выбрасывает Exception1 наружу. Это может быть правильно, но мы все равно не сохраняем информацию об обоих 
исключениях, а иногда и не хотим ее терять. Итак, давайте посмотрим, как мы сможем справиться с этой ситуацией.

Простой и надежный способ под названием try-with-resources был представлен в Java 7.
try (Reader reader = new FileReader("file.txt")) {
    // some code
}

Эта конструкция состоит из двух частей, заключенных круглыми и фигурными скобками. Круглые скобки содержат инструкции по созданию 
экземпляра входного потока. Можно также создать несколько объектов. Приведенный ниже код тоже правильный:
try (Reader reader1 = new FileReader("file1.txt");
     Reader reader2 = new FileReader("file2.txt")) {
    // some code
}

Вторая часть просто содержит некоторый код для работы с объектом, который был создан в первой части.
Как видите, явных вызовов метода close вообще нет. Он неявно вызывается для всех объектов, объявленных в первой части. Конструкция 
гарантирует закрытие всех ресурсов надлежащим образом.

Начиная с Java 9, вы можете инициализировать входной поток вне конструкции, а затем объявить его в круглых скобках:
Reader reader = new FileReader("file.txt");
try (reader) {
    // some code
}

Конечно, мы делаем все возможное, чтобы писать безошибочные программы. Однако трудно предвидеть все возможные проблемы. Лучше всего 
обернуть любой код, имеющий дело с системными ресурсами, построением try-with-resources

Вы также можете использовать try-with-resources как часть try-catch-finally:
try (Reader reader = new FileReader("file.txt")) {
    // some code
} catch(IOException e) {
    ...
} finally {
    ...
}

Теперь давайте вернемся к нашему случаю с двумя исключениями. Если оба метода try block и close выбрасывают исключения Exception1 и 
Exception2:
void readFile() throws IOException {
    try (Reader reader = new FileReader("file.txt")) {
        throw new RuntimeException("Exception1");
    }
}
метод выдает результирующее исключение, которое содержит информацию об обоих исключениях. Это выглядит так:
Exception in thread "main" java.lang.RuntimeException: Exception1
    at ...
    Suppressed: java.lang.RuntimeException: Exception2
        at ...

Закрытие имеет решающее значение для других внешних источников, таких как веб-соединения или соединения с базами данных. Классы, 
которые их обрабатывают, имеют метод close и поэтому могут быть обернуты оператором try-with-resources.
Например, давайте рассмотрим java.util.Scanner. Ранее мы использовали Scanner для считывания данных со стандартного ввода, но он 
также может считывать данные из файла. Scanner имеет метод close() для освобождения ресурсов.
Рассмотрим пример программы, которая считывает из файла два целых числа, разделенных пробелом, и печатает их:
try (Scanner scanner = new Scanner(new File("file.txt"))) {
    int first = scanner.nextInt();
    int second = scanner.nextInt();
    System.out.println("arguments: " + first + " " + second);
}
Предположим, что что-то пошло не так, и содержимое файла равно 123 not_number, где второй аргумент-строка. Это приводит к 
java.util.InputMismatchException при разборе второго аргумента. Try-with-resources гарантирует, что связанные с файлами ресурсы 
будут закрыты должным образом.

==========================================================Throwing exceptions======================================================
Любой объект класса Throwable и все его подклассы могут быть выброшены с помощью оператора throw. Общая форма оператора состоит из 
ключевого слова throw и объекта, который должен быть выброшен.
В следующем примере мы создаем и выбрасываем объект класса RuntimeException, который расширяет Throwable.
public class Main {
    public static void main(String args[]) {
        RuntimeException exception = new RuntimeException("Something's bad.");
        throw exception;
    }
}
Давайте рассмотрим фрагмент кода выше. Сначала мы создаем объект с указанным сообщением в качестве аргумента конструктора. Затем 
мы выбрасываем это исключение, используя ключевое слово throw. Просто создать объект недостаточно, чтобы вызвать исключение.
Программа останавливается и печатает ошибку с сообщением, которое мы предоставили:
Exception in thread "main" java.lang.RuntimeException: Something's bad.
    at Main.main(Main.java:3)

Общепринятая практика состоит в том, чтобы создать и выбросить исключение в одной строке:
1) throwing an instance of class Throwable
throw new Throwable("Something's bad.");
2) throwing an instance of class Exception
throw new Exception("An exception occurs");
3) throwing an instance of class NullPointerException
throw new NullPointerException("The field is null");

Невозможно выбросить объект класса, который не расширяет Throwable. Например, строка throw new Long(10L); вообще не компилируется.

1) Throwing checked exceptions
Если метод выбрасывает проверяемое исключение, то это исключение должно быть указано в объявлении метода после ключевого 
слова throws. В противном случае код не будет компилироваться.
Например, давайте рассмотрим следующий метод, который считывает текст из файла. В случае, если файл не найден, метод вызывает 
исключение IOException:
public static String readTextFromFile(String path) throws IOException {
    // find a file by the specified path    

    if (!found) {
        throw new IOException("The file " + path + " is not found");
    }

    // read and return text from the file
}
Ключевое слово throws после параметров метода является обязательным, так как IOException является проверяемым исключением.

Если метод выдает два или более проверяемых исключения, они должны быть записаны в объявлении через запятую (,):
public static void method() throws ExceptionType1, ExceptionType2, ExceptionType3

Если метод объявлен как выбрасывающий исключение (т. е. BaseExceptionType), он также может выбросить любой подкласс указанного 
исключения (т. е. SubClassExceptionType):
public static void method() throws BaseExceptionType

2) Throwing unchecked exceptions
Если метод выбрасывает непроверяемое исключение, ключевое слово throws не требуется в объявлении метода (однако вам все 
равно придется использовать throw)

Класс Account содержит метод deposit, который добавляет указанную сумму к текущему балансу. Если сумма отрицательная или больше 
возможной, метод выдает исключение IllegalArgumentException.
class Account {

    private long balance = 0;
    
    public void deposit(long amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Incorrect sum " + amount);
        }
        
        if (amount >= 100_000_000L) {
            throw new IllegalArgumentException("Too large amount");
        }
        
        balance += amount;
    }
    
    public long getBalance() {
        return balance;
    }
}

Общепринятая практика заключается в том, чтобы создавать исключение тогда и только тогда, когда предварительные условия метода 
нарушены, то есть когда оно не может быть выполнено в текущих условиях.

Вот несколько примеров, когда вы хотели бы создать исключение:
- метод должен прочитать файл, но этот файл не существует (FileNotFoundException);
- метод должен анализировать месяц из входной строки, но строка является недопустимой (InvalidArgumentException).

Рекомендуется выбрасывать исключения, которые наиболее релевантны (специфичны) к проблеме: лучше выбрасывать объект 
InvalidArgumentException, чем базовый класс Exception.
=====================================================Командная строка(Command line)==============================================================
whoami - показать имя текущего пользователя
dir - показать не скрытые папки и файлы
dir /A - показать все файлы и папки в текущей директории, в том числе и скрытые
dir /S - показать все папки и подпапки в текущей директории
echo print - напечатать "print"
mkdir papers - создать папку "papers", в текущей директории
cd C:\users\student\papers - перейти к папке "papers"
cd .. - вернуться в предыдущую папку
cd / - перейти в корневую папку
help - описание команд
java -version - узнать версию Java
javac Main.java - компиляция программы
java Main - запуск программы

CD [/D] [drive:][path]
СD - имя команды
[/D] - опция(флаг)
[drive:][path] - параметр



===================================================================================================================================
=============================================================ООП===================================================================
===================================================================================================================================
Основные принципы ООП
1) Инкапсуляция(Encapsulation) обеспечивает объединение (=инкапсуляцию) данных и методов, работающих с этими 
данными, в единое целое. Это также относится к способности объекта скрывать внутреннюю структуру своих 
свойств и методов.
2) Абстракция(Data abstraction) данных означает, что объекты должны предоставлять упрощенную, абстрактную версию своих 
реализаций. Детали их внутренней работы обычно не нужны пользователю,поэтому нет необходимости представлять 
их. Абстракция также означает, что будут представлены только наиболее релевантные признаки объекта.
3) Наследование(Inheritance) это механизм определения родительских отношений между классами. Часто объекты 
очень похожи, поэтому наследование позволяет программистам повторно использовать общую логику и в то же время
вводить уникальные понятия в классы
4) Полиморфизм() буквально означает одно имя и много форм, и речь идет о наследовании классов. Это позволяет 
программистам определять различную логику для одного и того же метода. Таким образом, имя (или интерфейс) 
остается прежним, но выполняемые действия могут отличаться.

=============================================================Классы================================================================

Новый класс объявляется с ключевым словом class, за которым следует имя класса. Например, таким образом можно создать класс Nothing:
class Nothing {
    // empty body
}

Тело класса может включать переменные экземпляра, методы и конструкторы. Переменные экземпляра хранят данные, методы определяют 
поведение, а конструкторы позволяют создавать и инициализировать новые объекты класса. переменные экземпляра и методы считаются 
членами класса. Не все классы Java имеют переменные экземпляра и методы, поэтому иногда вы увидите классы без них.
Исходный код класса помещается в файл.java. Обычно файл исходного кода содержит только один класс и имеет то же имя, что и этот 
класс, но иногда файл может содержать больше классов.
Переменная экземпляра(field) - это переменная, в которой хранятся данные. Он может иметь любой тип, включая примитивные типы (int, float, boolean и т. д.) и 
классы (даже один и тот же класс). Класс может иметь столько полей, сколько вам нужно.
class Patient {
    String name;
    int age;
    float height;
    String[] complaints;
}

Давайте создадим объект класса Patient с помощью ключевого слова new
Patient patient = new Patient();

При создании нового объекта каждое поле инициализируется значением по умолчанию соответствующего типа.
System.out.println(patient.name); // it prints null
System.out.println(patient.age); // it prints 0

Следующая программа создает два объекта класса Patient и печатает информацию о них.
Обратите внимание, что оба класса помещаются в один и тот же файл с именем PatientDemo.java.
public class PatientDemo {
    public static void main(String args[]) {
        Patient john = new Patient();
        
        john.name = "John";
        john.age = 30;
        john.height = 180;
        
        System.out.println(john.name + " " + john.age + " " + john.height);
            
        Patient alice = new Patient();

        alice.name = "Alice";
        alice.age = 22;
        alice.height = 165;
        
        System.out.println(alice.name + " " + alice.age + " " + alice.height);
    }
}

class Patient {
    String name;
    int age;
    float height;
}

==========================================================Метод экземпляра=========================================================
Все методы в Java можно разделить на две группы: статические(static) методы и методы экземпляра. Когда мы имеем дело со всеми объектами 
класса, мы вызываем статический метод. Это означает, что данный тип метода связан с классом в целом. Таким образом, для запуска 
метода не требуется создавать объект класса. Метод экземпляра, с другой стороны, может быть вызван только через объект класса,
так что сначала вам нужно создать объект.

Давайте объявим класс MyClass с одним экземпляром метода print . Обратите внимание, что метод экземпляра не имеет ключевого слова 
static в своем объявлении:
class MyClass {
    public void print() {
        System.out.println("instance method");
    }
}

Метод экземпляра-это метод, который принадлежит каждому созданному нами объекту определенного класса. Он также может получить 
доступ к своим полям. Смотрите, как это делается в коде ниже:
class MyClass {
    int field;
    public void print() {
        System.out.println(this.field);
    }
}

Ключевое слово this представляет конкретный экземпляр класса MyClass. Это ключевое слово является необязательным, но очень полезным,
когда речь заходит об управлении объектами класса.
Что важно в методах экземпляра, так это то, что они могут принимать аргументы и возвращать значения любого типа, включая тот же тип,
что и созданный класс.

Чтобы вызвать метод экземпляра, необходимо создать объект класса. Давайте создадим экземпляр класса MyClass и вызовем метод print, 
чтобы посмотреть, как все это работает
public static void main(String[] args) {
   MyClass object = new MyClass();
   object.field = 10;
   object.print(); // prints "10"
}
Мы определили метод print() так, чтобы он печатал значение field объекта, вызвавшего этот метод. Ключевое слово this позволяет нам 
получить доступ к значению того конкретного объекта, который мы только что создали. Поскольку мы определили значение поля для 
нашего объекта как 10, код также выводит 10

/**
 * The class is a "blueprint" for cats
 */
class Cat {
    String name; // the cat's name
    boolean sleeping; // the current state of the cat (by default - false)
    /**
     * The cat says "meow" if it is not sleeping, otherwise it says "zzz".
     * After saying "meow" the cat can sometimes fall asleep.
     */
    public void say() {
        if (sleeping) {
            System.out.println("zzz");
        } else {
            System.out.println("meow");

            if (Math.random() > 0.5) {
                sleeping = true;
            }
        }
    }
    /**
     * This method wakes the cat up.
     */
    public void wakeUp() {
        sleeping = false;
    }
}
Теперь мы можем создать экземпляр этого класса и вызвать его методы. Не забывайте, что когда кошка создана, она бодрствует!
public class CatsDemo {
    public static void main(String[] args) {
        Cat pharaoh = new Cat(); // an instance named "pharaoh"
        pharaoh.name = "pharaoh";       
        for (int i = 0; i < 5; i++) {
            pharaoh.say(); // it says "meow" or "zzz"
        }
        pharaoh.wakeUp(); // invoking the instance method
        pharaoh.say();
    }
}
Обратите внимание, что выходные данные программы могут быть разными, потому что мы используем Math.random() внутри метода say. 
Вот пример вывода
meow
meow
meow
zzz
zzz
meow

=========================================================Объекты (Objects)=========================================================
Ключевое слово new создает объект определенного класса. Здесь мы создаем стандартную строку и присваиваем ее переменной str
String str = new String("hello");

Переменная str хранит ссылку на объект "hello", расположенный где-то в куче памяти.

Точно так же мы можем создать объект любого известного нам класса.
Вот класс, описывающий пациента в больничной информационной системе
lass Patient {
    String name;
    int age;
}

Вот пример создания объекта этого класса:
Patient patient = new Patient();

В программировании существует важное понятие, называемое неизменяемостью (Immutability). Неизменность означает, что объект всегда хранит одни и 
те же значения. Если нам нужно изменить эти значения, мы должны создать новый объект. Распространенным примером является 
стандартный класс String. Строки являются неизменяемыми объектами, поэтому все строковые операции создают новую строку. 
Неизменяемые типы позволяют писать программы с меньшим количеством ошибок.
Класс Patient не является неизменяемым, потому что можно изменить любое поле объекта.
Patient patient = new Patient();
patient.name = "Mary";
patient.name = "Alice";

Несколько переменных могут ссылаться на один и тот же объект. Важно понимать, что две переменные относятся к одним и тем же данным 
в памяти, а не к двум независимым копиям. Поскольку наш класс является изменяемым, мы можем изменить объект, используя обе ссылки.
Patient patient = new Patient();
patient.name = "Mary";
patient.age = 24;
System.out.println(patient.name + " " + patient.age); // Mary 24
рatient p = patient;
System.out.println(p.name + " " + p.age); // Mary 24

Как и для любых ссылочных типов, переменная типа класса может быть нулевой, что означает, что она еще не инициализирована.
Patient patient = null;

==========================================================Immutability=============================================================
В философии существует мысленный эксперимент под названием "Корабль Тесея". Это одна из старейших концепций в западной философии, и 
она выглядит так. Знаменитый корабль героя Тесея хранится в качестве музейного экспоната в гавани. За эти годы деревянные детали 
сгнили и были заменены. Сто лет спустя все деревянные части корабля были заменены. Вопрос в следующем: это все тот же корабль?

Что нас интересует, так это то, что этот вопрос идентичности может быть применен и к программированию. Одним из наиболее важных 
понятий в программировании, непосредственно связанных с изменением и идентичностью, является понятие (im)mutability.

Изменчивость буквально означает "качество изменчивости", и в программировании это относится к идее изменения состояния объекта после 
его создания.

В этом направлении мы можем различать изменяемые и неизменяемые объекты. Проще говоря, изменяемые объекты могут быть изменены 
после их создания, а неизменяемые-нет. Это ключевое различие между изменяемыми и неизменяемыми объектами.

Что это означает на практике? Неизменяемые объекты всегда представляют одно и то же значение: если вы хотите иметь другое значение, 
вам нужно создать совершенно новый объект или переназначить значение существующего. С изменяемыми объектами все намного проще, и мы 
можем изменять значения, которые они содержат, без переназначения переменной или создания нового объекта.

Возвращаясь к кораблю Тесея, если бы мы рассматривали его как неизменный объект, то ответ на вопрос об идентичности был бы отрицательным. 
Как только вы что-то меняете, у вас появляется другой объект. Другими словами, корабль Тесея больше не является кораблем Тесея, хотя и 
имеет то же название!

С другой стороны, если мы рассматриваем корабль как изменяемый объект, то да, это все тот же корабль. Изменения, которые мы внесли, не 
повлияли на его идентичность.

В зависимости от используемого языка программирования различные типы объектов могут быть неизменяемыми. Например, строки неизменяемы в 
Python и Java, но в Java также есть другой тип строк, который является изменяемым. В Ruby и PHP строки изменчивы. При написании программы 
на вашем любимом языке вам необходимо учитывать, какие объекты являются изменяемыми, а какие неизменяемыми на этом конкретном языке.

Как правило, объекты пользовательских классов изменчивы. Однако бывают случаи, когда мы хотели бы сделать их неизменяемыми: неизменяемые 
объекты потокобезопасны, их легче тестировать, и они могут быть более безопасными.

Неизменяемые объекты могут совместно использоваться различными потоками без дополнительной защиты. Состояние изменяемых объектов трудно 
отслеживать, пока они могут быть изменены любым из рабочих потоков.

В контексте пользовательских объектов мы также можем говорить о слабой неизменяемости и сильной неизменяемости. Слабая неизменяемость-это 
когда некоторые поля объекта неизменяемы, а другие изменяемы. Сильная неизменность-это когда все поля объекта неизменны.

Конкретные инструкции о том, как сделать пользовательский класс неизменяемым, зависят от языка, но мы можем дать общие рекомендации. 
В принципе, вам нужно запретить изменять значение поля после его создания или запретить переназначение значения. Это можно сделать, 
например, сделав переменную доступной только для чтения или константой. Другой вариант-изменить методы, задающие значения атрибутов, 
чтобы они создавали исключения. Вы также можете работать с модификаторами доступа: сделайте поля недоступными извне класса.

Подводя итог, разница между изменяемыми и неизменяемыми объектами заключается в том, что изменяемые объекты могут изменять свои состояния 
после создания, а неизменяемые объекты-нет. Языки имеют свое собственное разделение на изменяемые и неизменяемые объекты. Пользовательские 
классы обычно изменчивы, но при необходимости могут быть сделаны неизменяемыми с помощью специфичных для языка инструментов и методов.

=====================================================Перегрузка(Overloading)=======================================================
Перегрузка позволяет изменить сигнатуру метода: количество параметров, их тип или и то, и другое. Если методы имеют одно и то же 
имя, но другое число или тип параметров, они перегружаются. Это означает, что вы можете вызывать разные методы с одним и тем же 
именем, передавая разные аргументы.

В качестве примера рассмотрим некоторый перегруженный метод из стандартного класса Math:
public static int abs(int a) { return (a < 0) ? -a : a; }
public static float abs(float a) { return (a <= 0.0F) ? 0.0F - a : a; }
Эти методы имеют одно и то же имя, но другой тип аргумента. Они перегружены.

Важно отметить, что невозможно объявить более одного метода с одним и тем же именем и параметрами (числом и типами), даже с разными 
типами возвращаемых значений. Возвращаемый тип не рассматривается для перегрузки, поскольку он не является частью сигнатуры.

Вот четыре метода print для печати различных значений.
public static void print(String stringToPrint) {
    System.out.println(stringToPrint);
}

public static void print(String stringToPrint, int times) {
    for (int i = 0; i < times; i++) {
        System.out.println(stringToPrint);
    }
}

public static void print(int times, String stringToPrint) {
    for (int i = 0; i < times; i++) {
        System.out.println(stringToPrint);
    }
}

public static void print(int val) {
    System.out.println(val);
}

Первый метод печатает входную строку, второй и третий печатают входную строку заданное количество раз, а последний печатает целое 
значение. Эти методы перегружены.

Давайте вызовем эти методы:
print("some string");
print("another string", 2);
print(2, "another string again");
print(5);
Как видите, любой из этих методов можно назвать одним и тем же именем, передавая подходящие аргументы. 
Выходы кода:
some string
another string
another string
another string again
another string again
5

Заметим, что в случае, когда параметры имеют разные типы, изменение порядка этих параметров является допустимым случаем перегрузки, 
как и во втором и третьем методах из приведенного выше примера.

Чтобы понять, как перегрузка имеет дело с приведением типов, давайте рассмотрим пример перегруженных методов, которые отличаются 
только типом одного аргумента, и посмотрим, когда каждый из них будет вызван и почему.

public class OverloadingExample {

    public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void print(int a) {
        System.out.println("int arg: " + a);
    }

    public static void print(long a) {
        System.out.println("long arg: " + a);
    }

    public static void print(double a) {
        System.out.println("double arg: " + a);
    }

    public static void main(String[] args) {
        print(100);
    }
}

Теперь, если мы вызовем print(100), программа выведет:
int arg: 100

Здесь мы видим, что 100 обрабатывается как int и вызывается соответствующий метод.

В случае, когда тип параметра метода не совсем совпадает с типом передаваемого аргумента, компилятор выбирает метод, который имеет 
ближайший тип аргумента в порядке неявного приведения.
Поскольку все целочисленные литералы по умолчанию обрабатываются как int, int будет отправной точкой. Ближайшая к ней будет long

Давайте удалим или прокомментируем метод public static void print(int a), затем перекомпилируем и снова запустим программу. 
Результат такой, как и ожидалось: long arg: 100

Хорошо, теперь давайте также удалим метод public static void print(long a). Поскольку у нас нет метода с аргументом float, 
следующий тип в порядке неявного приведения типов будет double. После перекомпиляции программа выводит: double arg: 100.0

Если мы удалим метод public static void print(double a), то единственный оставшийся у нас метод-это метод с short аргументом. 
Программа не будет компилироваться, если мы просто вызовем print(100), как делали это раньше.
Давайте объясним почему. Когда мы передаем некоторое значение методу, компилятор не вычисляет его. Все, что известно, это то, что 
он является целочисленным литералом и, следовательно, имеет целочисленный тип.
В нашем случае, поскольку 100 по умолчанию рассматривается как int и JVM не знает, может ли передаваемое значение быть безопасно 
приведено к short, единственный способ передать короткий аргумент-это явное приведение значения:

public class OverloadingExample {

    public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void main(String[] args) {
        print((short) 100);  // explicit casting 
    }
}

===================================================Аннотации (Annotations basics)==================================================
В Java аннотации-это своего рода метаданные, которые предоставляют информацию о программе. Они могут отмечать классы, методы, поля, 
переменные и другие элементы программы.
Аннотации могут использоваться для различных целей:
- чтобы предоставить информацию для компилятора;
- чтобы предоставить информацию для инструментов разработки для генерации кода, XML-файлов и так далее;
- предоставление информации для фреймворков и библиотек во время выполнения.

Чтобы отметить элемент (class/method/field/etc) аннотацией, нам нужно написать символ @, за которым следует имя аннотации. Например:

@Deprecated

Символ @ сигнализирует компилятору, что это аннотация.

Java имеет три встроенных аннотации общего назначения:
1 @Deprecated указывает, что помеченный элемент (класс, метод, поле и т. Д.) устарел и больше не должен использоваться. Эта 
аннотация предупреждает компилятор, если элемент используется.
2 @SuppressWarnings указывает компилятору отключить compile-time warnings, указанные в параметрах аннотации. Эта аннотация может 
быть применена к классам, методам, полям, локальным переменным и другим элементам.
3 @Override отмечает метод, который переопределяет метод суперкласса. Эта аннотация может быть применена только к методам. 

Давайте создадим аннотацию метода в качестве примера:

@Deprecated
public static void method() {
    System.out.println("an old method");
}

Эта аннотация указывает на то, что метод не должен использоваться.

Когда дело доходит до @Deprecated, вы даже можете отказаться от целого класса:

@Deprecated
class MyClass {
    // fields and methods
}

Мы можем пометить класс/метод/поле/и т. Д. двумя или более аннотациями!

Некоторые аннотации включают элементы, и эти элементы имеют тип. Например, в аннотации @SuppressWarnings есть элемент с именем 
value, указывающий, какой тип предупреждения мы хотели бы отключить.

@SuppressWarnings(value = "unused")
public static void method() {
    int a = 0;
}

Сейчас достаточно помнить два возможных значения: "unused" и "deprecation". Первый из них предписывает компилятору не обращать 
внимание на неиспользуемые локальных переменные, второй — не обращать внимание на предупреждения об использовании устаревших 
элементов.

Если в аннотации есть только один элемент и он называется value, то имя этого элемента можно опустить (это так называемый 
безымянный элемент):

@SuppressWarnings("unused") 
public static void method() { 
    int a = 0; 
}

Элемент аннотации также может быть массивом. Здесь, например, value - это массив:

@SuppressWarnings({"unused", "deprecation"})
public static void method() { ... }

Приведенный выше код верен, потому что единственный элемент @SuppressWarnings является массивом.

Если элемент аннотации имеет значение по умолчанию, мы можем пропустить его. Например , значение элемента @SuppressWarnings не 
имеет значения по умолчанию, поэтому его нельзя пропустить. Следующий синтаксис неверен:

@SuppressWarnings // it's not a correct syntax for this annotation
public static void method() { ... }

Предположим, у нас есть внешняя библиотека, которая включает в себя две аннотации @NotNull и @Range. Обе аннотации отмечают классы, 
поля, методы и параметры.

Аннотация @NotNull указывает на то, что:
- метод не должен возвращать null;
- переменная не может быть равна null.

Аннотация @Range указывает на то, что:
- метод возвращает целое число, принадлежащее указанному диапазону;
- переменная всегда принадлежит заданному диапазону.

Чтобы продемонстрировать, как работают эти аннотации, приведем класс, представляющий персонажа компьютерной игры.

class GameCharacter {

    @NotNull
    private String login;

    @Range(min = 1, max = 100)
    private int level = 1;

    public GameCharacter(
            @NotNull String login,
            @Range(min = 1, max = 100) int level) {

        this.login = login;
        this.level = level;
    }

    @NotNull
    public String getLogin() {
        return login;
    }

    @Range(min = 1, max = 100)
    public int getLevel() {
        return level;
    }
}

Примечание: аннотация @NotNull взята из JetBrains. Аннотация @Range написана просто как пример, но некоторые фреймворки и 
библиотеки имеют аннотацию с тем же именем, но немного другим значением.

========================================Скрытие и переопределение (Hiding and overriding)==========================================
Java предоставляет возможность объявить метод в подклассе с тем же именем, что и метод в суперклассе. Это называется 
переопределением метода. Преимущество переопределения заключается в том, что подкласс может дать свою собственную конкретную 
реализацию метода суперкласса.
Переопределение методов в подклассах позволяет классу наследовать от суперкласса, поведение которого "достаточно близко", а затем 
изменять это поведение по мере необходимости подкласса.
Методы экземпляра могут быть переопределены, если они наследуются подклассом. Переопределяющий метод должен иметь то же имя, 
параметры (количество и тип параметров) и тип возвращаемого значения (или подкласс типа), что и переопределяемый метод.

Вот пример переопределения.

class Mammal {

    public String sayHello() {
        return "ohlllalalalalalaoaoaoa";
    }
}

class Cat extends Mammal {

    @Override
    public String sayHello() {
        return "meow";
    }
}

class Human extends Mammal {

    @Override
    public String sayHello() {
        return "hello";
    }
}

Иерархия включает три класса: Mammal, Cat и Human. Класс Mammal имеет метод sayHello. Каждый подкласс переопределяет 
этот метод. Аннотация @Override указывает, что метод переопределен. Эта аннотация необязательна, но полезна.

Давайте создадим экземпляры и вызовем метод.

Mammal mammal = new Mammal();
System.out.println(mammal.sayHello()); // it prints "ohlllalalalalalaoaoaoa"

Cat cat = new Cat();
System.out.println(cat.sayHello()); // it prints "meow"

Human human = new Human();
System.out.println(human.sayHello()); // it prints "hello"

Вы можете вызвать метод базового класса в переопределенном методе, используя ключевое слово super.

Существует несколько правил для методов подклассов, которые должны переопределять методы суперкласса:

- метод должен иметь то же имя, что и в суперклассе;
- аргументы должны быть точно такими же, как и в методе суперкласса; 
- тип возвращаемого значения должен быть тем же типом или подтипом типа возвращаемого значения, объявленного в методе суперкласса;
- уровень доступа должен быть таким же или более открытым, чем уровень доступа переопределенного метода;
- метод c уровнем доступа private не может быть переопределен, поскольку он не наследуется подклассами;
- если суперкласс и его подкласс находятся в одном пакете, то методы c уровнем доступа default могут быть переопределены;
- статические методы не могут быть переопределены

Для проверки этих правил существует специальная аннотация @Override. Это позволяет вам узнать, будет ли метод фактически 
переопределен или нет. Если по какой-то причине компилятор решит, что метод не может быть переопределен, он выдаст ошибку.

Если вы хотите запретить переопределение метода, объявите его с помощью ключевого слова final

public final void method() {
    // do something
}

Теперь, если вы попытаетесь переопределить этот метод в подклассе, произойдет ошибка времени компиляции.

Напомним, что перегрузка - это функция, которая позволяет классу иметь более одного метода с одинаковым именем, если их аргументы 
различны. Мы также можем одновременно переопределять и перегружать метод экземпляра в подклассе. Перегруженные методы не 
переопределяют методы экземпляра суперкласса. Это новые методы, уникальные для данного подкласса.

class SuperClass {

    public void invokeInstanceMethod() {
        System.out.println("SuperClass: invokeInstanceMethod");
    }
}

class SubClass extends SuperClass {

    @Override
    public void invokeInstanceMethod() {
        System.out.println("SubClass: invokeInstanceMethod is overridden");
    }
    
    // @Override -- method doesn't override anything
    public void invokeInstanceMethod(String s) {
        System.out.println("SubClass: overloaded invokeInstanceMethod");
    }
}

Следующий код создает экземпляр и вызывает оба метода:

SubClass clazz = new SubClass();

clazz.invokeInstanceMethod();    // SubClass: invokeInstanceMethod() is overridden
clazz.invokeInstanceMethod("s"); // SubClass: overloaded invokeInstanceMethod(String)

Помните, что переопределение и перегрузка-это разные механизмы, но вы можете смешать их вместе в одной иерархии классов.

Статические методы не могут быть переопределены. Если подкласс имеет статический метод с той же сигнатурой (именем и параметрами), 
что и статический метод в суперклассе, то метод в подклассе скрывает метод в суперклассе. Это совершенно не похоже на 
переопределение методов.

Вы получите ошибку времени компиляции, если подкласс имеет статический метод с той же сигнатурой, что и метод экземпляра в 
суперклассе, или наоборот. Но если методы имеют одно и то же имя, но разные параметры, то проблем быть не должно.


Пример:

class Publication {

    private String title;

    public Publication(String title) {
        this.title = title;
    }

    public String getDetails() {
        return "title=\"" + title + "\"";
    }

}

class Newspaper extends Publication {

    private String source;

    public Newspaper(String title, String source) {
        super(title);
        this.source = source;
    }

    @Override
    public String getDetails() {
        return super.getDetails() + ", source=\"" + source + "\"";
    }
}

class Article extends Publication {

    private String author;

    public Article(String title, String author) {
        super(title);
        this.author = author;
    }

    @Override
    public String getDetails() {
        return super.getDetails() + ", author=\"" + author + "\"";
    }
}

class Announcement extends Publication {

    private int daysToExpire;

    public Announcement(String title, int daysToExpire) {
        super(title);
        this.daysToExpire = daysToExpire;
    }

    @Override
    public String getDetails() {
        return super.getDetails() + ", daysToExpire=" + daysToExpire;
    }
}

=======================================================Covariant return types======================================================
Как вы уже знаете, переопределение метода-это механизм для обеспечения нового поведения метода суперкласса в методе подкласса.

Переопределение метода следует набору определенных правил. При переопределении метода суперкласса имя и параметры метода подкласса 
должны быть точно такими же, как у метода суперкласса. Однако ситуация с типом возврата несколько отличается. Метод подкласса может 
возвращать тот же тип, что и метод суперкласса, или подтип этого типа возврата. Эта функция известна как ковариантный тип возврата.

class SuperType { }

class SubType extends SuperType { }

class A {
    
    public SuperType getType() {
        return new SuperType();
    }
}

class B extends A {
    
    @Override
    public SubType getType() {
        return new SubType();
    }
}

В этом примере класс SubType наследуется от класса SuperType. Метод GetType класса A возвращает экземпляр класса SuperType, но 
переопределенный метод GetType класса B (который расширяет A) возвращает экземпляр класса SubType. Ошибок во время компиляции нет, 
это переопределение работает идеально.

Помните, что при переопределении возвращаемого типа метода подкласса может быть тот же тип или подкласс возвращаемого типа метода 
суперкласса. Ковариация всегда меняется вниз по иерархии.
Также важно отметить, что ковариантные типы возврата возможны только для непримитивных типов возврата.


======================================================Полиморфизм(Polymorphism)====================================================
Java предоставляет два типа полиморфизма: static (compile-time) и dynamic (run-time). Первый достигается перегрузкой метода, второй 
основан на наследовании и переопределении метода.

Более теоретический подход подразделяет полиморфизм на несколько принципиально различных типов:
- Ad-hoc полиморфизм относится к полиморфным функциям, которые могут быть применены к аргументам различных типов, но ведут себя 
по-разному в зависимости от типа аргумента, к которому они применяются. Java поддерживает его как перегрузку метода.
- Subtype polymorphism (also known as subtyping) - это возможность использовать экземпляр подкласса, когда разрешен экземпляр 
базового класса.
- Parametric polymorphism - это когда код написан без упоминания какого-либо конкретного типа и, таким образом, может быть 
прозрачно использован с любым количеством новых типов. Java поддерживает его как дженерики или универсальное программирование.

В этом разделе мы рассмотрим только Subtype polymorphism, который широко используется в объектно-ориентированном программировании.

Напоминание: переопределение метода-это когда подкласс переопределяет метод суперкласса с той же сигнатурой
run-time polymorphism основан на двух принципах:
- ссылочная переменная суперкласса может ссылаться на любой объект подтипа;
- метод суперкласса может быть переопределен в подклассе.

Пример. Здесь вы можете увидеть иерархию классов. Суперкласс MythicalAnimal имеет два подкласса: Chimera и Dragon. Базовый класс 
имеет метод hello. Оба подкласса переопределяют этот метод.

class MythicalAnimal {    

    public void hello() {
        System.out.println("Hello, I'm an unknown animal");
    }
}

class Chimera extends MythicalAnimal {
    @Override
    public void hello() {
        System.out.println("Hello! Hello!");
    }
}

class Dragon extends MythicalAnimal {
    @Override
    public void hello() {
        System.out.println("Rrrr...");
    }
}

Мы можем создать ссылку на класс MythicalAnimal и присвоить ему объект подкласса:
MythicalAnimal chimera = new Chimera();
MythicalAnimal dragon = new Dragon();
MythicalAnimal animal = new MythicalAnimal();

Мы также можем вызывать переопределенные методы через ссылки на базовый класс:
chimera.hello(); // Hello! Hello!
dragon.hello(); // Rrrr...
animal.hello(); // Hello, i'm an unknown animal

Таким образом, результат вызова метода зависит от фактического типа экземпляра, а не от ссылочного типа. Это полиморфная функция в 
Java. JVM вызывает соответствующий метод для объекта, на который ссылается каждая переменная.

Полиморфизм подтипов позволяет классу определять методы, которые будут общими для всех его подклассов, в то же время позволяя 
подклассам определять конкретные реализации некоторых или всех этих методов. Это очень полезно для объектно-ориентированного 
проектирования, особенно вместе с абстрактными методами и интерфейсами, о которых вы узнаете в других разделах.

То же самое работает с методами, которые используются только внутри иерархии и недоступны извне

Пример. Существует иерархия файлов. Родительский класс File представляет собой описание одного файла в файловой системе. У него 
есть подкласс с именем ImageFile. Он переопределяет метод GetFileInfo родительского класса.

class File {

    protected String fullName;

    // constructor with a single parameter

    // getters and setters

    public void printFileInfo() {
        String info = this.getFileInfo(); // here is polymorphic behavior!!!
        System.out.println(info);
    }

    protected String getFileInfo() {
        return "File: " + fullName;
    }
}

class ImageFile extends File {

    protected int width;
    protected int height;
    protected byte[] content;

    // constructor

    // getters and setters

    @Override
    protected String getFileInfo() {
        return String.format("Image: %s, width: %d, height: %d", fullName, width, height); 
    }
}

Родительский класс имеет public метод printFileInfo и protected метод GetFileInfo. Второй метод переопределяется в подклассе, но 
подкласс не переопределяет первый метод.

Давайте создадим экземпляр ImageFile и назначим его переменной File.

File img = new ImageFile("/path/to/file/img.png", 480, 640, someBytes); // assigning an object

Теперь, когда мы вызываем метод printFileInfo, он вызывает переопределенную версию метода GetFileInfo.

img.printFileInfo(); // It prints "Image: /path/to/file/img.png, width: 480, height: 640"

Таким образом, run-time polymorphism позволяет вызывать переопределенный метод подкласса, имеющего ссылку на базовый класс.

Пример:

class Publication {

    private String title;

    public Publication(String title) {
        this.title = title;
    }

    public final String getInfo() {
        return getType() + getDetails() + ": " + this.title;
    }

    public String getType() {
        return "Publication";
    }

    public String getDetails() {
        return "";
    }

}

class Newspaper extends Publication {

    private String source;

    public Newspaper(String title, String source) {
        super(title);
        this.source = source;
    }

    @Override
    public String getType() {
        return "Newspaper ";
    }

    @Override
    public String getDetails() {
        return super.getDetails() + "(source - " + this.source + ")";
    }
}

class Article extends Publication {

    private String author;

    public Article(String title, String author) {
        super(title);
        this.author = author;
    }

    @Override
    public String getType() {
        return "Article ";
    }

    @Override
    public String getDetails() {
        return super.getDetails() + "(author - " + this.author + ")";
    }
}

class Announcement extends Publication {

    private int daysToExpire;

    public Announcement(String title, int daysToExpire) {
        super(title);
        this.daysToExpire = daysToExpire;
    }

    @Override
    public String getType() {
        return "Announcement ";
    }

    @Override
    public String getDetails() {
        return super.getDetails() + "(days to expire - " + this.daysToExpire + ")";
    }
}
========================================Перегрузка конструктора(Constructor Overloading)===========================================
Иногда нам нужно инициализировать все поля объекта при его создании, но в других случаях может быть уместно инициализировать только 
одно или несколько полей. К счастью, для этой цели класс может иметь несколько конструкторов, которые присваивают полям значения 
различными способами.
Вы можете определить столько конструкторов, сколько вам нужно. Каждый конструктор должен иметь имя, соответствующее имени класса, 
но параметры должны быть разными. Ситуации, когда класс содержит несколько конструкторов, называются перегрузкой конструктора.

public class Robot {
    String name;
    String model;

    public Robot() {
        this.name = "Anonymous";
        this.model = "Unknown";
    }

    public Robot(String name, String model) {
        this.name = name;
        this.model = model;
    }
}

Класс Robot имеет два конструктора:
Robot() это конструктор без аргументов, который инициализирует поля значениями по умолчанию;
Robot(String name, String model) принимает два параметра и присваивает их соответствующим полям.

Для создания экземпляра класса Robot мы можем использовать любой из двух конструкторов:
Robot anonymous = new Robot(); // name is "Anonymous", model is "Unknown"
Robot andrew = new Robot("Andrew", "NDR-114"); // name is "Andrew", model is "NDR-114"

Имейте в виду, что вы не можете определить два конструктора с одинаковым числом, типами и порядком параметров!

Мы также можем вызвать конструктор из другого. Он позволяет инициализировать одну часть объекта одним конструктором, а другую-другим 
конструктором.
Вызов конструктора внутри другого выполняется с помощью ключевого слова this. Например:
this(); // calls a no-argument constructor
Если вы вызвали конструктор с параметрами вы можете передать некоторые аргументы:
this("arg1", "arg2"); // calls a constructor with two string arguments

Помните, что оператор для вызова конструктора должен быть первым оператором в теле вызывающего конструктора!

public class Robot {
    String name;
    String model;
    int lifetime;

    public Robot() {
        this.name = "Anonymous";
        this.model = "Unknown";
    }

    public Robot(String name, String model) {
        this(name, model, 20);
    }

    public Robot(String name, String model, int lifetime) {
        this.name = name;
        this.model = model;
        this.lifetime = lifetime;
    }
}

Теперь в классе есть три конструктора:
Robot() это конструктор без аргументов, который инициализирует поля значениями по умолчанию;
Robot(String name, String model) это конструктор с двумя аргументами, который вызывает другой конструктор;
Robot(String name, String model, int lifetime) это конструктор с тремя аргументами, который заполняет все поля.

Давайте добавим вывод в третий конструктор и посмотрим результат:

public Robot(String name, String model, int lifetime) {
    this.name = name;
    this.model = model;
    this.lifetime = lifetime;
    System.out.println("The third constructor is invoked");
}

Теперь давайте создадим экземпляр с помощью конструктора с двумя аргументами
Robot andrew = new Robot("Andrew", "NDR-114");
Выходы программы:
The third constructor is invoked

Пример:
class Employee {

    String name;
    int salary;
    String address;

    public Employee() {
        this("unknown", 0, "unknown");
    }

    public Employee(String name, int salary) {
        this(name, salary, "unknown");
    }

    public Employee(String name, int salary, String address) {
        this.name = name;
        this.salary = salary;
        this.address = address;
    }
}

============================================Ключевое слово super(The keyword super)================================================
Иногда, когда мы определяем новый подкласс, нам нужно получить доступ к членам или конструкторам его суперкласса. Java предоставляет 
для этого специальное ключевое слово super. Это ключевое слово может быть использовано в нескольких случаях:
- для доступа к полям экземпляра родительского класса;
- для вызова методов родительского класса;
- для вызова конструкторов родительского класса (no-arg или параметризованных).

Ключевое слово super может использоваться для доступа к методам экземпляра или полям суперкласса. В некотором смысле это похоже на 
ключевое слово this, но оно относится к непосредственному родительскому объекту класса.
Ключевое слово super является необязательным, если члены подкласса имеют разные имена от членов суперкласса. В противном случае 
использование super-это правильный способ доступа к скрытым (с тем же именем) членам базового класса.

Пример. Существует два класса: SuperClass и SubClass. Каждый класс имеет поле и метод.
class SuperClass {
    
    protected int field;

    protected int getField() {
        return field;
    }
    
    protected void printBaseValue() {
        System.out.println(field);
    }
}

class SubClass extends SuperClass {
    
    protected int field;

    public SubClass() {
        this.field = 30;  // It initializes the field of SubClass
        field = 30;       // It also initializes the field of SubClass
        super.field = 20; // It initializes the field of SuperClass
    }

    /**     
     * It prints the value of SuperClass and then the value of SubClass
     */
    public void printSubValue() {
        super.printBaseValue(); // It invokes the method of SuperClass, super is optional here
        System.out.println(field);
    }
}

В конструкторе SubClass поле field суперкласса инициализируется с помощью ключевого слова super. Здесь нам нужно использовать 
ключевое слово super, потому поле field подкласса и поле field базового класса называются одинаково.
В теле метода printSubValue вызывается метод суперкласса printBaseValue. Здесь ключевое слово super является необязательным. Это 
необходимо, если метод подкласса имеет то же имя, что и метод в базовом классе. 

Конструкторы не наследуются подклассами, но конструктор суперкласса может быть вызван из подкласса с помощью ключевого слова super 
со скобками. Мы также можем передать некоторые аргументы конструктору суперкласса.

Два важных момента:
- вызов super(...) должен быть первым оператором в конструкторе подкласса, в противном случае код не может быть скомпилирован;
- стандартный конструктор подкласса автоматически вызывает конструктор без аргументов суперкласса.

Пример. Вот два класса Person и Employee. Второй класс расширяет первый. Каждый класс имеет конструктор для инициализации полей.

class Person {

    protected String name;
    protected int yearOfBirth;
    protected String address;

    public Person(String name, int yearOfBirth, String address) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.address = address;
    }

    // getters and setters
}

class Employee extends Person {

    protected Date startDate;
    protected Long salary;

    public Employee(String name, int yearOfBirth, String address, Date startDate, Long salary) {
        super(name, yearOfBirth, address); // invoking a constructor of the superclass
        
        this.startDate = startDate;
        this.salary = salary;
    }

    // getters and setters
}

В приведенном примере конструктор класса Employee вызывает конструктор родительского класса для присвоения значений переданным 
полям. В некотором смысле это напоминает работу с несколькими конструкторами, использующими this().

Пример:

class BankAccount {

    protected String number;
    protected Long balance;

    public BankAccount(String number, Long balance) {
        this.number = number;
        this.balance = balance;
    }
}

class CheckingAccount extends BankAccount {

    double fee;

    public CheckingAccount(String number, Long balance, double fee) {
        super(number, balance);

        this.fee = fee;
    }
}

class SavingAccount extends BankAccount {

    double interestRate;

    public SavingAccount(String number, Long balance, double interestRate) {
        super(number, balance);

        this.interestRate = interestRate;
    }
}

Пример:

class Employee {

    protected String name;
    protected String birthDate;

    public Employee(String name, String birthDate) {
        this.name = name;
        this.birthDate = birthDate;
    }
}

class RegularEmployee extends Employee {

    protected long salary;
    protected String hireDate;

    public RegularEmployee(String name, String birthDate, long salary, String hireDate) {
        super(name, birthDate);
        this.salary = salary;
        this.hireDate = hireDate;
    }
}

class ContractEmployee extends Employee {

    protected long payPerHour;
    protected String contractPeriod;

    public ContractEmployee(String name, String birthDate, long payPerHour, String contractPeriod) {
        super(name, birthDate);

        this.payPerHour = payPerHour;
        this.contractPeriod = contractPeriod;
    }
}

==============================================Абстрактный класс (Abstract class)===================================================
Иногда у вас есть набор полей и методов, которые необходимо повторно использовать во всех классах иерархии. Можно поместить все 
общие члены в специальный базовый класс, а затем объявить подклассы, которые могут получить доступ к этим членам. При этом вам не 
нужно создавать объекты базового класса. Чтобы достичь этого, вы можете использовать абстрактный класс в качестве базового класса в 
иерархии.

Абстрактный класс-это класс, объявленный с ключевым словом abstract. Он представляет собой абстрактное понятие, которое 
используется в качестве базового класса для подклассов.

Абстрактные классы имеют некоторые особенности:
- невозможно создать экземпляр абстрактного класса;
- абстрактный класс может содержать абстрактные методы, которые должны быть реализованы в неабстрактных подклассах;
- он может содержать поля и неабстрактные методы (в том числе статические);
- абстрактный класс может расширять другой класс, включая абстрактный;
- он может содержать конструктор.

Как видите, абстрактный класс имеет два основных отличия от обычных классов: отсутствие экземпляров и абстрактные методы.

Абстрактные методы объявляются путем добавления ключевого слова abstract. У них есть объявление (модификаторы, возвращаемый тип 
и подпись), но нет реализации. Каждый конкретный (не абстрактный) подкласс должен реализовывать эти методы.

Заметьте, статические методы не могут быть абстрактными!

Вот абстрактный класс Pet:

public abstract class Pet {

    protected String name;
    protected int age;

    protected Pet(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public abstract void say(); // an abstract method
}

Класс имеет два поля, конструктор и абстрактный метод.

Поскольку Pet является абстрактным классом мы не можем создавать экземпляры этого класса:

Pet pet = new Pet("Unnamed", 5); // this throws a compile time error

Метод say() объявлен абстрактным, поскольку на этом уровне абстракции его реализация неизвестна. Конкретные подклассы класса Pet 
должны иметь реализацию этого метода.

Ниже приведены два конкретных подкласса Pet. Вы можете видеть, что они переопределяют абстрактный метод:

class Cat extends Pet {

    // It can have additional fields as well

    public Cat(String name, int age) {
        super(name, age);
    }

    @Override
    public void say() {
        System.out.println("Meow!");
    }
}

class Dog extends Pet {

    // It can have additional fields as well

    public Dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void say() {
        System.out.println("Woof!");
    }
}

Мы можем создавать экземпляры этих классов и вызывать метод say().

Dog dog = new Dog("Boss", 5);
Cat cat = new Cat("Tiger", 2);
        
dog.say(); // it prints "Woof!"
cat.say(); // it prints "Meow!"

Не забывайте, что Java не поддерживает множественное наследование классов. Поэтому класс может расширять только один абстрактный 
класс.

Пример:

abstract class IntBinaryOperation {

    protected int firstArg;
    protected int secondArg;

    public IntBinaryOperation(int firstArg, int secondArg) {
        this.firstArg = firstArg;
        this.secondArg = secondArg;
    }

    public abstract int perform();
}

class Addition extends IntBinaryOperation {

    public Addition(int firstArg, int secondArg) {
        super(firstArg, secondArg);
    }

    @Override
    public int perform() {
        return firstArg + secondArg;
    }
}

class Multiplication extends IntBinaryOperation {

    public Multiplication(int firstArg, int secondArg) {
        super(firstArg, secondArg);
    }

    @Override
    public int perform() {
        return firstArg * secondArg;
    }
}

Пример 2:

abstract class Shape {

    abstract double getPerimeter();

    abstract double getArea();
}

class Triangle extends Shape {

    double a, b, c;

    Triangle(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    @Override
    double getPerimeter() {
        return a + b + c;
    }

    @Override
    double getArea() {
        return Math.sqrt((getPerimeter() / 2) * ((getPerimeter() / 2) - a) * ((getPerimeter() / 2) - b) * ((getPerimeter() / 2) - c));
    }
}


class Rectangle extends Shape {

    double length, width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double getPerimeter() {
        return (length + width) * 2;
    }

    @Override
    double getArea() {
        return length * width;
    }
}

class Circle extends Shape {

    double r;

    Circle(double r) {
        this.r = r;
    }

    @Override
    double getPerimeter() {
        return 2 * Math.PI * r;
    }

    @Override
    double getArea() {
        return Math.PI * Math.pow(r, 2);
    }
}

Пример 3:

abstract class A { 
    
    public static void staticFoo() { }
    
    public void instanceBar() { }
    
    public abstract void abstractFoo();
    
    public abstract void abstractBar();
}

abstract class B extends A { 
    
    public static void anotherStaticFoo() { }
    
    public void anotherInstanceBar() { }

    @Override
    public void abstractBar() { }
    
    public abstract void qq();
}

class C extends B {
    @Override
    public void abstractFoo() { }

    @Override
    public void qq() { }
}


=======================================================Interface(интерфейс)========================================================
Общая идея ООП и один из ее принципов-это абстракция. Это означает, что объекты реального мира могут быть представлены их 
абстрактными моделями. Проектирование моделей-это сосредоточение внимания на существенных особенностях объектов и отказ от других. 
Чтобы понять, что это значит, давайте взглянем на карандаш. Карандаш-это предмет, который мы можем использовать для рисования. 
Другие свойства, такие как материал или длина, иногда могут быть важны для нас, но не определяют идею карандаша.

Представьте, что нам нужно создать программу графического редактора. Одной из основных функций программы является рисование. Перед 
рисованием программа просит пользователя выбрать инструмент рисования. Это может быть ручка, карандаш, кисть, маркер, маркер, спрей 
и другие. Каждый инструмент из набора имеет свои особенности: карандаш и спрей оставляют разные следы, и это имеет значение. Но есть 
и существенная особенность, которая их объединяет: умение рисовать.

Теперь давайте рассмотрим класс Pencil, который является абстракцией карандаша. Как мы уже обсуждали, класс, по крайней мере, должен 
иметь метод draw, который принимает модель кривой. Это важнейшая функция карандаша для нашей программы. Предположим, что Curve-это 
класс, представляющий некоторую кривую:

class Pencil {
    ...
    public void draw(Curve curve) {...}
}

class Brush {
    ...
    public void draw(Curve curve) {...}
}

Каждый из них имеет метод draw, хотя и делает это по-своему. Умение рисовать является общей чертой для всех них. Давайте назовем эту 
функцию DrawingTool. Тогда мы можем сказать, что если класс имеет функцию DrawingTool, то он должен иметь возможность рисовать, это 
означает, что класс должен иметь метод void draw(Curve curve) { ... }.

Java позволяет объявлять эту функцию, вводя интерфейсы. Вот как выглядит наш интерфейс:

interface DrawingTool {
    void draw(Curve curve);
}

Он объявляет метод draw без тела метода.

Теперь давайте пометим классы, которые могут рисовать, добавив в объявление класса инструмент рисования. Если класс реализует 
интерфейс, он должен реализовать все объявленные методы:

class Pencil implements DrawingTool {
    ...
    public void draw(Curve curve) {...}
}

class Brush implements DrawingTool {
    ...
    public void draw(Curve curve) {...}
}

Теперь достаточно беглого взгляда на объявление класса, чтобы понять, что класс способен рисовать. Другими словами, основная идея 
интерфейса-объявление функциональности.

Еще одним важным преимуществом внедрения интерфейсов является то, что вы можете использовать их в качестве типа переменной:

DrawingTool pencil = new Pencil();
DrawingTool brush = new Brush();

Теперь объекты карандаша и кисти имеют один и тот же тип. Это означает, что оба класса можно рассматривать аналогичным образом как 
инструмент рисования. Это еще один способ поддержки полиморфизма, который помогает создать многоразовую функцию рисования программы 
графического редактора.

void drawCurve(DrawingTool tool, Curve curve) {
    System.out.println("Drawing a curve " + curve + " using a " + tool);
    tool.draw(curve);
}

Во многих случаях важнее знать, что может делать объект, а не как он делает то, что он делает. Это причина, по которой интерфейсы 
обычно используются для объявления типа переменной.

Интерфейс можно рассматривать как особый вид класса, объект которого не может быть создан (похож на абстрактный класс). Чтобы объявить 
интерфейс, вы должны написать ключевое слово interface вместо class перед именем интерфейса:

interface Interface { }

Интерфейс может содержать:
- public константы;
- абстрактные методы без реализации (ключевое слово abstract здесь не требуется);
- default методы с реализацией (требуется ключевое слово default);
- static методы с реализацией (требуется ключевое слово static);
- private методы с реализацией.

Если модификаторы не указаны после объявления метода в интерфейсе, его параметры по умолчанию будут общедоступными.

Интерфейс не может содержать полей (только константы), конструкторов или непубличных абстрактных методов. Давайте объявим интерфейс, 
содержащий все возможные элементы:

interface Interface {
        
    int INT_CONSTANT = 0; // it's a constant, the same as public static final int INT_FIELD = 0
        
    void instanceMethod1();
        
    void instanceMethod2();
        
    static void staticMethod() {
        System.out.println("Interface: static method");
    }
        
    default void defaultMethod() {
        System.out.println("Interface: default method. It can be overridden");
    }

    private void privateMethod() {
        System.out.println("Interface: private methods in interfaces are acceptable but should have a body");
    }
}

static , default и private методы должны иметь реализацию(тело метода) в интерфейсе!

Давайте подробнее рассмотрим этот интерфейс. Переменная INT_CONSTANT здесь не является полем – это static final константа. 
Два метода instanceMethod1() и instanceMethod2() являются абстрактными методами. staticMethod () - это обычный статический метод. 
Метод defaultMethod() default метод, который имеет реализацию, он может быть переопределен в подклассах. privateMethod также имеет 
реализацию и может использоваться для декомпозиции default методов.

Класс может имплементировать интерфейс, используя ключевое слово implements. Мы должны реализовать все абстрактных методы интерфейса
в классе, который имплементирует интерфейс.

Давайте реализуем интерфейс, который мы рассматривали ранее:

class Class implements Interface {

    @Override
    public void instanceMethod1() {
        System.out.println("Class: instance method1");
    }

    @Override
    public void instanceMethod2() {
        System.out.println("Class: instance method2");
    }
}

Теперь мы можем создать экземпляр класса и вызвать его методы:

Interface instance = new Class();

instance.instanceMethod1(); // it prints "Class: instance method1"
instance.instanceMethod2(); // it prints "Class: instance method2"
instance.defaultMethod();   // it prints "Interface: default method. It can be overridden"

Одной из важных особенностей интерфейса является множественное наследование.

Класс может реализовывать несколько интерфейсов:

interface A { }
interface B { }
interface C { }
    
class D implements A, B, C { }

Интерфейс может расширять один или несколько других интерфейсов с помощью ключевого слова extends:

interface A { }
interface B { }
interface C { }

interface E extends A, B, C { }

Класс также может расширять другой класс и реализовывать несколько интерфейсов:

class A { }

interface B { }
interface C { }
    
class D extends A implements B, C { }

Множественное наследование интерфейсов часто используется в стандартной библиотеке классов Java. 
Например, класс String реализует сразу три интерфейса:

public final class String 
    implements java.io.Serializable, Comparable<String>, CharSequence {
// ...
}

В некоторых ситуациях интерфейс может вообще не иметь членов. Такие интерфейсы называются 
marker или tagged interfaces. Например, хорошо известный интерфейс Serializable является 
marker интерфейсом:

public interface Serializable {
 
}

Other examples of marker interfaces are Cloneable, Remote, etc. They are used to provide 
essential information to the JVM.

Вы можете объявить и реализовать статический метод в интерфейсе

interface Car {
    static float convertToMilesPerHour(float kmh) {
        return 0.62 * kmh;
    }
}

Чтобы использовать статический метод, вам просто нужно вызвать его непосредственно из интерфейса

Car.convertToMilesPerHour(4.5);

Основной целью статических методов интерфейса является определение функциональности утилиты, 
которая является общей для всех классов, реализующих интерфейс. Они помогают избежать 
дублирования кода и создания дополнительных служебных классов.

Итог:
Интерфейс-это особый вид класса, объект которого не может быть создан. Основная идея интерфейса - 
объявление функциональности. Интерфейсы помогают абстрагироваться от конкретных классов и 
подчеркивают функциональность. Это делает дизайн программного обеспечения более многоразовым и 
чистым. Это хорошая практика для проектирования классов с использованием интерфейсов вместо 
дополнительных служебных классов. Для реализации интерфейса используется ключевое слово implements. 
В отличие от класса, интерфейс может расширять несколько интерфейсов. Класс может реализовывать 
несколько интерфейсов.

=================================================Default methods(in Interface)=====================================================
Как вы, вероятно, помните, методы интерфейса по умолчанию абстрактны. Это означает, что у них не может быть тела, вместо этого они 
просто объявляютcя. Тем не менее, некоторые методы могут иметь тело. Такие методы называются default и доступны начиная с Java 8.

default методы противоположны абстрактным. У них есть реализация:

interface Feature {
    default void action() {
        System.out.println("Default action");
    }
}

Для обозначения этого метода как default зарезервировано ключевое слово default. Помните, что метод интерфейса по умолчанию 
рассматривается как абстрактный. Поэтому вам нужно указать это явно, поставив ключевое слово default перед методами с телом, иначе 
произойдет ошибка компиляции.

Хотя default методы реализованы, вы не можете вызывать их непосредственно из интерфейса, как Feature.action(). Вам все еще нужно 
иметь объект класса, который реализует интерфейс:

class FeatureImpl implements Feature {
}
...

Feature feature = new FeatureImpl();
feature.action(); // Default action

Если вы хотите изменить default метод в классе, просто переопределите его, как обычный метод:

class FeatureImpl implements Feature {
    public void action() {
        System.out.println("FeatureImpl specific action");
    }
}
...

Feature feature = new FeatureImpl();
feature.action(); // FeatureImpl-specific action

Иногда default методы огромны. Чтобы сделать возможным декомпозицию таких методов, Java позволяет объявлять private методы внутри интерфейса:

interface Feature {
    default void action() {
        String answer = subAction();
        System.out.println(answer);
    }

    private String subAction() {
        return "Default action";
    }
}

Как уже упоминалось в разделе Интерфейса, основная идея интерфейса-объявление функциональности. default Методы расширяют эту идею. 
Они не только объявляют функциональность, но и реализуют ее. Основная причина-поддержка обратной совместимости. Давайте рассмотрим пример.

Предположим, вы программируете игру, в которой есть несколько типов персонажей. Эти персонажи могут перемещаться по карте. Это представлено 
Movable интерфейсом:

interface Movable {
    void stepAhead();
    void turnLeft();
    void turnRight();
}

Таким образом, у нас есть интерфейс и множество классов, которые его реализуют. Например, персонаж Batman:

class Batman implements Movable {
    public void stepAhead() {...}
    public void turnLeft() {...}
    public void turnRight() {...}
}

Как только вы решите, что персонажи должны иметь возможность развернуться. Это означает, что вам нужно добавить метод turnAround
к интерфейсу Movable. Вы можете реализовать этот метод для всех классов, реализующих интерфейс. Другим способом является объявление 
default метода в интерфейсе. Тогда вам не нужно реализовывать его во всех классах.

Другой пример, когда ситуация становится еще хуже, - это когда мы говорим об интерфейсах, которые являются частью стандартной библиотеки Java. 
Предположим, что разработчики Java решили расширить обычно используемый интерфейс с помощью нового метода в следующем выпуске. Это означает, 
что если вы собираетесь обновить версию Java и в вашем коде есть классы, реализующие интерфейс, вы должны реализовать новый метод. В противном 
случае ваш код не будет компилироваться.

Иногда default методы помогают избежать дублирования кода. Действительно, в нашем случае метод turnAround может выглядеть одинаково для всех классов.

interface Movable {
    void stepAhead();
    void turnLeft();
    void turnRight();

    default void turnAround() {
        turnLeft();
        turnLeft();
    }
}

Если вы хотите изменить default метод для Batman, просто переопределите его:

class Batman implements Movable {
    public void stepAhead() {...}
    public void turnLeft() {...}
    public void turnRight() {...}
    public void turnAround() {
        turnRight();
        turnRight();
    }
}

Предположим, что у нас есть еще один интерфейс Jumpable, который представляет собой возможность прыгать. Интерфейс содержит 
абстрактные методы для прыжков на месте, прыжков с поворотом влево и вправо. Он также имеет default метод для разворотоа
в прыжке с тем же названием, что и в интерфейсе Movable.

interface Jumpable {
    void jump();
    void turnLeftJump();
    void turnRightJump();
    default void turnAround() {
        turnLeftJump();
        turnLeftJump();
    }
}

Spiderman реализует интерфейс Movable и Jumpable. Обратите внимание, что интерфейсы имеют default метод turnAround,
с одним названием но с разными реализациями. Какой из них следует выбрать? Чтобы избежать двусмысленности, компилятор 
вызывает ошибку компиляции.

class Spiderman implements Movable, Jumpable {
    // define an implementation for abstract methods
    public void stepAhead() {...}
    public void turnLeft() {...}
    public void turnRight() {...}
    public void jump() {…}
    public void turnLeftJump() {...}
    public void turnRightJump() {...}

    // define an implementation for conflicted default method
    public void turnAround() {
        // define turnaround for the spiderman
    }
}

Вы также можете выбрать одну из реализаций по умолчанию вместо написания собственной.

class Spiderman implements Movable, Jumpable {
    ...
    public void turnAround() {
        Movable.super.turnAround();
    }
}

The problem is known as the diamond problem.



==================================================Abstract class vs interface======================================================
Абстрактный класс и интерфейс-это инструменты для достижения абстракции, которые позволяют нам объявлять абстрактные методы. 
Мы не можем создавать экземпляры абстрактных классов и интерфейсов напрямую, мы можем делать это только через классы, которые их 
наследуют.

Начиная с Java 8, интерфейс может иметь default и статические методы, содержащие тело. Это делает интерфейс более похожим на 
абстрактный класс. Итак, важный вопрос: в чем разница между интерфейсами и абстрактными классами?

1) абстрактный класс может иметь абстрактные и неабстрактные методы экземпляра, в то время как интерфейс может иметь абстрактные 
методы экземпляра или default методы экземпляра;
2) абстрактный класс может расширять другой абстрактный или обычный класс, а интерфейс может расширять только другой интерфейс;
3) абстрактный класс может расширять только один класс, в то время как интерфейс может расширять любое количество интерфейсов;
4) абстрактный класс может иметь final, non-final, static, non-static variables (обычные поля), в то время как интерфейс может 
иметь только static final variables;
5) абстрактный класс может обеспечить реализацию интерфейса, но интерфейс не может обеспечить реализацию абстрактного класса;
6) абстрактный класс может иметь конструктор, а интерфейс-нет;
7) в абстрактном классе ключевое слово abstract является обязательным для объявления метода как абстрактного, в то время как в 
интерфейсе это ключевое слово является необязательным.

Помните, что класс расширяет другой класс, класс реализует интерфейс, но интерфейс расширяет другой интерфейс.

Как правило, интерфейсы используются для отделения интерфейса компонента (класса) от реализации, в то время как абстрактные 
классы часто используются в качестве базовых классов с общими полями, которые должны быть расширены подклассами.

Иногда интерфейсы и абстрактные классы используются вместе, чтобы сделать иерархию классов более гибкой. В этом случае абстрактный 
класс содержит общие члены и реализует один или несколько интерфейсов, а конкретные классы расширяют абстрактный класс и, возможно, 
реализуют другие интерфейсы.

interface ManagedDevice {

    void on();

    void off();
}

abstract class AbstractDevice implements ManagedDevice {

    protected String serialNumber;
    protected boolean on;
    
    public AbstractDevice(String serialNumber) {
        this.serialNumber = serialNumber;
    }

    protected void setOn(boolean on) {
        this.on = on;
    }
}

class Kettle extends AbstractDevice {

    protected double volume;

    public Kettle(String serialNumber, double volume) {
        super(serialNumber);
        this.volume = volume;
    }

    @Override
    public void on() {
        // do complex logic to activate all electronic components
        setOn(true);
    }

    @Override
    public void off() {
        // do complex logic to stop all electronic components
        setOn(false);
    }
}

Использование обеих концепций (интерфейсов и абстрактных классов) делает ваш код более гибким. Используйте подходящие 
абстракции или их комбинации при проектировании иерархий классов.

В качестве примера вы можете увидеть иерархии классов в стандартной библиотеке классов Java. Примером этого является 
иерархия коллекций. Он объединяет абстрактные классы и интерфейсы, чтобы сделать иерархию более поддерживаемой и гибкой 
для использования в вашем коде.

========================================================The Object class===========================================================
Стандартная библиотека Java имеет класс с именем Object, который по умолчанию является родительским для всех стандартных классов и 
пользовательских классов. Каждый класс расширяет этот класс неявно, поэтому он является прородителем в программах Java. Класс 
принадлежит пакету java.lang, который импортируется по умолчанию.

Давайте создадим экземпляр класса Object.

Object anObject = new Object();

Класс Object может ссылаться на экземпляр любого класса, поскольку любой экземпляр является своего рода Object (upcasting).

Long number = 1_000_000L;
Object obj1 = number; // an instance of Long can be cast to Object

String str = "str";
Object obj2 = str; // the same with the instance of String

Когда мы объявляем класс, мы можем явно расширить класс Object. Однако в этом нет смысла, так как это уже сделано неявно. 
Мы советуем вам не писать лишний код, но вот пример, на всякий случай:

class A extends Object { }

В ваших собственных решениях достаточно вместо этого написать класс A {}.

Класс Object предоставляет некоторые общие методы для всех подклассов. Он имеет девять методов экземпляра (исключая перегруженные методы), 
которые можно разделить на четыре группы:

threads synchronization: wait, notify, notifyAll;
object identity: hashCode, equals;
object management: finalize, clone, getClass;
human-readable representation: toString;

Первая группа методов (wait, notify, notifyAll) предназначена для работы в многопоточных приложениях.
Метод hashCode возвращает значение хэш-кода для объекта
Метод equals указывает, является ли какой-либо другой объект "равным" этому конкретному объекту.
Метод finalize вызывается garbage collectorом(GC) для объекта, когда GC хочет его удалить. (Примечание: этот метод устарел с JDK 9).
Метод clone создает и возвращает копию объекта.
Метод getClass возвращает экземпляр класса, который содержит информацию о выполняемом классе
Метод toString возвращает строковое представление объекта.

Некоторые из перечисленных выше методов являются native, что означает, что они реализованы в "native" коде. 
Обычно он написан на C или C++. Native методы обычно используются для взаимодействия с системными вызовами или библиотеками, 
написанными на других языках программирования.

==========================================================Метод toString()=========================================================
Класс Object имеет метод toString() для получения строкового представления объекта. Если вы хотите иметь строковое представление, 
переопределите этот метод в своем классе.

Во-первых, давайте рассмотрим пример, основанный на реализации toString() по умолчанию, предоставляемой классом Object.

Это класс Account. Он имеет три поля и один конструктор.

class Account {

    private long id;
    private String code;
    private Long balance;

    public Account(long id, String code, Long balance) {
        this.id = id;
        this.code = code;
        this.balance = balance;
    }
    
    // getters and setters
}

Давайте создадим экземпляр класса и получим строковое представление этого экземпляра:

Account account = new Account(1121, "111-123", 400_000L);

String accString = account.toString(); // org.demo.example.Account@27082746

Строка типа org.demo.example.Account@27082746 - это не совсем то, что мы хотели бы видеть. То, что мы получили здесь, - это полное 
имя класса и хэш-код объекта. Это поведение метода toString () по умолчанию

Если мы хотим включить поля в строковое представление объекта, мы должны переопределить стандартное поведение метода toString().

Вот еще одна версия класса Account, в которой мы переопределили метод toString() :

class Account {

    private long id;
    private String code;
    private Long balance;

    public Account(long id, String code, Long balance) {
        this.id = id;
        this.code = code;
        this.balance = balance;
    }
    
    // getters and setters

    @Override
    public String toString() {
        return "Account{id=" + id + ",code=" + code + ",balance=" + balance + "}";
    }
}

Давайте создадим экземпляр этого класса и получим строковое представление экземпляра:

Account account = new Account(1121, "111-123", 400_000L);

String accString = account.toString(); // Account{id=1121,code=111-123,balance=400000}

По сравнению со строковым представлением по умолчанию, это дает нам больше информации об объекте и его атрибутах.

Строковые представления очень полезны для отладки и ведения логов. Вы можете использовать метод toString() для 
отображения строкового представления объекта в стандартном выводе:

// option 1
System.out.println(account.toString());

// option 2
System.out.println(account);

Если у вас есть иерархия классов, вы также можете переопределить toString().

Вот иерархия из двух классов:

- Person with a single string field name;
- Employee that extends Person and adds the field salary.

class Person {

    protected String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person{name=" + name + "}";
    }
}

class Employee extends Person {

    protected long salary;

    public Employee(String name, long salary) {
        super(name);
        this.salary = salary;
    }

    @Override
    public String toString() {
        return "Employee{name=" + name + ",salary=" + salary + "}";
    }
}

Считается хорошей практикой включать имя класса в строковое представление при работе с иерархиями.

Давайте создадим объекты этих двух классов и напечатаем их в виде строк:

Person person = new Person("Helena");
Employee employee = new Employee("Michael", 10_000);

System.out.println(person);   // Person{name=Helena}
System.out.println(employee); // Employee{name=Michael,salary=10000}

Переопределение метода toString() до сих пор выглядит очень просто, но что, если в вашем классе есть 
другой класс в качестве типа поля? Иногда это может привести к ошибке.

См. Следующий пример с классами Person и Passport. Мы не включаем геттеры и сеттеры в код, чтобы 
сделать его более компактным.

class Person {

    private String name;
    private Passport passport;
    
    // getters and setters
    
    @Override
    public String toString() {
        return "Person{name='" + name + ",passport=" + passport + "}";
    }
}

class Passport {
    
    private String country;
    private String number;
    
    // getters and setters

    @Override
    public String toString() {
        return "Passport{country=" + country + ",number=" + number + "}";
    }
}

Если у человека нет паспорта (null), строковое представление будет содержать null.

Вот пример двух объектов.

Passport passport = new Passport();
passport.setNumber("4343999");
passport.setCountry("Austria");

Person person = new Person();
person.setName("Michael");
System.out.println(person);  // first print

person.setPassport(passport);
System.out.println(person);  // second print

This code prints:

Person{name=Michael,passport=null} // first print
Person{name=Michael, passport=Passport{country=Austria, number=4343999}} // second print

Он работает очень хорошо, здесь нет проблем! Но что, если паспорт имеет обратную ссылку на человека и 
пытается получить строковое представление этого человека?

Давайте добавим следующее поле и соответствующий сеттер в класс Passport:

private Person owner;

Давайте также изменим метод toString() следующим образом:

public String toString() {
    return "Passport{country=" + country + ",number=" + number + ",owner=" + owner + "}";
}

Когда мы создаем два объекта, давайте установим владельца паспорта:

passport.setOwner(person);

Теперь мы получаем большую проблему — программа пытается получить строковое представление человека, 
которое включает в себя строковое представление паспорта, которое включает в себя строковое представление 
человека. Это вызывает java.lang.StackOverflowError.

Есть несколько способов исправить эту ситуацию:

- не включайте поля, представленные вашими классами, в метод toString() ;
- исключите поле в методе toString() из одного из классов.

Поэтому будьте осторожны при включении полей в метод toString. Если вам не нужна никакая информация, лучше исключить ее. 
Это избавит вас от фатальных ошибок в долгосрочной перспективе.


======================================================hashCode() and equals()======================================================
Иногда вам нужно сравнить объекты вашего пользовательского класса друг с другом. java.lang.Object, который является суперклассом любого 
класса, предоставляет для этого два метода: equals(Object obj) и hashCode(). Их поведение по умолчанию выглядит следующим образом:

boolean equals(Object obj) проверяет, хранятся ли этот объект и другой объект в одном и том же адресе памяти;

int hashCode() возвращает целочисленный хэш-код, уникальный для каждого объекта (идентификатор объекта).

Давайте посмотрим, как они себя ведут. Вот простой класс Person с тремя полями:

class Person {

    private String firstName;
    private String lastName;
    private int age;

    // constructor, getters and setters
}

Есть два объекта, которые представляют одного и того же человека (т. Е. Объекты логически эквивалентны):

Person p1 = new Person("John", "Smith", 31);
Person p2 = new Person("John", "Smith", 31);

Однако метод equals считает их разными, поскольку он сравнивает ссылки, а не значения их полей:

System.out.println(p1.equals(p2)); // false

Метод hashCode также ничего не говорит об их равенстве:

System.out.println(p1.hashCode()); // 242131142
System.out.println(p2.hashCode()); // 1782113663

Таким образом, поведение по умолчанию методов equals(Object obj) и hashCode() недостаточно для сравнения 
объектов пользовательского класса по значениям их полей.

Интересно, как эти методы ведут себя со стандартными классами, например, String :

String person1 = new String("John Smith");
String person2 = new String("John Smith");

System.out.println(person1.equals(person2)); // true

System.out.println(person1.hashCode()); // 2314539
System.out.println(person2.hashCode()); // 2314539

Если мы хотим определить аналогичную логику для сравнения в классе Person, мы должны переопределить оба описанных метода. 
Недостаточно просто переопределить только один из них.

Чтобы проверить логическое равенство объектов, мы должны переопределить метод equals нашего класса. Это не так просто, как может показаться.

Существуют некоторые математические ограничения, накладываемые на поведение equals, которые перечислены в документации по классу Object.

1) Рефлексивность(Reflexivity): для любого ненулевого ссылочного значения x, x.equals(x) должно возвращать true.
2) Симметрия(Symmetry): для любых ненулевых ссылочных значений x и y x.equals(y) должен возвращать true тогда и только тогда, когда 
y.equals(x) возвращает true.
3) Транзитивность(Transitivity): для любых ненулевых ссылочных значений x, y и z, если x.equals(y) возвращает true, а y.equals(z) возвращает true, 
то x.equals(z) должен возвращать true.
4) Согласованность(Consistency): для любых ненулевых ссылочных значений x и y многократные вызовы x.equals(y) последовательно возвращают true или 
последовательно возвращают false, при условии, что никакая информация, используемая в сравнениях equals для объектов, не изменяется.
5) Ненулевое значение: для любого ненулевого ссылочного значения x, x.equals(null) должно возвращать false.

Чтобы создать метод, удовлетворяющий перечисленным ограничениям, сначала необходимо выбрать поле, которое вы хотите сравнить. Затем вы должны 
выполнить три теста внутри метода equals:

1) если этот и другой объекты имеют одинаковую ссылку, объекты равны, в противном случае — перейдите к шагу 2;
2) если другой объект равен null или имеет неподходящий тип, объекты не равны, в противном случае — перейдите к шагу 3;
3) если все выбранные поля равны, объекты равны, в противном случае они не равны.

Вот модифицированный класс Person, который переопределяет метод equals. Он использует все три поля для сравнения.

class Person {

    private String firstName;
    private String lastName;
    private int age;

    // constructor, getters and setters

    @Override
    public boolean equals(Object other) {
        /* Check this and other refer to the same object */
        if (this == other) {
            return true;
        }

        /* Check other is Person and not null */
        if (!(other instanceof Person)) {
            return false;
        }

        Person person = (Person) other;

        /* Compare all required fields */
        return age == person.age && 
                Objects.equals(firstName, person.firstName) &&
                Objects.equals(lastName, person.lastName);
    }
}

В приведенном выше примере мы используем java.util.Objects.equals(obj1, obj2), чтобы проверить, равны ли строковые поля. 
Этот подход позволяет нам избежать исключения NullPointerException.

Ниже приведен пример, в котором мы проверяем три объекта на равенство. Два объекта представляют одного и того же человека.

Person p1 = new Person("John", "Smith", 31); // a person
Person p2 = new Person("John", "Smith", 31); // the same person
Person p3 = new Person("Marry", "Smith", 30); // another person

System.out.println(p1.equals(p2)); // true
System.out.println(p2.equals(p3)); // false
System.out.println(p3.equals(p3)); // true (reflexivity)

Как видите, теперь метод equals сравнивает два объекта и возвращает true, если их поля равны, в противном случае — false.

Если вы переопределяете equals, хорошей практикой также является переопределение hashCode(). В противном случае ваш класс не может 
быть правильно использован в любой коллекции, которая применяет механизм хеширования (например, HashMap, HashSet или HashTable).

Ниже приведены три требования к методу hashCode():

1) Всякий раз, когда он вызывается на одном и том же объекте более одного раза во время выполнения приложения Java, метод hashCode 
должен последовательно возвращать одно и то же целое число, при условии, что информация, используемая в сравнениях equals для объекта, 
не изменяется. Это целое число не должно изменяться от одного выполнения приложения к другому.

person1.hashCode(); // 400000 - ok
person1.hashCode(); // 400000 - ok
person1.hashCode(); // 500000 - not ok

2) Если два объекта равны в соответствии с методом equals(Object), то вызов метода hashCode для каждого из двух объектов должен привести 
к одному и тому же целочисленному результату.

person1.equals(person2); // true
person1.hashCode() == person2.hashCode(); // false - not ok, it must be true

3) Для неравных объектов не требуется создавать уникальные хэш-коды. Однако программист должен знать, что получение различных целочисленных 
результатов для неравных объектов может повысить производительность хэш-таблиц.

person1.equals(person3); // false
person1.hashCode() == person3.hashCode(); // true - will work

Простейшая реализация метода hashCode() может выглядеть следующим образом:

@Override
public int hashCode() {
    return 42;
}

Он всегда возвращает одно и то же значение и удовлетворяет обоим необходимым условиям 1 и 2, но не удовлетворяет необязательному условию 3. 
К сожалению, этот метод очень неэффективен для промышленного программирования, так как он полностью снижает мощность коллекций на основе хэша. 
Хорошая хэш - функция имеет тенденцию генерировать разные хэш-коды для неодинаковых объектов.

Для разработки корректного и эффективного метода хэш-кода мы рекомендуем алгоритм, предложенный Джошуа Блохом в его книге "Эффективная Java".

1) Создайте результат int и назначьте ненулевое значение (т. е. 17).
2) Для каждого поля f, проверенного в методе equals (), вычислите код хэш-кода:
- Вычислите целочисленный хэш - код для f
Если поле f является boolean: вычислить (f ? 0 : 1);
Если поле f является byte, char, short или int: вычислить (int) f;
Если поле f является long: вычислить (int)(f ^ (f >>> 32));
Если поле f является float: вычислите Float.floatToIntBits(f);
Если поле f является double: вычислите Double.doubleToLongBits(f) и обрабатывать возвращаемое значение, как и любое long значение;
Если поле f является объектом: используйте результат метода hashCode() или 0, если f == null;
Если поле f является массивом: рассматривайте каждое поле как отдельный элемент и вычисляйте значение хэша рекурсивным способом. 
Затем объедините значения, как описано выше.
- Объедините хэш-значение code с result следующим образом: result = 31 * result + code;
3) Верните result в виде хэш - кода объекта.

Здесь мы применяем описанный алгоритм к классу Person.

class Person {

    private String firstName;
    private String lastName;
    private int age;

    // constructor, getters and setters

    // overridden equals method

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + (firstName == null ? 0 : firstName.hashCode());
        result = 31 * result + (lastName == null ? 0 : lastName.hashCode());
        result = 31 * result + age;
        return result;
    }
}

Ниже вы можете увидеть пример вызова hashCode() для трех объектов. Два объекта представляют одного и того же человека.

Person p1 = new Person("John", "Smith", 31);  // a person
Person p2 = new Person("John", "Smith", 31);  // the same person
Person p3 = new Person("Marry", "Smith", 30); // another person

System.out.println(p1.hashCode()); // 409937238
System.out.println(p2.hashCode()); // 409937238
System.out.println(p3.hashCode()); // 689793455

Как вы можете видеть, у нас один и тот же хэш-код для одинаковых объектов.

Обратите внимание, что начиная с Java 7, у нас есть java.util.Objects.hash(Object... values) метод для хэширования 
Objects.hash(firstName, secondName, age). Он скрывает все магические константы и нулевые проверки внутри.
	


========================================================enum(enumeration)==========================================================
Когда переменная может принимать только одно из небольшого набора возможных значений, рекомендуется использовать перечисления в 
программе. Enum-это специальное ключевое слово, сокращенное от enumeration, которое позволяет нам создать список констант, 
сгруппированных по их содержанию: сезоны, цвета,состояния и т. д. Когда мы храним кучу констант в одном месте и обрабатываем их 
вместе, это помогает нам избежать ошибок и делает код более читаемым и понятным.

Мы можем создать собственное перечисление точно так же, как обычно объявляем класс. Согласно Соглашению о коде Java, константы в 
перечислении записываются в верхнем регистре. Все константы должны быть разделены запятыми. Взгляните на пример enum Season:
public enum Season {
    SPRING, SUMMER, AUTUMN, WINTER // four instances
}
Можно объявить перечисление внутри класса. В этом случае нам не нужно использовать модификатор public в объявлении enum.

Предположим, что мы должны написать программу с перечислением, которое отображает три возможных состояния пользователя. Давайте 
создадим enum UserStatus с этими статусами:
public enum UserStatus {
    PENDING, ACTIVE, BLOCKED
}

А теперь мы инициализируем переменную типа UserStatus из предыдущего примера:
UserStatus active = UserStatus.ACTIVE;

Каждое значение enum имеет имя, доступ к которому можно получить с помощью имени метода():
System.out.println(active.name()); // ACTIVE

Иногда нам может понадобиться получить доступ к экземпляру enum по его имени. Это можно сделать с помощью метода valueOf(). 
Вот еще один способ инициализации переменной:
UserStatus blocked = UserStatus.valueOf("BLOCKED"); // BLOCKED
Важно помнить, что этот метод чувствителен к регистру. Это означает, что если данная строка точно не соответствует какой-либо 
константе, мы получим исключение IllegalArgumentException.
UserStatus blocked = UserStatus.valueOf("blocked"); // IllegalArgumentException, valueOf is case-sensitive

Если мы хотим посмотреть на все константы enum, мы можем получить их в массиве с помощью метода values():
UserStatus[] statuses = UserStatus.values(); // [PENDING, ACTIVE, BLOCKED]

Другой метод ordinal() возвращает порядковое положение экземпляра среди перечислений
System.out.println(pending.ordinal()); // 0 (starting with 0)
System.out.println(UserStatus.BLOCKED.ordinal()); // 2

Хотя перечисление является ссылочным типом, две переменные могут быть правильно сопоставлены с помощью метода equals и оператора ==.
System.out.println(active.equals(UserStatus.ACTIVE)); // true
System.out.println(active == UserStatus.ACTIVE); // true

Перечисление может быть успешно использовано в операторе switch. В зависимости от состояния наша программа может выполнять 
различные действия, указанные оператором switch. В этом случае он печатает разные ответы:
UserStatus status = ... // some status
 
switch (status) {
    case PENDING:
        System.out.println("You need to wait a little.");
        break;
    case ACTIVE:
        System.out.println("No problems, you may pass here.");
        break;
    case BLOCKED:
        System.out.println("Stop! You can't pass here.");
        break;
    default:
        System.out.println("Unsupported enum constant.");
}

Один из лучших способов перебора перечислений - использовать цикл for или for-each. Давайте применим его к нашему образцу 
перечисления:
for (UserStatus status : UserStatus.values()) {
        System.out.println(status);
    }
/* the output is 
ACTIVE
PENDING
BLOCKED
*/
Здесь мы использовали метод values() для возврата массива значений перечисления. Этот цикл очень удобен при переборе перечислений 
с большим количеством констант.

Пример:

enum DayOfWeek {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}

public class Main {
    public static void main(String[] args) {
        for (DayOfWeek day : DayOfWeek.values()) {
            System.out.println(day);
        }
    }
}

=====================================================Поля и методы в ENUM==========================================================
Мы используем enum для определения набора неизменяемых переменных. После того, как мы определили их, нам может потребоваться 
расширить функциональность enum и добавить значения к константам. Как и класс, enum может иметь поля, конструкторы и методы. Эта 
функция делает enum мощным инструментом для работы со значениями, которые вы не собираетесь изменять.

Предположим, мы должны написать программу, которая отображает уровень заряда батареи смартфона, банка питания или любого устройства 
с дискретной шкалой.
Прежде всего, давайте создадим enum с несколькими пороговыми уровнями, которые представляют собой уровень заряда батареи:

public enum ChargeLevel {
    FULL, HIGH, MEDIUM, LOW
}

Предположим, что нам нужно визуально отобразить уровень заряда батареи. Мы хотим, чтобы он был разделен на несколько сегментов и 
имел цветовую индикацию, таким образом:
Для этого мы добавим соответствующие поля и значения в наш enum. Когда мы определяем их, мы должны предоставить значения 
конструктору enum. Здесь мы создали конструктор в перечислении ChargeLevel и добавили два поля sections и color. Кроме того, 
есть два метода getSections() и getColor (), которые возвращают значения полей соответственно.

public enum ChargeLevel {

    FULL(4, "green"),
    HIGH(3, "green"),
    MEDIUM(2, "yellow"),
    LOW(1, "red");

    int sections;
    String color;

    ChargeLevel(int sections, String color) {
        this.sections = sections;
        this.color = color;
    }

    public int getSections() {
        return sections;
    }

    public String getColor() {
        return color;
    }
}

Обратите внимание, что все эти экземпляры создаются JVM таким же образом, как и static поле класса. Именно по этой причине 
enum не может содержать public конструктор. Это означает, что мы не можем создавать объекты enum, вызывая конструктор enum по 
ключевому слову new, но вместо этого должны выбрать один из предопределенных экземпляров.

Имейте в виду, что если ваш enum содержит поля и методы, вы всегда должны определять их после списка констант в enum.

Теперь у нас есть класс с дополнительной информацией, собранной в одном месте: количество разделов для выделения и цвета.
System.out.println(ChargeLevel.LOW.sections); // 1
System.out.println(ChargeLevel.LOW.color); // red

Можно расширить enum, добавив пользовательские статические методы. Например, давайте добавим метод, который находит экземпляр 
ChargeLevel по заданному количеству секций:

public enum ChargeLevel {

    FULL(4, "green"),
    HIGH(3, "green"),
    MEDIUM(2, "yellow"),
    LOW(1, "red");

    int sections;
    String color;

    ChargeLevel(int sections, String color) {
        this.sections = sections;
        this.color = color;
    }

    public int getSections() {
        return sections;
    }

    public String getColor() {
        return color;
    }

    public static ChargeLevel findByNumberOfSections(int sections) {
        for (ChargeLevel value: values()) {
            if (value.sections == sections) {
                return value;
            }
        }
        return null;
    }
}

Внутри метода findByNumberOfSections() мы перебирали возможные значения, используя цикл for-each. Вот пример вывода нашего метода:
System.out.println(ChargeLevel.findByNumberOfSections(2)); // MEDIUM

Пример:
import java.util.Scanner;

public class Main {

    /**
     * The method change the balance of the given account according to an operation.
     * @param account
     * @param operation
     * @return true if the balance has changed, otherwise - false.
     */
    public static boolean changeBalance(Account account, Operation operation, Long sum) {
        if (operation == Operation.DEPOSIT) {
            account.setBalance(account.getBalance() + sum);
            return true;
        } else {
            if (account.getBalance() < sum) {
                System.out.println("Not enough money to withdraw.");
                return false;
            } else {
                account.setBalance(account.getBalance() - sum);
                return true;
            }
        }
    }

    /* Do not change code below */
    enum Operation {
        /**
         * deposit (add) an amount into an Account
         */
        DEPOSIT,
        /**
         * withdraw (subtract) an amount from an Account
         */
        WITHDRAW
    }

    static class Account {

        private String code;
        private Long balance;

        public String getCode() {
            return code;
        }

        public Long getBalance() {
            return balance;
        }

        public void setBalance(Long balance) {
            this.balance = balance;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String[] parts = scanner.nextLine().split("\\s+");

        Account account = new Account();
        account.setBalance(Long.parseLong(parts[0]));

        Operation operation = Operation.valueOf(parts[1]);

        Long sum = Long.parseLong(parts[2]);

        if (changeBalance(account, operation, sum)) {
            System.out.println(account.getBalance());
        }
    }
}

============================================================Package================================================================
Пакеты имеют много преимуществ:
1) Группируйте связанные классы вместе, чтобы легче было выяснить, где находится определенный класс
2) Избегать конфликта имен классов
3) Контролировать доступ к классам и членам вместе с модификаторами доступа

Согласно соглашению об именах, имена пакетов всегда пишутся в нижнем регистре, например:
model
collection
utils

Вы можете вывести полное имя класса, используя следующий код:
System.out.println(User.class.getName()); // org.company.webapp.data.User

Классы, объявленные внутри пакета, имеют специальное ключевое слово package в верхней части файла.
package org.company.webapp.data;
public class User {
}

Когда вы используете внешние библиотеки, два класса могут иметь одно и то же имя. Пакеты позволяют избежать конфликта имен классов,
потому что полное имя класса включает имя пакета. Таким образом, даже если два класса из разных пакетов имеют одинаковое имя, их 
полные имена будут разными. Это, конечно, если бы не было конфликтов между именами пакетов.

Чтобы избежать создания пакетов с такими же именами, как у других общедоступных пакетов, обычно рекомендуется начинать иерархию 
пакетов с обратного доменного имени вашей компании (или другой организации). Например:
org.company
org.hyperskill
net.labs

Если два класса расположены в одном пакете, использование одного класса внутри другого не проблема. Если это не так и классы 
находятся в разных пакетах, вам нужно написать оператор импорта, чтобы использовать один класс внутри другого. Оператор импорта 
определяется ключевым словом import.

Вот пример. У нас есть два публичных класса в разных пакетах:
org.hyperskill.java.packages.theory.p1.A
org.hyperskill.java.packages.theory.p2.B
Чтобы использовать класс B внутри класса A, мы должны использовать оператор import:

package org.hyperskill.java.packages.theory.p1;  // current package
import org.hyperskill.java.packages.theory.p2.B; // it's required to make the import

public class A {
    public static void method() {
        B b = new B();
    }
}

Объявление пакета и операторы импорта не являются обязательными. Если они оба присутствуют, пакет должен быть перед всем импортом! 
В противном случае мы получим ошибку компиляции.

Также можно импортировать все классы из пакета. Для этого нам нужно написать * в операторе импорта вместо имени конкретного класса.
Не делайте этого слишком часто. В некоторых случаях это считается плохой практикой и может нарушить совместимость вашей программы с
новыми версиями Java.
import org.hyperskill.java.packages.theory.p3.*; // import all classes from the package

Можно обойтись без оператора import, но тогда придётся какждый раз писать полный путь к классу:
java.util.Scanner scanner = new java.util.Scanner(System.in);
java.util.Date now = new java.util.Date();

Мы также можем импортировать статические члены (методы и поля) класса внутри другого класса. Если мы напишем * в операторе импорта, 
тогда нам не нужно будет записывать имя импортированного класса перед вызовом статических методов или чтением статических полей.

package org.hyperskill.java.packages.theory;
import static java.util.Arrays.*; // instead of the statement "import java.util.Arrays;"

public class Main {
    public static void main(String[] args) {
        int[] numbers = { 10, 4, 5, 47, 5, 12 }; // an array
        sort(numbers); // instead of writing Arrays.sort(...)
        int[] copy = copyOf(numbers, numbers.length); // instead of writing Arrays.copyOf(...)
    }
}

Если мы не напишем оператор пакета до определения нашего класса, он будет помещен в пакет по умолчанию. У этого пакета есть большой 
недостаток - расположенные здесь классы нельзя импортировать в классы, расположенные внутри именованных пакетов. Следующий класс 
нельзя использовать в классе, расположенном внутри пакетов, так как нет объявления пакета:

// no package declaration

public class Person {
    String firstName;
    String lastName;
}

===========================================================Конструктор=============================================================
Конструкторы - это специальные методы, которые инициализируют новый объект класса. Конструктор класса вызывается при создании 
экземпляра с помощью ключевого слова new. 

Конструктор отличается от других методов тем, что:
- он имеет то же имя, что и класс, который его содержит;
- он не имеет возвращаемого типа (даже void).

Вот класс Patient. Объект класса имеет имя, возраст и рост. Класс имеет конструктор с тремя аргументами для инициализации 
объектов с определенными значениями.

class Patient {
    String name;
    int age;
    float height;

    public Patient(String name, int age, float height) {
        this.name = name;
        this.age = age;
        this.height = height;
    }
}

Давайте пойдем дальше и создадим несколько экземпляров класса с помощью конструктора, который мы написали:
Patient patient1 = new Patient("Heinrich", 40, 182.0f);
Patient patient2 = new Patient("Mary", 33, 171.5f);

Компилятор автоматически предоставляет конструктор без аргументов по умолчанию для любого класса без конструкторов.
class Patient {
    String name;
    int age;
    float height;
}
Мы можем создать экземпляр класса Patient с помощью конструктора по умолчанию без аргументов:
Patient patient = new Patient();
В этом случае все поля будут заполнены значениями по умолчанию их типов.

Если вы создаёте определенный конструктор, конструктор по умолчанию не будет создан автоматически.
Мы также можем определить конструктор без каких-либо аргументов, но использовать его для установки значений по умолчанию для полей 
класса. Такие конструкторы без аргументов полезны в тех случаях, когда любое значение по умолчанию лучше, чем null. Например, мы 
можем инициализировать имя с помощью "Unknown":
class Patient {
    String name;
    int age;
    float height;

    public Patient() {
        this.name = "Unknown";
    }
}

=================================================Модификаторы доступа (Access modifiers)===========================================
Вы, вероятно, видели следующий фрагмент кода:
public static void main(String[] args) { 
    // some code goes here
}

Почему вообще существует слово "public"? Как вы, наверное, уже догадались, это означает, что main(...) метод доступен 
каждому. Слово public здесь является модификатором доступа.

Модификатор доступа-это специальное ключевое слово, которое указывает, кому разрешено использовать ваш код или его специальную 
часть. Он может быть помещен перед переменной, методом или целым классом.

Есть две основные причины взять доступ под контроль: ясность и безопасность кода.
1) Code clarity. Вот как помогает контроль доступа в коде – вы можете “скрыть” внутреннее устройство программы от 
пользователя, ограничив доступ, и просто предоставить ему общедоступные элементы управления.
2) Code safety. Запрет на изменение кода с помощью ограничения доступа к нему

default: (по умолчанию, без явного модификатора): виден только для классов из одного пакета;
public: видимый для всех классов повсюду.

Вот класс внутри пакета org.hyperskill.java.packages.theory.p1 c default package-private access:
package org.hyperskill.java.packages.theory.p1;
class PackagePrivateClass{ }

Этот класс может использоваться только другими классами из того же пакета. Он даже не виден для классов из любого другого 
пакета, включая:
org.hyperskill
org.hyperskill.java.packages.theory
default package

Вот публичный класс внутри пакета org.hyperskill.java.packages.theory.p2
package org.hyperskill.java.packages.theory.p2;
public class PublicClass {}

Этот класс не имеет ограничений доступа, он виден всем классам и может использоваться везде, включая:
org.hyperskill
org.hyperskill.java.packages.theory
org.hyperskill.java.packages.theory.p1
default package

Член класса (поле или метод, например конструктор класса) имеет больше вариантов на выбор: private, default, 
protected и public. Как вы можете видеть, здесь есть два дополнительных модификатора.
Поля часто объявляются закрытыми, чтобы контролировать доступ к ним из любого другого класса. В некоторых случаях эти поля 
используются только внутри класса, и нет никакого способа изменить их и даже получить доступ к ним из любого другого класса. 
В других случаях это можно сделать с помощью методов доступа (например, геттеров и сеттеров).

Пример класса Counter с private переменной current. Это поле может быть прочитано только с помощью метода getCurrent(), 
getter-метода, и изменено с помощью метода inc(). Последний метод не совсем является сеттером, потому что он не 
устанавливает вручную значение текущей переменной, а просто увеличивает его.
public class Counter {
   private long current = 0;
   public long getCurrent() {
       return current;
   }

   public long inc() {
       inc(1L);
       return current;
   }

   private void inc(long val) {
       current += val;
   }
}

Иногда требуется private конструктор класса. Этот тип конструктора может использоваться только внутри класса, например, из 
другого конструктора, который также может быть public или private, или из методов класса.

Модификатор доступа default не требует какого-либо ключевого слова. Если поле, метод или конструктор имеет этот модификатор, 
то он может быть прочитан или изменен из любого класса внутри того же пакета
Давайте рассмотрим пример. Вот два класса в одном пакете: Salary и Promotion
Класс Salary имеет модификатор доступа default и конструктор. Объект класса Salary может быть создан внутри метода 
Promotion, и поле также может быть доступно для объекта класс Promotion и его участников, поскольку они имеют один и тот же пакет.
public class Salary {
    long income;
    Salary(long income) {
        this.income = income;
    }
}

public class Promotion {
    Salary salary;
    Promotion(Salary salary) {
        this.salary = salary;
    }
    public void promote() {
        salary.income += 1500;
    }
}

Если член класса имеет модификатор доступа protected, то к нему можно получить доступ из классов внутри одного пакета и всех 
подклассов этого класса (включая те, что находятся в других пакетах). На данный момент важно помнить, что protected менее 
ограничен, чем default, поскольку он позволяет некоторым классам из других пакетов получить доступ к члену кода.

Модификатор доступа public означает, что нет никаких ограничений на использование поля, метода или класса. Он часто 
используется для конструкторов, методов, представляющих API класса, но обычно не используется с полями.

private — available only inside a class;
package-private (also known as default, implicit) — available for all classes in the same package;
protected — available for classes in the same package and for subclasses (will be covered later);
public — available for all classes everywhere

Помните, что при объявлении классов могут использоваться только модификаторы public или default (без ключевых слов). Все четыре из 
них могут быть применены к членам класса: полям, методам и т.д.

=======================================Модификатор доступа Protected (Protected modifier)==========================================
Этот модификатор означает, что только подклассы и любые классы из одного пакета могут использовать член класса. Класс верхнего 
уровня не может иметь модификатор Protected, но внутренний может быть объявлен таким образом. Именно здесь возникает важность 
правильной декомпозиции пакета.

Protected vs default
Вы можете думать о классах из одного и того же пакета, как о соседях, а о подклассах как о наследниках определенного класса. 
Есть некоторые вещи, которыми вы можете поделиться или сделать со своими соседями, например, обсудить план ремонта здания или 
разделить подвал. Эти вещи и действия будут package-private (default).
Есть также действия, которые вы можете сделать для детей и близких друзей, например, занять немного денег или пойти прогуляться в 
парк в воскресенье. Эти действия будут Protected.

Protected vs private.
Это различие еще проще: если переменная, метод или внутренний класс используется только самим классом, то он private, в противном 
случае он Protected. Следуя главному правилу: Используйте наиболее ограничительный уровень доступа, который имеет смысл для 
конкретного участника.
Если вы не уверены, полезен ли этот метод для других классов, лучше сначала сделать его закрытым и при необходимости расширить его 
доступность позже.

В приведенном ниже примере пакет org.hyperskill.bluetooth имеет три класса: Laptop, SmartPhone и SmartWatch. Все гаджеты в 
пакете могут быть подключены через Bluetooth. Laptop имеет метод receiveInfo(), отвечающий за получение любой информации от 
подключенных гаджетов.

package org.hyperskill.bluetooth;

public class Laptop {

    private String info;

    void receiveInfo(String info) {
        this.info = info;
    }

}

Класс Laptop имеет только одно поле info, которое является private. Но все классы из одного и того же пакета могут получить к нему 
доступ, вызывая метод receiveInfo, который объявлен как package-private (без модификатора).

Мы считаем, что классы SmartPhone и SmartWatch расширяют один и тот же класс MobileGadget с помощью метода printNotification:

package org.hyperskill.bluetooth;

public class MobileGadget {

    protected void printNotification(String data) {
        System.out.println(data);
    }
}

Метод printNotification доступен для всех подклассов этого класса, а также для всех классов в одном пакете (включая класс Laptop).
Rласс SmartPhone, может получить доступ к методу receiveInfo класса Laptop и методу printNotification класса MobileGadget.

package org.hyperskill.bluetooth;

public class SmartPhone extends MobileGadget {

    private Laptop connectedLaptop;

    public SmartPhone() {
        this.connectedLaptop = new Laptop();
    }

    private void sendInfoToLaptop(String data) {
        printNotification("Sending data to laptop : "  + data);
        connectedLaptop.receiveInfo(data);
    }
}

Класс SmartWatch имеет private метод countHeartRate, который недоступен для других классов. Он также использует метод класса
Laptop для получения данных и метод родительского класса для печати уведомления:

package org.hyperskill.bluetooth;

public class SmartWatch extends MobileGadget {

    private int avgHeartRate;
    private Laptop connectedLaptop;

    public SmartWatch() {
        this.avgHeartRate = 75;
        this.connectedLaptop = new Laptop();
    }

    private int countHeartRate() {
        System.out.println("Counting heart rate");
        return avgHeartRate;
    }

    private void sendInfoToLaptop(String data) {
        printNotification("Sending data to laptop : "  + data);
        connectedLaptop.receiveInfo(data);
    }
}

====================================Ссылки на объекты подкласса (Referencing subclass objects)=====================================
Существует два способа ссылки на объект подкласса:

- использование ссылки на подкласс. Ссылка на подкласс может использоваться для ссылки на его объект;
- использование ссылки на суперкласс. Ссылочная переменная суперкласса может использоваться для ссылки на любой объект подкласса, 
производный от этого суперкласса, поскольку подкласс является частным случаем суперкласса.

Рассмотрим пример иерархии классов.

class Person {

    protected String name;
    protected int yearOfBirth;
    protected String address;

    // public getters and setters for all fields
}

class Client extends Person {

    protected String contractNumber;
    protected boolean gold;

    // public getters and setters for all fields
}

class Employee extends Person {

    protected Date startDate;
    protected Long salary;

    // public getters and setters for all fields
}

Как вы знаете, каждый из представленных классов имеет конструктор no-args по умолчанию.
Теперь давайте рассмотрим оба подхода к ссылке в действии.

1. Subclass reference. Мы можем создавать экземпляры подклассов с помощью конструктора:
Person person = new Person(); // the reference is Person, the object is Person
Client client = new Client(); // the reference is Client, the object is Client
Employee employee = new Employee(); // the reference is Employee, the object is Employee

В этом случае мы использовали ссылки на подклассы, поскольку типы ссылок совпадают с типами создаваемых объектов.

2. Superclass reference. При создании объектов с помощью конструктора мы можем ссылаться на объект подкласса, используя ссылку на 
суперкласс:

Person client = new Client(); // the reference is Person, the object is Client
Person employee = new Employee(); // the reference is Person, the object is Employee

В этом случае мы использовали ссылку на суперкласс, поскольку ссылки имеют тип суперкласса, а фактические типы создаваемых объектов 
являются подклассами.

Есть некоторые моменты, которые вы должны помнить:
- вы не можете назначить объект одного подкласса ссылке другого подкласса, потому что они не наследуют друг друга:
Client whoIsIt = new Employee(); // it's impossible

- вы не можете назначить объект родительского класса ссылке на его подкласс:
Client client = new Person(); // it's impossible too

Основное правило звучит так: Если класс А является суперклассом класса В, а класс В-суперклассом класса С, то переменная класса А 
может ссылаться на любой объект, производный от этого класса (например, объекты класса В и класса С). Это возможно потому, что 
каждый объект подкласса является объектом своего суперкласса, но не наоборот.

Мы можем использовать ссылку на суперкласс для любого объекта подкласса, производного от него. Однако мы не можем получить доступ к 
конкретным членам подкласса через ссылку на базовый класс. У нас есть доступ только к тем членам объекта, которые определены типом 
ссылки.

Пример. В рассматриваемой иерархии каждый класс имеет геттеры и сеттеры для доступа к защищенным полям извне.

Person employee = new Employee();

employee.setName("Ginger R. Lee"); // Ok
employee.setYearOfBirth(1980); // Ok
employee.setSalary(30000); // Compile-time error, the base class "doesn't know" about the method

Суперкласс Person не имеет метода setSalary класса Employee. Вы не можете вызвать метод через ссылку суперкласса. То же правило 
работает и для полей.

Вы всегда можете привести объект подкласса к его суперклассу. Также может быть возможно привести объект из типа суперкласса в 
подкласс, но только если объект действительно является экземпляром этого подкласса, в противном случае будет вызвано 
ClassCastException. Будьте осторожны при приведении класса к его подклассу. После успешного приведения суперкласса к подклассу мы 
можем получить доступ к его членам

Person person = new Client();

Client clientAgain = (Client) person; // it's ok
Employee employee = (Employee) person; // the ClassCastException occurs here

Когда использовать ссылку на суперкласс на практике, может быть не так очевидно. Кроме того, это добавляет некоторые ограничения на 
доступ к членам класса. Есть два распространенных случая:
- обработка массива (или другой коллекции) объектов, имеющих разные типы из одной иерархии;
- метод, который принимает объект базового класса, но может также работать с объектами его подклассов

Затем мы объединили оба этих случая в один пример. Наш метод под названием printNames берет массив c типом Person и отображает его.

public static void printNames(Person[] persons) {
    for (Person person : persons) {
        System.out.println(person.getName());
    }
}

Этот метод будет работать для массива с объектами Person, Client и Employee.

Person person = new Employee();
person.setName("Ginger R. Lee");

Client client = new Client();
client.setName("Pauline E. Morgan");

Employee employee = new Employee();
employee.setName("Lawrence V. Jones");

Person[] persons = {person, client, employee};

printNames(persons);

Результат оказался именно таким, как мы и ожидали:
Ginger R. Lee
Pauline E. Morgan
Lawrence V. Jones



=============================================Геттеры и сеттеры (Getters and setters)===============================================
Для доступа к скрытым полям программисты пишут специальные типы методов: геттеры и сеттеры. Геттеры могут только читать поля, 
сеттеры могут только писать (изменять) поля. Оба типа методов должны быть с модификатором public.

Использование этих методов дает нам некоторые преимущества:
- поля класса могут быть доступны только для чтения, только для записи или и то, и другое;
- класс может иметь полный контроль над тем, какие значения хранятся в полях;
- пользователи класса не знают, как класс хранит свои данные, и не зависят от полей.

Java не предоставляет никаких специальных ключевых слов для методов getter и setter. Их главное отличие от других методов-это их 
названия.
В соответствии с конвенцией JavaBeans:
- геттеры начинаются с get, за которыми следует имя переменной, причем первая буква имени переменной пишется с заглавной буквы;
- сеттеры начинаются с set, за которым следует имя переменной с заглавной буквы.
Это соглашение применяется ко всем типам, кроме boolean. Геттер для логического поля начинается с is, за которым следует имя переменной.

Пример:
class Account {

    private long id;
    private String code;
    private long balance;
    private boolean enabled;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public long getBalance() {
        return balance;
    }

    public void setBalance(long balance) {
        this.balance = balance;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
}

Давайте создадим экземпляр класса и заполним поля, а затем прочитаем значения из полей и выведем их.

Account account = new Account();

account.setId(1000);
account.setCode("62968503812");
account.setBalance(100_000_000);
account.setEnabled(true);

System.out.println(account.getId());      // 1000
System.out.println(account.getCode());    // 62968503812
System.out.println(account.getBalance()); // 100000000
System.out.println(account.isEnabled());  // true

===============================================Наследование (Inheritance)==========================================================
Наследование-это механизм получения нового класса из другого класса (родительского класса). Новый класс приобретает некоторые поля и 
методы родительского класса. Наследование-один из основных принципов объектно-ориентированного программирования. Это позволяет 
разработчикам создавать удобные иерархии классов и повторно использовать существующий код.

When it comes to inheritance, there are several terms. A class derived from another class is called a subclass (it's also known as 
a derived class, extended class or child class). The class from which the subclass is derived is called a superclass (also a base 
class or a parent class).

Для получения нового класса из другого используется ключевое слово extends. Общий синтаксис приведен ниже.
class SuperClass { }

class SubClassA extends SuperClass { }

class SubClassB extends SuperClass { }

class SubClassC extends SubClassA { }

Есть основные моменты о наследовании в Java:
- Java не поддерживает множественное наследование, т.е. класс может быть подклассом только одного суперкласса;
- иерархия классов может иметь несколько уровней (класс C может расширять класс B, который расширяет класс A);
- суперкласс может иметь более одного подкласса.

- Подкласс наследует все public и protected поля и методы от суперкласса. Подкласс также может добавлять новые поля и методы. 
Унаследованные и добавленные члены будут использоваться таким же образом.
- Подкласс не наследует private поля и методы от суперкласса. Однако если суперкласс имеет public или protected методы доступа к
 своим закрытым полям, эти члены могут использоваться внутри подклассов.
- Конструкторы не наследуются, но конструктор суперкласса может быть вызван из подкласса с помощью специального ключевого слова 
super.
- Если вы хотите, чтобы поля и методы родительского класса были доступны из всех подклассов, но не из внешнего кода (исключая один 
и тот же пакет), используйте модификатор доступа protected
- Наследование представляет собой отношение IS-A. Базовый класс представляет общее, а подкласс-частное или специфическое.

Пример:

class Person {
    protected String name;
    protected int yearOfBirth;
    protected String address;

    // public getters and setters for all fields here
}

class Client extends Person {
    protected String contractNumber;
    protected boolean gold;

    // public getters and setters for all fields here
}

class Employee extends Person {
    protected Date startDate;
    protected Long salary;

    // public getters and setters for all fields here
}

class Programmer extends Employee {
    protected String[] programmingLanguages;

    public String[] getProgrammingLanguages() {
        return programmingLanguages;
    }

    public void setProgrammingLanguages(String[] programmingLanguages) {
        this.programmingLanguages = programmingLanguages;
    }
}

class Manager extends Employee {
    protected boolean smile;

    public boolean isSmile() {
        return smile;
    }

    public void setSmile(boolean smile) {
        this.smile = smile;
    }
}

Эта иерархия имеет два уровня и пять классов в целом. Все поля имеют модификатор protected, что означает, что они видны подклассам.
Каждый класс также имеет общедоступные геттеры и сеттеры, но некоторые из них пропускаются в коде.
Давайте создадим объект класса Programmer и заполним унаследованные поля с помощью унаследованных сеттеров. Для чтения значений 
полей мы можем использовать унаследованные геттеры.

Programmer p = new Programmer();

p.setName("John Elephant");
p.setYearOfBirth(1985);
p.setAddress("Some street, 15");
p.setStartDate(new Date());
p.setSalary(500_000L);
p.setProgrammingLanguages(new String[] { "Java", "Scala", "Kotlin" });

System.out.println(p.getName()); // John Elephant
System.out.println(p.getSalary()); // 500000
System.out.println(Arrays.toString(p.getProgrammingLanguages())); // [Java, Scala, Kotlin]

Если класс объявлен с ключевым словом final, он вообще не может иметь подклассов.
final class SuperClass { }

Если вы попытаетесь расширить класс, произойдет compile-time error.
Некоторые стандартные классы объявляются как final: Integer, Long, String, Math. Они не могут быть расширены.

============================================================BigInteger=============================================================
Как вы помните, стандартные примитивные целочисленные типы не могут хранить очень большие числа. Невозможно присвоить переменной 
типа int (или даже long) следующее большое число):
int y = 62957291795228763406253098; // compilation-error: integer number too large

К счастью, библиотека классов Java предоставляет класс BigInteger для обработки очень больших чисел (как положительных, так и 
отрицательных). Размер сохраненного числа ограничен только доступной памятью.

Класс BigInteger является неизменяемым, что означает, что методы класса возвращают новые экземпляры вместо изменения существующих.

Хотя этот тип может хранить любые целые числа, включая малые числа, BigInteger следует использовать только в случае крайней 
необходимости. Операции BigInteger существенно медленнее, чем операции со встроенными целочисленными типами.

Класс BigInteger принадлежит к пакету java.math. Мы импортируем его, написав следующее заявление:
import java.math.BigInteger;

Вот экземпляр класса, который хранит большое число представленное выше:
BigInteger number = new BigInteger("62957291795228763406253098");

Также можно создать экземпляр, передав long методу valueOf:
BigInteger number = BigInteger.valueOf(1_000_000_000);

Кроме того, класс имеет несколько полезных констант:
BigInteger zero = BigInteger.ZERO; // 0
BigInteger one = BigInteger.ONE;   // 1
BigInteger ten = BigInteger.TEN;   // 10

Их использование является хорошей практикой, поскольку константы позволяют повторно использовать уже созданный объект. Это особенно 
важно, учитывая, что экземпляр BigInteger на самом деле довольно большой. За исключением точки оптимизации памяти, код с 
константами легче читать.

Compare the code below:

if (something) {
    return new BigInteger("1");
}

and its analog with constants:

if (something) {
    return BigInteger.ONE;
}


Класс имеет набор нестатических методов для выполнения всех стандартных арифметических операций. Следующий пример демонстрирует 
сложение.
BigInteger eleven = ten.add(one);
System.out.println(eleven); // 11

System.out.println(ten); // 10, it has not changed!

BigInteger nine = ten.subtract(BigInteger.ONE); // 10 - 1 = 9
BigInteger oneHundredTen = ten.multiply(eleven); // 10 * 11 = 110
BigInteger twelve = oneHundredTen.divide(nine); // integer division: 12

Метод negate возвращает новый BigInteger с измененным знаком, например:
nine.negate(); // -9

Метод divideAndRemainder возвращает массив, состоящий из двух чисел: результата целочисленного деления и остатка.
BigInteger[] pair = oneHundredTen.divideAndRemainder(nine); // 12 and 2

Класс также предоставляет методы для выполнения более сложных математических операций. Метод abs возвращает новый BigInteger, 
значение которого является модулем этого BigInteger.
BigInteger number = new BigInteger("-8");
System.out.println(number.abs()); // 8

Метод gcd возвращает наибольший общий делитель двух чисел.
BigInteger three = BigInteger.valueOf(3);
BigInteger six = BigInteger.valueOf(6);
System.out.println(three.gcd(six)); // 3

Метод подсчёта факториала:

static BigInteger factor(long a) {
        BigInteger result = BigInteger.ONE;
        for (long i = 1; i <= a; i++) {
            result = result.multiply(BigInteger.valueOf(i));
        }
        return result;
    }

================================================Работа с файлами, класс File (Files)=======================================================
Существует класс File в пакете Java.io . Объект этого класса представляет собой существующий или несуществующий файл или каталог. 
Класс может использоваться для управления файлами и каталогами: создания, удаления, доступа к свойствам и многого другого.

Самый простой способ создать объект - передать строковый путь его конструктору. Допустимый формат строки зависит от операционной 
системы:
- Windows uses backslashes for paths ('\'),
- Linux, OS X, Android and other UNIX-like systems use the forward slash ('/').

Давайте создадим два объекта класса File для разных платформ.
File fileOnUnix = new File("/home/username/Documents");    // a directory on a UNIX-like system
File fileOnWin = new File("D:\\Materials\\java-materials.pdf"); // a file on Windows

Код будет работать, даже если файл или каталог на самом деле не существует в вашей файловой системе. Он не создает новый файл или 
каталог. Он просто представляет собой "виртуальный" файл или каталог, который уже существует или может быть создан в будущем.

Чтобы отобразить символ для разделения пути к файлу в вашем случае, вы можете напечатать следующее:
System.out.println(File.separator); // '/' - for Linux

Объекты класса File являются неизменяемыми; то есть после создания абстрактный путь, представленный объектом, никогда не изменится.

                                               Абсолютный и относительный путь
1) Абсолютный путь к файлу
Вы уже видели примеры файлов, описанных абсолютным путем. Проще говоря, путь является абсолютным, если он начинается с корневого 
элемента файловой системы. Он содержит полную информацию о расположении файла, включая тип операционной системы.
Считается плохой практикой находить файл, используя его абсолютный путь внутри ваших программ, так как вы потеряете возможность 
повторного использования вашей программы на разных платформах. Другая проблема заключается в том, что вы не можете перенести файл 
вместе с указанным каталогом, вам придется изменить код, который обращается к нему.

2) Относительный путь
Относительный путь-это путь, который не включает корневой элемент файловой системы. Он всегда начинается с вашего рабочего каталога. 
Этот каталог представлен символом . (точка). Относительный путь не является полным и должен быть объединен с текущим путем к 
каталогу, чтобы добраться до запрошенного файла.

Вот пример с файлом внутри каталога images, который находится в вашем рабочем каталоге:
File fileOnUnix = new File("./images/picture.jpg");
File fileOnWin = new File("./images/picture.jpg");

Как вы можете видеть, оба пути выглядят совершенно одинаково, что обеспечивает независимость платформы. Интересно, что точку в
начале пути можно пропустить, поэтому путь images/picture.jpg тоже правильный.

Для построения платформо-независимых программ общепринято использовать относительный путь, когда это возможно. Вы также можете 
перенести весь рабочий каталог, который содержит images/picture.jpg без каких-либо изменений кода.

To access the parent directory, just write .. (double dot). So, ../picture.jpg is a file placed in the parent directory of the working directory. 
The relative path images/../images/picture.jpg means the parent directory of images, then the images folder again. And picture.jpg is the file inside images folder. 
In general images/../images/picture.jpg and images/picture.jpg are the same paths.

			Методы класса File (https://docs.oracle.com/javase/7/docs/api/java/io/File.html)
- String getPath() возвращает путь к этому файлу или каталогу;
- String getName() возвращает имя этого файла или каталога (только последнее имя пути)
- boolean isDirectory() возвращает true, если это каталог существует, в противном случае false;
- boolean isFile() возвращает true, если это существующий файл (а не каталог), в противном случае false;
- boolean exists() возвращает true, если этот файл или каталог действительно существует в вашей файловой системе, в противном 
случае-false;
- String getParent() возвращает путь к родительскому каталогу, содержащему этот файл или каталог.

Давайте создадим экземпляр существующего файла и распечатаем некоторую информацию о нем.

File file = new File("/home/username/Documents/javamaterials.pdf");

System.out.println("File name: " + file.getName());
System.out.println("File path: " + file.getPath());
System.out.println("Is file: " + file.isFile());
System.out.println("Is directory: " + file.isDirectory());
System.out.println("Exists: " + file.exists());
System.out.println("Parent path:" + file.getParent());
As we expect, the code prints the following:

File name: javamaterials.pdf
File path: /home/username/Documents/javamaterials.pdf
Is file: true
Is directory: false
Exists: true
Parent path: /home/username/Documents

Предположим теперь у нас есть экземпляр, который представляет собой несуществующий файл и печатает информацию о нем:
File name: javamaterials1.pdf
File path: /home/art/Documents/javamaterials1.pdf
Is file: false
Is directory: false
Exists: false
Parent path:/home/art/Documents

Существует также группа методов CanRead(), CanWrite(), CanExecute() для проверки того, может ли приложение читать/изменять/выполнять 
файл, обозначенный путем. Рекомендуется использовать эти методы, в противном случае вы можете столкнуться с ошибками доступа к 
файлам, когда ваш пользователь не имеет достаточных разрешений для выполнения операции с файлом.


===================================================Запись в файл (Writing files)===================================================
1) Класс java.io.FileWriter
Класс FileWriter имеет набор конструкторов для записи символов и строк в указанный файл:

FileWriter(String fileName);
FileWriter(String fileName, boolean append);
FileWriter(File file);
FileWriter(File file, boolean append);

Два конструктора принимают дополнительный параметр append, который указывает, следует ли добавлять (true) или перезаписывать 
(false) существующий файл.

Все эти конструкторы могут вызывать исключение IOException по нескольким причинам:
- если именованный файл существует, но это каталог;
- если файл не существует и не может быть создан;
- если файл существует, но не может быть открыт.

Давайте рассмотрим следующий код:
File file = new File("/home/username/path/to/your/file.txt");
FileWriter writer = new FileWriter(file); // overwrites the file

writer.write("Hello");
writer.write("Java");

writer.close();

Если указанный файл не существует, он будет создан после выполнения этого кода. Если файл уже существует, этот код 
перезаписывает данные. Файл будет содержать текст HelloJava.

Если вы хотите добавить некоторые новые данные, вы должны указать второй аргумент как true.
File file = new File("/home/username/path/to/your/file.txt");
FileWriter writer = new FileWriter(file, true); // appends text to the file

writer.write("Hello, World\n");
writer.close();

Этот код добавляет новую строку в файл. Запустите его несколько раз, чтобы увидеть, что произойдет. Обратите внимание, что 
здесь мы используем Unix-подобные линейные прерыватели ОС. Существует разница между символами разрыва строки:
\n Unix-like OS
\r\n Windows OS

Важно закрыть FileWriter после использования, чтобы избежать утечки ресурсов. Это делается путем вызова метода close:
writer.close();

Начиная с Java 7, удобный способ закрыть объект FileWriter-это использовать оператор try-with-resources.
File file = new File("/home/username/path/to/your/file.txt");

try (FileWriter writer = new FileWriter(file)) {
    writer.write("Hello, World");
} catch (IOException e) {
    System.out.printf("An exception occurs %s", e.getMessage());
}

Он автоматически закроет FileWriter.

2) Класс PrintWriter
Класс PrintWriter позволяет записывать форматированные данные в файл. Он может выводить строки, примитивные типы и даже массив 
символов. Класс предоставляет несколько перегруженных методов: print, println и printf.

File file = new File("/home/art/Documents/file.txt");
try (PrintWriter printWriter = new PrintWriter(file)) {
    printWriter.print("Hello"); // prints a string
    printWriter.println("Java"); // prints a string and then terminates the line
    printWriter.println(123); // prints a number
    printWriter.printf("You have %d %s", 400, "gold coins"); // prints a formatted string
} catch (IOException e) {
    System.out.printf("An exception occurs %s", e.getMessage());
}
The result contains:

HelloJava
123
You have 400 gold coins

В этом примере сначала создается экземпляр File и, а затем, PrintWriter в операторе try-with-resources, чтобы правильно закрыть 
его. Он пишет "Hello"и "Java" в одной строке, а затем 123 в новой строке. В этом примере также вызывается расширенный метод 
printf, который может форматировать текст с помощью %d, %s и так далее. После выполнения оператора try-with-resources, 
PrintWriter закрыт.

Класс имеет несколько конструкторов. Некоторые из них похожи на конструкторы FileWriter:
PrintWriter(String fileName);
PrintWriter(File file);

Другие позволяют передавать FileWriter как класс, расширяющий абстрактный класс Writer:
PrintWriter(Writer writer);

FileWriter и PrintWriter расширяют абстрактный класс Writer и имеют много общего. Однако PrintWriter является более 
высокоуровневым и предоставляет несколько полезных методов. Среди них методы форматирования и перегруженные методы печати для 
записи примитивных типов.

===========================================================Reading files===========================================================
Стандартная библиотека классов Java предоставляет несколько способов чтения данных из файлов. Некоторые из них довольно старые, 
другие появились совсем недавно. В этой теме мы рассмотрим только два основных метода, которых пока вполне достаточно. Вы можете 
выбрать тот, который наиболее подходит для вас.

Можно использовать java.util.Scanner для считывания данных из файлов. Этот класс представляет собой высокоуровневый подход к чтению 
входных данных. Он позволяет читать примитивные типы или строки с помощью регулярных выражений.

Прежде всего, нам нужно создать экземпляр java.io.File, а затем экземпляр Scanner, передающего объект file. После этого мы можем 
получить данные из файла с помощью сканера таким же образом, как мы читаем из стандартного ввода.

Предположим, у вас есть строка с именем pathToFile. Он сохраняет путь к файлу, содержащему последовательность чисел, разделенных пробелами.

Давайте создадим объект класса File, а затем сканер для чтения данных из файла.

File file = new File(pathToFile);
Scanner scanner = new Scanner(file); // it throws FileNotFoundException (checked)

При создании экземпляра сканера, передающего файл, необходимо обработать проверяемое исключение FileNotFoundException. Вы также можете 
объявить метод как выбрасывающий это исключение.

Теперь мы можем использовать методы сканера для чтения данных в виде строк, целых чисел и так далее.

while (scanner.hasNext()) {
    System.out.print(scanner.nextLine());
}

Этот код считывает каждую строку из файла и выводит ее.

После использования сканера мы должны закрыть объект, чтобы избежать утечек памяти. Удобный способ закрыть сканер и обработать 
исключения-использовать try-with-resources, как показано ниже.

File file = new File(pathToFile);
 
try (Scanner scanner = new Scanner(file)) {
    while (scanner.hasNext()) {
        System.out.print(scanner.nextLine() + " ");
    }
} catch (FileNotFoundException e) {
    System.out.println("No file found: " + pathToFile);
}

Затем для файла, содержащего:
first line
second line
third line

Программа выводит на консоль следующий результат:
first line second line third line

Сканер также позволяет считывать integers, boolean, doubles и другие типы. Методы имеют соответствующие имена, такие как nextInt, 
nextBoolean и т. Д. В случае отсутствия новых данных любой из следующих методов возвращает исключение java.util.NoSuchElementException.

Вместо отображения прочитанных данных в стандартном выводе вы можете сохранить их в массиве или строке.

Начиная с Java 1.7 появился набор новых классов и методов для обработки файлов. В рамках этой темы мы ограничимся изучением того, как 
читать весь текстовый файл. Обратите внимание, что этот метод следует использовать только для небольших текстовых файлов. Под малым 
мы подразумеваем, что их размер меньше, чем доступная оперативная память JVM. Этого более чем достаточно для обучения и выполнения 
небольших задач.

Прежде всего, сделайте следующий импорт:
import java.nio.file.Files;
import java.nio.file.Paths;

Класс Files состоит из методов, которые работают с файлами, класс Paths содержит набор методов, которые возвращают специальный объект 
для представления пути к файлу.

Следующий метод возвращает весь текст из указанного файла:

public static String readFileAsString(String fileName) throws IOException {
    return new String(Files.readAllBytes(Paths.get(fileName)));
}

Давайте попробуем использовать метод readFileAsString для чтения исходного кода из файла HelloWorld.java и вывести его.

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class ReadingFileDemo {
    public static String readFileAsString(String fileName) throws IOException {
        return new String(Files.readAllBytes(Paths.get(fileName)));
    }

    public static void main(String[] args) {
        String pathToHelloWorldJava = "/home/username/Projects/hello-world/HelloWorld.java";
        try {
            System.out.println(readFileAsString(pathToHelloWorldJava));
        } catch (IOException e) {
            System.out.println("Cannot read file: " + e.getMessage());
        }
    }
}


========================================================Writing files======================================================================
Теперь, когда мы узнали, как создавать файлы и управлять ими, давайте обсудим, как записывать текст в файл.
Java предоставляет для этого разные способы, и в этом уроке мы рассмотрим два самых простых способа: использование классов 
java.io.FileWriter и java.io.PrintWriter.

Класс FileWriter имеет набор конструкторов для записи символов и строк в указанный файл:

FileWriter(String fileName);
FileWriter(String fileName, boolean append);
FileWriter(File file);
FileWriter(File file, boolean append);

Два конструктора принимают дополнительный параметр append, который указывает, следует ли добавлять (true) или 
перезаписывать (false) существующий файл.

Все эти конструкторы могут вызывать IOException по нескольким причинам: 
- если указанный файл существует, но является каталогом; 
- если файл не существует и не может быть создан; 
- если файл существует, но не может быть открыт.

Let's consider the following code:

File file = new File("/home/username/path/to/your/file.txt");
FileWriter writer = new FileWriter(file); // overwrites the file

writer.write("Hello");
writer.write("Java");

writer.close();

Если указанный файл не существует, он будет создан после выполнения этого кода. Если файл уже существует, этот код перезаписывает 
данные. Файл будет содержать текст HelloJava.

Если вы хотите добавить некоторые новые данные, вы должны указать второй аргумент как true.

File file = new File("/home/username/path/to/your/file.txt");
FileWriter writer = new FileWriter(file, true); // appends text to the file

writer.write("Hello, World\n");
writer.close();

Этот код добавляет новую строку в файл. Обратите внимание, что здесь мы используем разрывы строк в Unix-подобных ОС. Существует разница 
между символами разрыва строки на разных платформах: 
\n Unix-подобная ОС 
\r\n Операционная система Windows

Важно закрыть FileWriter после его использования, чтобы избежать утечки ресурсов. Это делается путем вызова метода close:

writer.close();

Since Java 7, a convenient way to close an object of FileWriter is to use the try-with-resources statement.

File file = new File("/home/username/path/to/your/file.txt");

try (FileWriter writer = new FileWriter(file)) {
    writer.write("Hello, World");
} catch (IOException e) {
    System.out.printf("An exception occurred %s", e.getMessage());
}

Класс PrintWriter позволяет записывать отформатированные данные в файл. Он может выводить строки, примитивные типы и даже массив символов. 
Класс предоставляет несколько перегруженных методов: print, println и printf.

File file = new File("/home/art/Documents/file.txt");
try (PrintWriter printWriter = new PrintWriter(file)) {
    printWriter.print("Hello"); // prints a string
    printWriter.println("Java"); // prints a string and then terminates the line
    printWriter.println(123); // prints a number
    printWriter.printf("You have %d %s", 400, "gold coins"); // prints a formatted string
} catch (IOException e) {
    System.out.printf("An exception occurred %s", e.getMessage());
}

The result contains:

HelloJava
123
You have 400 gold coins

Класс имеет несколько конструкторов. Некоторые из них похожи на конструкторы FileWriter: 

PrintWriter(String fileName);
PrintWriter(File file).

Другие позволяют передавать FileWriter как класс, расширяющий абстрактный класс Writer:

PrintWriter(Writer writer).



=======================================================File hierarchies============================================================
Как вы знаете, приложение может хранить данные в файлах на диске. Чтобы структурировать данные, файлы могут быть организованы в 
каталоги. Один каталог, родительский, может включать в себя другие каталоги, подкаталоги. Именно так создается иерархия файлов. 
Например, рассмотрим иерархию файловой системы в Linux: у нее есть корневой каталог /, который включает в себя все другие файлы и 
каталоги, даже если они хранятся на разных физических устройствах.

В программах Java можно выполнить итерацию по иерархии файлов с помощью java.io.File. Давайте рассмотрим четыре метода для этого:

1) File getParentFile() возвращает экземпляр java.io.File, представляющий родительский каталог этого файла, или null, если этот файл 
не имеет родителя (это означает, что он является корневым);

2) String getParent() возвращает строковое представление родительского каталога этого файла или null, если у этого файла нет родителя;

3) File[] listFiles() возвращает массив файлов(пустой массив если файлов нет), расположенных в этом каталоге, или null, если этот 
экземпляр не является каталогом;

4) String[] list() возвращает массив строк с именами файлов и каталогов в каталоге, обозначенном этим абстрактным именем пути.

Любой экземпляр java.io.File имеет эти методы.

Давайте рассмотрим иерархию файлов с корневым каталогом с именем Files. Он содержит два подкаталога: CompletedProjects и Music. У них 
также есть подкаталоги. Каталог HelloWorld содержит два файла, связанных с проектом, каталог JCalculator содержит только один файл, а 
каталог SOUNDTRACKS пуст.

Предположим, у нас есть экземпляр класса java.io.File с именем completedProjsDirectory. Он соответствует каталогу CompletedProjects. 
Теперь давайте получим оба его подкаталога, содержащие данные о проектах.

File[] projects = completedProjsDirectory.listFiles(); // HelloWorld and JCalculator

Конкретный порядок файлов в массиве не гарантируется. Чтобы найти проект HelloWorld, мы будем использовать специальный пользовательский 
метод findFileByName, который возвращает либо найденный файл, либо null.

File helloWorldProject = findFileByName(projects, "HelloWorld"); // just find a file

Мы предполагаем, что это не null просто для упрощения кода в образовательных целях. Тем не менее, лучше проверить, потому что фактическая 
иерархия может быть изменена.Давайте теперь получим Reviews.txt файл с помощью того же метода.

File reviews = findFileByName(helloWorldProject.listFiles(), "Reviews.txt");

Здесь мы предполагаем, что он найден (но имейте в виду NPE в своей будущей работе). Теперь давайте попробуем получить список файлов из 
нашего текущего экземпляра файла.

File[] files = reviews.listFiles(); // null

Список массивов равен нулю, поскольку reviews вообще не является каталогом и не может включать другие файлы или подкаталоги.

Теперь давайте вернемся в каталог CompletedProjects, чтобы попытаться получить его родительские Files.

File filesDirectory = completedProjsDirectory.getParentFile();

В следующем коде мы получаем каталог Soundtracks (снова пропуская все проверки на null).

File music = findFileByName(filesDirectory.listFiles(), "Music");
File soundtracks = findFileByName(music.listFiles(), "Soundtracks");

Каталог не содержит других файлов, поэтому метод listFiles() возвращает пустой массив.

int length = soundtracks.listFiles().length; // 0, but not null

Как вы можете видеть, он возвращает 0, но не null, как в случае, когда экземпляр не является каталогом.


Пример:

import java.io.File;

public class Main {
    public static void main(String[] args) {

        File file = new File("D://basedir/basedir"); // создаём файл
        String[] array = file.list(); // добавляем в массив все подпапки
        String dir = new String();
        int filesInDir = 0;

        for (int i = 0; i < array.length; i++) {
            File temp = new File("D://basedir/basedir/" + array[i]); // перебираем все подпапки
            File[] tempFiles = temp.listFiles(); // создаём массив с файлами подпапки
            if (tempFiles.length > filesInDir) { // ищем подпапку с самым большим количеством файлов
                filesInDir = tempFiles.length;
                dir = array[i];
            }
        }

        System.out.println(dir + " " + filesInDir);
    }
}

Пример 2:

import java.io.File;

public class Main {
    public static void main(String[] args) {
        File file = new File("D://basedir");
        String[] array = file.list();
        StringBuilder out = new StringBuilder();

        for (int i = 0; i < array.length; i++) {
            File temp = new File("D://basedir/" + array[i]);
            String[] tempArray = temp.list();
            if (tempArray == null) {
                continue;
            } else {
                for (int j = 0; j < tempArray.length; j++) {
                    File temp2 = new File("D://basedir/" + array[i] + "/" + tempArray[j]);
                    File[] filesInTemp2 = temp2.listFiles();
                    if (filesInTemp2 == null) {
                        continue;
                    } else if (filesInTemp2.length == 0) {
                        out.append(tempArray[j] + " ");
                    }
                }
            }
        }
        System.out.println(out.toString());
    }
}

Пример 3:

public class Test {
    static String dirName = "";
    static int deepFile = 0;
    static int permDeep = 0;

    public static String getFiles(File files) {
        for (File file : files.listFiles()) {
            if (file.isDirectory()) {
                permDeep++;
                getFiles(file);
                if (permDeep > deepFile) {
                    deepFile = permDeep;
                    dirName = file.getName();
                }
                permDeep--;
            } else {
                if (permDeep > deepFile) {
                    deepFile = permDeep;
                    dirName = file.getName();
                }
            }
        }
        return dirName;
    }

    public static void main(String[] args) {
        getFiles(new File("basedir"));
        System.out.println(dirName + " " + deepFile);
    }
}

=========================================================Managing files============================================================
Как вы уже знаете, java.io.File представляет собой абстрактный путь к файлу или каталогу, который может даже не существовать. 
Помимо простого обхода файловой иерархии, мы также можем управлять файлами и каталогами, создавая, удаляя и переименовывая их. 
Давайте рассмотрим несколько методов для этого. Вы можете использовать рассмотренные методы в различных операционных системах, но в 
следующем примере мы работаем с UNIX-подобной ОС.

Чтобы создать файл в файловой системе, нам нужно сделать следующее:

1) Создайте экземпляр java.io.File с указанным абстрактным путем.
2) Вызовите метод createNewFile этого экземпляра.

После создания экземпляра класса File мы должны вызвать метод createNewFile. Метод возвращает true, если файл был успешно создан, и 
false, если он уже существует. Он не стирает содержимое существующего файла.

File file = new File("/home/username/Documents/file.txt");
try {
    boolean createdNew = file.createNewFile();
    if (createdNew) {
        System.out.println("The file was successfully created.");
    } else {
        System.out.println("The file already exists.");
    }
} catch (IOException e) {
    System.out.println("Cannot create the file: " + file.getPath());
} 

Вы можете спросить: "Почему метод возвращает false вместо того, чтобы создавать исключение, когда файл уже существует"? 
Ответ заключается в том, что иногда для программы не имеет значения, был ли файл создан прямо сейчас или уже существовал.

Чтобы создать каталог, нам также нужно начать с создания экземпляра java.io.File. После этого мы должны вызвать один из 
двух методов этого экземпляра:

1) boolean mkdir создает каталог; он возвращает true только в том случае, если каталог был создан, в противном случае он возвращает false.
2) boolean mkdirs создает каталог, включающий все необходимые несуществующие родительские каталоги; возвращает значение true только в том 
случае, если каталог был создан вместе со всеми указанными родительскими каталогами.

Оба метода не вызывают исключения IOException, в отличие от метода createNewFile.

File file = new File("/home/art/Documents/dir");

boolean createdNewDirectory = file.mkdir();
if (createdNewDirectory) {
    System.out.println("It was successfully created.");
} else {
    System.out.println("It was not created.");
}

Как правило, код работает следующим образом: если каталог не существует, этот код создает его. Если каталог существует, код не 
будет его создавать. Если в пути есть несуществующий родительский каталог, он также не будет создан. В любом случае исключений не бывает.

Вот еще один пример, демонстрирующий метод mkdirs. Он создает целевой каталог и все родительские каталоги, если они не существуют.

File file = new File("/home/art/Documents/dir/dir/dir");

boolean createdNewDirectory = file.mkdirs();
if (createdNewDirectory) {
    System.out.println("It was successfully created.");
} else {
    System.out.println("It was not created.");
}

Теперь, когда мы знаем, как создать каталог, давайте выясним, как избавиться от него. Существует метод с именем delete для удаления 
файла или каталога. Он возвращает true тогда и только тогда, когда файл или каталог успешно удалены, в противном случае он возвращает 
false. Метод возвращает false, если файл или каталог не существует. Важно помнить, что он также возвращает false, если каталог 
содержит подкаталоги или файлы. Это означает, что метод не удалит иерархию, только определенный файл или пустой каталог.

File file = new File("/home/art/Documents/dir/dir/dir");
        
if (file.delete()) {
    System.out.println("It was successfully removed.");
} else {
    System.out.println("It was not removed.");
}

Чтобы удалить каталог, который не является пустым, сначала необходимо удалить все вложенные файлы и каталоги. Взгляните на код ниже. 
Он рекурсивно удаляет каталоги с их содержимым. Обратите внимание, что метод предполагает, что переданный каталог dir действительно существует. 
В противном случае будут созданы исключения children == null и NullPointerException.

public void deleteDirRecursively(File dir) {
    File[] children = dir.listFiles();
    for (File child : children) {
        if (child.isDirectory()) {
            deleteDirRecursively(child);
        } else {
            child.delete();
        }
    }

    dir.delete();
}

Метод delete никогда не вызывает исключение IOException.

Существует также другой способ удаления файлов. Он называется deleteOnExit и удаляет файл или каталог, когда ваша программа останавливается. 
Обратите внимание, что после запроса на удаление отменить его невозможно.

Теперь давайте рассмотрим переименование файлов и каталогов.

Метод renameTo изменяет имя файла, редактируя его в абстрактном пути. Он возвращает true тогда и только тогда, когда переименование прошло 
успешно, в противном случае-false.

File file = new File("/home/art/Documents/dir/filename.txt");

boolean renamed = file.renameTo(new File("/home/art/Documents/dir/newname.txt"));

Тот же метод можно использовать для перемещения файла или каталога из текущего местоположения в другое:

File file = new File("/home/art/Documents/dir/file.txt");

boolean renamed = file.renameTo(new File("/home/art/Documents/another/file.txt"));

Многие аспекты поведения этого метода остаются зависимыми от платформы. Возможно, он не сможет переместить файл из одной файловой системы в другую, 
и это может не сработать, если файл с тем же назначением уже существует. Возвращаемое значение всегда следует проверять, чтобы убедиться, что 
операция прошла успешно.

File file = new File("/home/art/Documents/dir/filename.txt");
File renamedFile = new File("/home/art/Documents/dir/newname.txt");

boolean renamed = file.renameTo(renamedFile);
if (renamed) {
    System.out.println("It was successfully renamed.");
} else {
    System.out.println("It was not renamed.");
}

Метод renameTo вызывает исключение NullPointerException в случае, когда файл назначения равен null.

Большинство рассмотренных методов возвращают false в случае, если у вас нет разрешения на выполнение соответствующей операции: 
переименование, перемещение или удаление файлов и каталогов. Однако метод create выбрасывает java.lang.Исключение IOException в подобных случаях.

Пример:

  public void moveToSpam(String username, File msg) {
      String pathToSpam = username + File.separator + "spam";

      File spamDirectory = new File(pathToSpam);
      if (!spamDirectory.exists()) {
          spamDirectory.mkdir();
      }

      File spamMsg = new File(pathToSpam + File.separator + msg.getName());
      msg.renameTo(spamMsg);
 }


========================================================Reading files======================================================================
	Можно использовать java.util.Scanner для чтения данных из файлов. Этот класс представляет собой высокоуровневый подход к чтению 
входных данных. Он позволяет читать примитивные типы или строки с помощью регулярных выражений.
	Прежде всего, нам нужно создать экземпляр java.io.File, а затем экземпляр Scanner, передающий файл. После этого мы можем получить 
данные из файла с помощью сканера так же, как мы читаем из стандартного ввода.
	Предположим, у вас есть строка с именем pathToFile. Он хранит путь к файлу, содержащему последовательность чисел, разделенных 
пробелами. Давайте создадим файл, а затем сканер для чтения данных из файла.

File file = new File(pathToFile);
Scanner scanner = new Scanner(file); // it throws FileNotFoundException (checked)

Теперь мы можем использовать методы Scanner для чтения данных в виде строк, целых чисел и так далее. Прочитаем строку из файла

while (scanner.hasNext()) {
    System.out.print(scanner.nextLine());
}

Этот код считывает каждую строку из файла и выводит ее на стандартный вывод.

После использования сканера мы должны закрыть объект, чтобы избежать утечек. Удобный способ закрыть сканеры и обработать исключения — 
использовать инструкцию try-with-resources, как показано ниже.

File file = new File(pathToFile);
 
try (Scanner scanner = new Scanner(file)) {
    while (scanner.hasNext()) {
        System.out.print(scanner.nextLine() + " ");
    }
} catch (FileNotFoundException e) {
    System.out.println("No file found: " + pathToFile);
}

Сканер также позволяет читать целые, логические, двойные и другие типы. Методы имеют соответствующие имена, такие как nextInt, 
nextBoolean и т. д. Если новые данные недоступны, любой из следующих методов возвращает java.util.NoSuchElementException.

Вместо того, чтобы отображать прочитанные данные в стандартном выводе, вы можете сохранить их в массиве или строке.


Начиная с Java 1.7 появился набор новых классов и методов для работы с файлами. В рамках этой темы мы ограничимся изучением того, 
как читать текстовый файл целиком. Обратите внимание, что этот метод следует использовать только для небольших текстовых файлов. Под 
маленьким мы подразумеваем, что их размер меньше доступной оперативной памяти JVM. Этого более чем достаточно для обучения и выполнения 
небольших задач. Прежде всего, сделайте следующий импорт:

import java.nio.file.Files;
import java.nio.file.Paths;

Класс Files состоит из методов, которые работают с файлами, класс Paths содержит набор методов, которые возвращают специальный объект 
для представления пути к файлу.

The following method returns all text from a specified file:

public static String readFileAsString(String fileName) throws IOException {
    return new String(Files.readAllBytes(Paths.get(fileName)));
}

Let's try to use the method readFileAsString to read the source code from the file HelloWorld.java and print it to the standard output. 
HelloWorld.java contains a traditional basic program mentioned in one of the earliest topics "The first program".

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class ReadingFileDemo {
    public static String readFileAsString(String fileName) throws IOException {
        return new String(Files.readAllBytes(Paths.get(fileName)));
    }

    public static void main(String[] args) {
        String pathToHelloWorldJava = "/home/username/Projects/hello-world/HelloWorld.java";
        try {
            System.out.println(readFileAsString(pathToHelloWorldJava));
        } catch (IOException e) {
            System.out.println("Cannot read file: " + e.getMessage());
        }
    }
}


=======================================================Потоки (Streams)============================================================
1) Input and output streams
В некотором смысле поток Java похож на реальный поток воды, который имеет начало (источник) и конец (пункт назначения). Основываясь 
на тех же принципах, потоки ввода-вывода можно разделить на две группы:
- input stream (входной поток), считывающий данные из источника; (информация загружается в программу) пример: System.in
- output stream (выходной поток), записывающий данные в указанное место назначения (информация выгружается из программы) System.out

2) Byte and char streams
Потоки могут быть далее классифицированы на две категории в зависимости от того, как они представляют последовательности данных:
- byte streams (байтовые потоки), используемые для чтения и записи данных в байтах;
- char streams (потоки символов), используемые для чтения и записи данных в виде символов в соответствии с 16-битным форматом 
Unicode.
Потоки символов значительно облегчают программистам обработку текстовых данных. По сравнению с ними байтовые потоки достаточно 
низкоуровневы, но могут работать с данными любого типа, включая мультимедийные.

3) Buffered streams
Некоторые потоки используют временную ячейку памяти. Сначала такие потоки считывают или записывают данные во временное 
местоположение, а затем данные перемещаются из него в источник или пункт назначения. Это временное расположение обычно представляет 
собой байтовый или символьный массив, называемый буфером, и весь процесс называется буферизацией. Причина, по которой вводится 
промежуточная ячейка памяти, заключается в том, что обращение к некоторым источникам или адресатам занимает значительный промежуток 
времени. Таким образом, буферизация-это своего рода оптимизация, которая минимизирует количество взаимодействий с ними.

Давайте посмотрим, как работает буферизация в выходных потоках. Когда вы записываете данные в поток, они сначала накапливаются в 
буфере. Как только буфер заполнен, все сохраненные данные записываются в место назначения.

Некоторые входные потоки также имеют функцию буферизации. Когда поток читает данные в первый раз, он читает столько, сколько может 
вместить буфер. Даже если было запрошено всего несколько байтов или символов, буферизованный входной поток будет считывать байты до 
тех пор, пока буфер не будет заполнен. Следующее чтение сначала проверяет, есть ли в буфере какие-либо непрочитанные данные. В 
случае, если буфер содержит некоторые непрочитанные данные, поток берет их из буфера и не должен взаимодействовать с источником. 
В противном случае он запрашивает данные из источника, как и в первый раз.

=========================================================Input streams=============================================================
Данные могут быть получены из разных источников. Помимо стандартного ввода или файла, это могут быть сетевые соединения, буферы в 
памяти или даже объекты. Все они называются источниками входных потоков. Фактически, источником являются любые данные, которые 
могут быть использованы и обработаны программой.
Поскольку реализация конкретного источника потребления довольно специфична, каждый источник нуждается в специализированном классе.

1) Character streams
Существует несколько классов для чтения текста. Они называются потоками ввода символов и позволяют считывать текстовые данные: char 
или String. Например, есть FileReader, CharArrayReader, StringReader и т. д.
Имя класса указывает, какой тип источника он использует в качестве входных данных, и обычно заканчивается на Reader, поскольку все 
такие классы расширяют класс java.io.Reader.
Каждый класс предоставляет набор полезных методов, в то время как они также имеют общие методы для чтения данных:

int read() считывает один символ. Если достигнут конец потока, метод возвращает значение -1. В противном случае он возвращает 
числовое представление символа в соответствии с кодировкой;

int read(char[] cbuf) считывает последовательность символов в переданный массив и возвращает количество символов, 
которые были фактически прочитаны. Он также может возвращать -1 в случае, если данные не были прочитаны;

int read(char[] cbuf, int off, int len) записывает символы в указанную часть переданного массива и возвращает их количество или -1 в случае, 
если данные не были прочитаны.

Эти методы возвращают количество символов, которые были фактически прочитаны или -1. Они также блокируют запуск программы до тех 
пор, пока не будет доступен какой-то вход, достигнут конец потока.

Другим важным методом является void close(), который должен быть вызван после использования потока.

Рассмотрим FileReader в качестве примера классов Reader. FileReader имеет набор конструкторов. Вот некоторые из них:
new FileReader(String fileName)
new FileReader(String fileName, Charset charset)
new FileReader(File file)
new FileReader(File file, Charset charset)

Charset - это класс, который объявляет кодировку от последовательностей байтов до символов. По умолчанию java использует кодировку 
UTF-16, подходящую для большинства задач. Однако иногда файл может иметь другую кодировку, и вам придется использовать другую 
кодировку, чтобы правильно прочитать содержимое файла.

Теперь давайте попробуем прочитать файл. Скажем, у нас есть file.txt со следующим содержимым: input stream

Reader reader = new FileReader("file.txt");

char first = (char) reader.read(); // i
char second = (char) reader.read(); // n

char[] others = new char[12];
int number = reader.read(others); // 10

После запуска кода others будет содержать ['p', 'u', 't', 's', 't', 'r', 'e', 'a', 'm', '\u0000', '\u0000'].
Давайте объясним результат. Поскольку мы прочитали первые две буквы в others, первые 10 символов others заполняются, начиная с 
третьей буквы. Когда поток достиг конца файла, он перестал читать, поэтому последние два символа не обновляются.
Когда вы создаете пустой массив, он заполняется значениями по умолчанию, которые являются '\u0000' для массива char. Это 
причина, по которой последние 2 элемента массива others являются "\u0000".
Хитрость здесь заключается в том, что "\u0000 " интерпретируется как пустой символ и вообще не отображается, хотя технически он 
присутствует. Помните об этом, когда вы читаете данные в массив.

Другой распространенный способ чтения потока текстовых данных-это чтение его по символам до тех пор, пока поток не будет закрыт:
FileReader reader = new FileReader("file.txt");

int charAsNumber = reader.read();
while(charAsNumber != -1) {
    char character = (char) charAsNumber;
    System.out.print(character);
    charAsNumber = reader.read();
}
reader.close();

Когда возвращается -1, это означает, что конец потока достигнут, то есть читать больше нечего.

2) Byte streams
Байтовые потоки могут показаться более сложными, поэтому давайте начнем с того, что вы уже знаете. Чтобы прочитать некоторые 
текстовые данные из стандартного ввода, мы можем создать экземпляр класса Scanner. Вы знакомы с этим процессом:
Scanner scanner = new Scanner(System.in);

System.in пример байтового входного потока. Существуют и другие специализированные классы байтовых потоков: 
ByteArrayInputStream используется для чтения из byte[], FileInputStream предназначен для файлов, AudioInputStream-это способ 
чтения аудиофайлов и многое другое.

Имя класса байтового потока указывает, какой тип источника он использует в качестве входных данных, и обычно заканчивается на 
InputStream, поскольку все такие классы расширяют java.io.InputStreamclass.

Все классы байтовых потоков имеют методы чтения, аналогичные символьным входным потокам:
abstract int read() считывает один байт
int read(byte[] b) считывает некоторое количество байтов и сохраняет их в байтовом массиве
byte[] readAllBytes() считывает все байты

Метод, считывающий байты в массив, возвращает значение int. Это число байтов, которые были фактически считаны из источника. Если возвращается значение -1, то это признак того, что байты не были прочитаны.

Каждый класс входного потока также имеет метод void close() для освобождения системных ресурсов/

Предположим, у нас есть file.txt который содержит текст: input stream. Давайте прочитаем его с помощью класса FileInputStream. Он 
может быть создан с помощью нескольких конструкторов, таких как:
new FileInputStream(String pathToFile)
new FileInputStream(File file)

Здесь мы создаем его, указав имя файла:
FileInputStream inputStream = new FileInputStream("myfile.txt");
Мы собираемся прочитать первые пять байтов:
byte[] bytes = new byte[5];
int numberOfBytes = inputStream.read(bytes);
System.out.println(numberOfBytes); // 5
inputStream.close();

Теперь bytes содержит ['i', 'n', 'p', 'u', 't'].

Пример (чтение текста из консоли и вывод текста в байтах):
import java.io.InputStream;

class Main {
    public static void main(String[] args) throws Exception {
        InputStream inputStream = System.in;
        byte in = (byte) inputStream.read();
        while (in != -1) {
            System.out.print(in);
            in = (byte) inputStream.read();
        }
        inputStream.close();
    }
}

Пример 2:
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String in = reader.readLine();
        StringBuilder out = new StringBuilder(in);
        reader.close();
        System.out.println(out.reverse());
    }
}

Основное различие между байтовыми и символьными потоками заключается в том, что байтовые потоки считывают входные данные как байты, 
в то время как символьные работают с символами.
Компьютер понимает только последовательности байтов. С этой точки зрения любые данные-это набор байтов, а входные потоки байтов-это 
обычный способ чтения любого вида данных. Для компьютеров символы по-прежнему представляют собой комбинации байтов, определенные 
спецификацией кодировки.
Как люди, мы привыкли иметь дело с последовательностями символов. Потоки ввода символов предназначены для чтения данных, состоящих 
из символов. Под капотом они все еще читают байты, но они сразу же кодируют байты в символы.
Если вам нужно прочитать текст, используйте потоки ввода символов. В противном случае, например, при чтении аудио, видео, zip и т.Д., 
используйте байтовые входные потоки.

Пример 1:

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        List<StringBuilder> list = reader.lines()
                .map(el -> new StringBuilder(el).reverse())
                .collect(Collectors.toList());
        list.forEach(System.out::print);
        reader.close();

Пример 2:

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String line = reader.readLine();

        if (line == null || "".equals(line.trim())) {
            System.out.println(0);
        } else {
            System.out.println(line.trim().split("\\s+").length);
        }

        reader.close();


=========================================================Output streams====================================================================
Хотя вам может показаться, что вы еще не работали с потоками, наверняка вы уже использовали подобные конструкции для вывода данных на 
консоль:

System.out.println("Text to display");

В терминологии Java System.out — это поток вывода, который позволяет программистам выводить данные на консоль. Таким образом, вы знакомы с 
потоками вывода.

Как мы узнали из предыдущего раздела, поток вывода позволяет записывать данные в место назначения. Некоторые очевидные места назначения, с 
которыми вы, вероятно, уже работали, — это console и file. Диски, буфер памяти, веб-сокеты или другие сетевые расположения также могут быть 
местом назначения. Вообще говоря, пункт назначения — это целевая конечная точка, которой достигают данные, отправленные в выходной поток.

1) Character output streams
Потоки символьного вывода позволяют записывать текстовые данные: char или String. Возможно, вы уже использовали такие потоки, как FileWriter 
и PrintWriter ранее для записи текстовых данных в файлы. Оба они, как и другие потоки вывода символов, имеют общего абстрактного предка 
java.io.Writer. Давайте посмотрим на это внимательно.

void write(char[] cbuf) writes a char array
void write(char[] cbuf, int off, int len) writes a portion of a char array
void write(int c) writes a single character
void write(String str) writes a string
void write(String str, int off, int len) writes a portion of a string

Another important method is close(). It should be invoked for preventing resource leaks.

Writer имеет в стандартной библиотеке несколько прямых подклассов для разных целей. Например, FileWriter предназначен для записи в файлы. 
StringWriter предназначен для записи в строки. CharArrayWriter использует char[] в качестве адресата.

Рассмотрим класс CharArrayWriter. Кроме методов, унаследованных от Writer, у класса есть собственные методы toCharArray() и writeTo. 
Первый предоставляет содержимое char[]. Последний пишет контент другому Writer.

Представьте случай, когда вам нужно создать два вида визиток. Каждый тип визитки имеет свое содержание, но контактные данные одинаковы.
Здесь будет удобно реализовать метод writeTo класса CharArrayWriter для снабжения обеих карточек содержимым разделов контактов.

CharArrayWriter contactWriter = new CharArrayWriter();
FileWriter bc1 = new FileWriter("business_card_1.txt", true);
FileWriter bc2 = new FileWriter("business_card_2.txt", true);

contactWriter.write("Phone: 111-222-333; Address: Java Avenue, 7");
contactWriter.writeTo(bc1);
contactWriter.writeTo(bc2);

char[] array = contactWriter.toCharArray(); // writer content as char[]

bc1.close();
bc2.close();
contactWriter.close();

Пример 1:

class Converter {
    public static char[] convert(String[] words) throws IOException {
        // implement the method
        try (CharArrayWriter writer = new CharArrayWriter()) {
            for (String word : words) {
                writer.write(word);
            }
    
            return writer.toCharArray();
        }
    }
}

2) Byte output streams
Классы byte output streams из стандартной библиотеки расширяют абстрактный класс java.io.OutputStream. Класс содержит три 
метода для записи:

void write(byte[] b) writes a byte array
void write(byte[] b, int off, int len) writes a portion of a byte array
abstract void write(int b) writes a single byte

Just like character streams, byte streams have void close() that should be invoked in a similar way.

Давайте посмотрим на некоторые прямые подклассы OutputStream из стандартной библиотеки. FileOutputStream предназначен для 
записи данных в файл в качестве места назначения. ByteArrayOutputStream позволяет записывать в массив byte[].

Такие классы, как FilterOutputStream или PipedOutputStream, не имеют конечной точки назначения и записывают данные в другие 
потоки вывода. Предполагается, что эти классы являются промежуточными потоками для преобразования данных или, возможно, обеспечивают 
дополнительную функциональность.

Давайте рассмотрим пример, где мы записываем что-то в файл, используя FileOutputStream. Класс имеет набор конструкторов. 
Некоторые из них:

FileOutputStream(String fileName)
FileOutputStream(String fileName, boolean append)
FileOutputStream(File file)
FileOutputStream(File file, boolean append)

Параметр append указывает, следует ли добавлять (true) или перезаписывать (false) существующий файл.

Полезно знать, что FileOutputStream создаст файл с указанным именем, если он еще не существует. Он создает файл сразу после 
инициализации FileOutputStream, даже если вы не пытались в него что-то записать.

byte[] data = new byte[] {'s', 't', 'r', 'e', 'a', 'm'};
OutputStream outputStream = new FileOutputStream("sample.txt", false);
outputStream.write(data);
outputStream.close();

Обратите внимание, что все рассмотренные выше методы байтовых потоков позволяют записывать только байты. Это означает, что вы не 
можете напрямую писать строки, вы должны сначала преобразовать их в byte[]. Поэтому, если вы хотите записать строку в файл, вы 
должны сначала преобразовать ее в байты. Например, вы можете использовать для этого метод getBytes().

String str = "stream"; 
byte[] strAsBytes = str.getBytes(); // convert String to byte[]

Преобразование String в byte[] каждый раз, когда вам нужно что-то написать, неэффективно и неудобно. Более того, многие потоки 
символов основаны на потоках байтов и хорошо оптимизированы. Так что если вы хотите написать текст, не изобретайте велосипед: 
используйте потоки вывода символов. С другой стороны, вам нужно будет использовать потоки байтов, когда вы будете работать с 
двоичными файлами, например, с изображением .jpg или файлом .pdf.

3) Buffered output streams
Выходные потоки имеют 2 класса из стандартной библиотеки, которые выполняют буферизацию. BufferedOutputStream основан на принципе 
буферизации. У него всего два конструктора:

BufferedOutputStream(OutputStream out)
BufferedOutputStream(OutputStream out, int size)

То же самое работает для BufferedWriter:

BufferedWriter(Writer out)
BufferedWriter(Writer out, int size)

Эти классы являются промежуточными выходными потоками. Они принимают выходной поток в качестве входного и выполняют буферизацию перед 
передачей другому потоку. Дополнительным параметром size является размер буфера. Если вы хотите освободить все данные из буфера, 
записав их в место назначения, вы можете использовать метод flush(). Обычно он вызывается автоматически, когда ваш буфер заполнен или 
перед закрытием потока.


======================================================Serialization basics=================================================================
Существует два процесса сохранения и восстановления состояния объектов между запусками программы: сериализация и десериализация.

Сериализация — это процесс, который преобразует состояние объекта в поток байтов. Объекты сохраняются в какое-то постоянное хранилище 
для последующего восстановления.

Десериализация — это обратный процесс, когда сериализованная форма используется для восстановления фактического объекта.

Существует множество способов сериализации объектов Java в двоичные и текстовые форматы, например XML и JSON. Платформа Java уделяет 
особое внимание двоичной сериализации и предоставляет протокол двоичной сериализации по умолчанию.

Дополнительным свойством сериализации является возможность отправлять некоторые сериализованные объекты по сети, а затем десериализовать 
и использовать их в другой программе Java. Таким образом, сериализация упрощает использование объектов в подключенных системах.

Чтобы сделать класс сериализуемым, он должен реализовать интерфейс Serializable. Это интерфейс - маркер без методов. Он используется для 
информирования компилятора о том, что реализующий его класс имеет особое поведение.

class SomeClass implements Serializable {
    // fields and methods
}

Сериализуемый класс может содержать в качестве своего поля любой примитивный тип и любой другой класс. Все связанные значения и объекты 
также будут сериализованы. Вы можете легко предотвратить сериализацию поля с помощью ключевого слова transient:

private transient String nonSerializedField;

Рекомендуется добавлять специальное поле с именем serialVersionUID для каждого класса, реализующего этот интерфейс. Поле должно быть 
static, final и long типа:

private static final long serialVersionUID = 7L;

Поле serialVersionUID используется для проверки совместимости отправителя и получателя сериализованного объекта и загрузки классов 
для этого объекта. Если номера версий классов отправителя и получателя не совпадают, возникает runtime error InvalidClassException.
Сопоставление этого значения происходит «под капотом» во время сериализации и десериализации. Ошибка возникает только в случаях 
несоответствия.

В Java механизмы сериализации и десериализации основаны на стандартной системе ввода-вывода и byte потоках. Они соответственно 
используют классы ObjectOutputStream и ObjectInputStream.

Первый класс предоставляет метод с именем void writeObject(Object object), который записывает состояние указанного объекта в поток.
Второй класс имеет соответствующий метод Object readObject() для восстановления объекта. Оба метода генерируют исключения, 
когда что-то не так.

Вот два наших полных метода сериализации и десериализации, помещенные в класс SerializationUtils для удобства.

class SerializationUtils {
    /**
     * Serialize the given object to the file
     */
    public static void serialize(Object obj, String fileName) throws IOException {
        FileOutputStream fos = new FileOutputStream(fileName);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(obj);
        oos.close();
    }

    /**
     * Deserialize to an object from the file
     */
    public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(fileName);
        BufferedInputStream bis = new BufferedInputStream(fis);
        ObjectInputStream ois = new ObjectInputStream(bis);
        Object obj = ois.readObject();
        ois.close();
        return obj;
    }
}

Оба метода используют потоки разных типов: файловые потоки, буферизованные потоки и потоки объектов. Создание новых объектов 
потока на основе других потоков является обычной практикой в ​​Java. Они оборачивают друг друга, добавляя новую функциональность в 
соответствии с шаблоном декоратора.

FileOutputStream и FileInputStream используются для работы с файлом; 
BufferedInputStream и BufferedOutputStream необязательны, но полезны для ускорения операций ввода-вывода;
ObjectOutputStream и ObjectInputStream выполняют сериализацию и десериализацию объектов, а также вызывают обернутые потоки для 
работы с файлом.

Предположим, вам нужно разработать информационную систему, которая постоянно хранит всех граждан страны. Вот два связанных класса 
для этой системы: Citizen и Address. Оба класса реализуют интерфейс Serializable и содержат поля serialVersionUID. Класс Citizen 
представляет гражданина страны. У него есть имя, адрес и несериализуемое поле, называемое паспортом.

public class Citizen implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;
    private Address address;
    private transient String passport;

    // getters and setters

    @Override
    public String toString() {
        return "Citizen{" +
                "name='" + name + '\'' +
                ", passport='" + passport + '\'' +
                ", address=" + address +
                '}';
    }
}

Класс Address представляет адрес в стране, где живет гражданин. Он имеет три строковых поля: штат, город и улица.

class Address implements Serializable {
    private static final long serialVersionUID = 1L;

    private String state;
    private String city;
    private String street;

    // getters and setters

    @Override
    public String toString() {
        return "Address{" +
                "state='" + state + '\'' +
                ", city='" + city + '\'' +
                ", street='" + street + '\'' +
                '}';
    }
}

Значение serialVersionUID класса должно увеличиваться всякий раз, когда вы вносите изменения, которые добавляют/обновляют/удаляют 
поле. В противном случае вы можете столкнуться с исключениями в процессе десериализации для объектов, которые были сохранены до 
этого изменения.

Наконец, пришло время посмотреть, как работает сериализация. Вот метод, который генерирует массив граждан.

public static Citizen[] initCitizens() {
    Citizen mark = new Citizen();
    mark.setName("Mark Olson");
    mark.setPassport("503143798"); // the passport was set

    Address markAddress = new Address();
    markAddress.setState("Arkansas");
    markAddress.setCity("Conway");
    markAddress.setStreet("1661  Dawson Drive");

    mark.setAddress(markAddress);

    Citizen anna = new Citizen();
    anna.setName("Anna Flores");
    anna.setPassport("605143321"); // the passport was set

    Address annaAddress = new Address();
    annaAddress.setState("Georgia");
    annaAddress.setCity("Atlanta");
    annaAddress.setStreet("4353  Flint Street");

    anna.setAddress(annaAddress);

    return new Citizen[]{ mark, anna };
}

Вот основной метод, который выполняет всю работу и использует класс SerializationUtils.

public static void main(String[] args) {
    String filename = "citizens.data";
    try {
        SerializationUtils.serialize(initCitizens(), filename);
        Citizen[] citizens = (Citizen[]) SerializationUtils.deserialize(filename);
        System.out.println(Arrays.toString(citizens));
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }
}

Он сериализует двух граждан в файл с именем Citizens.data, а затем загружает их из файла и выводит на стандартный вывод.
Как и ожидалось, программа выводит массив из двух граждан с их полями.

[Citizen{name='Mark Olson', passport='null', address=Address{state='Arkansas', city='Conway', street='1661  Dawson Drive'}}, 
Citizen{name='Anna Flores', passport='null', address=Address{state='Georgia', city='Atlanta', street='4353  Flint Street'}}]

Оба гражданина были успешно десериализованы из файла. Паспорт поля имеет значение null, так как он не был сериализован. 
Вам может быть интересно, как выглядят сериализованные данные в файле. Это что-то вроде этого:

�� ur "[Lorg.hyperskill.problems.Citizen;i� �����  xp   sr  org.hyperskill.problems.Citizen        L addresst !Lorg/hyperskill/problems/Address;L namet Ljava/lang/String;xpsr  org.hyperskill.problems.Address        L cityq ~ L stateq ~ L streetq ~ xpt Conwayt Arkansast 1661  Dawson Drivet 
Mark Olsonsq ~ sq ~ t Atlantat Georgiat 4353  Flint Streett  Anna Flores


============================================================Sockets========================================================================
Как вы, возможно, знаете, у каждого компьютера в Интернете есть уникальный адрес, позволяющий однозначно идентифицировать его и позволять 
другим компьютерам взаимодействовать с ним. Предположим, вам нужно написать сетевое приложение, такое как мессенджер или онлайн-игра. Для 
этого вам необходимо организовать взаимодействие между несколькими пользователями вашего приложения. Вы можете сделать это с помощью 
сокетов.

Сокет — это интерфейс для отправки и получения данных между различными процессами (работающими программами) в двунаправленном порядке.
Он определяется комбинацией адреса компьютера в сети (например, 127.0.0.1, это ваша собственная машина) и порта на этой машине.
Порт — это целое число от 0 до 65535, но предпочтительно больше 1024 (например, 8080, 32254 и т. д.). Итак, сокет может иметь следующий 
адрес: 127.0.0.1:32245.

Чтобы начать связь, одна программа, называемая клиентом, запрашивает соединение с другой программой, называемой сервером, используя адрес 
машины и определенный порт, на котором сервер прослушивает входящие запросы. Сервер просто ждет новый запрос и принимает его или нет. Если 
соединение было принято, сервер создает сокет для взаимодействия с клиентом. И клиент, и сервер могут отправлять данные друг другу, 
используя свои сокеты. Как правило, один сервер взаимодействует с несколькими клиентами. Как долго продолжается взаимодействие, зависит от 
приложения.

Примечание: обе программы клиент и сервер могут быть как на одном компьютере, так и на разных машинах, подключенных через сеть.

Библиотека классов Java предоставляет два основных класса для взаимодействия между программами с использованием сокетов: 

- Socket представляет собой одну сторону двустороннего соединения (используемого клиентами и серверами);
- ServerSocket представляет собой особый тип сокетов, которые прослушивают и принимают соединения с клиентами (используются только серверами).

Оба класса находятся в пакете java.net.*.

Схема взаимодействия: на строне клиента создаётся сокет с помощью класса Socket, с помощью которого идёт обращение к ServerSocket на 
стороне сервера. ServerSocket создаёт Socket для общения с Socket клиента.

В качестве примера напишем небольшой эхо-сервер, который получает сообщения от клиентов и затем отправляет их обратно. В итоге у нас будет 
две программы: клиентская и серверная. Каждая программа имеет свой собственный main метод для запуска.

1) Writing server-side code

Во-первых, рассмотрим серверный код. Чтобы создать серверный сокет, мы используем следующий оператор:

ServerSocket server = new ServerSocket(34522); 

Объект сервера прослушивает порт 34522 для запросов на подключение от клиентов. Сервер может принять нового клиента и создать сокет 
для взаимодействия с ним:

Socket socket = server.accept(); // a socket to interact with a new client

Метод accept заставляет программу ждать нового клиента, т.е. она выполняется до тех пор, пока не придет новый клиент. В результате у 
нас есть объект сокета, который используется для взаимодействия с клиентом.

Для отправки и получения данных нам нужны входные и выходные потоки: 

DataInputStream input = new DataInputStream(socket.getInputStream());
DataOutputStream output  = new DataOutputStream(socket.getOutputStream());

Вызов input.readUTF() получает строковое сообщение от клиента; 
Вызов output.writeUTF(message) отправляет строковое сообщение клиенту.

Ниже мы даем вам полную серверную программу, которая принимает клиентов в цикле и просто повторно отправляет им сообщения.

import java.io.*;
import java.net.*;

public class EchoServer {
    private static final int PORT = 34522;

    public static void main(String[] args) {
        try (ServerSocket server = new ServerSocket(PORT)) {
            while (true) {
                try (
                    Socket socket = server.accept(); // accepting a new client
                    DataInputStream input = new DataInputStream(socket.getInputStream());
                    DataOutputStream output = new DataOutputStream(socket.getOutputStream())
                ) {
                    String msg = input.readUTF(); // reading a message
                    output.writeUTF(msg); // resend it to the client
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Как видите, этот код достаточно прост, но он наглядно демонстрирует основные идеи взаимодействия через сокеты. Он создает только один 
ServerSocket, а затем принимает подключения от клиентов в бесконечном цикле.

2) Writing client-side code

Для начала взаимодействия с сервером нам нужен хотя бы один клиент. Во-первых, мы должны создать сокет, указав путь к серверу.

Socket socket = new Socket("127.0.0.1", 23456); // address and port of a server

Для отправки и получения данных на сервер нам нужны входные и выходные потоки:

DataInputStream input = new DataInputStream(socket.getInputStream());
DataOutputStream output = new DataOutputStream(socket.getOutputStream());

Мы рассмотрели выше, как их использовать. Ниже мы даем вам полную клиентскую программу, которая подключается к серверу, отправляет 
одно сообщение и распечатывает полученное сообщение с сервера.

import java.io.*;
import java.net.Socket;
import java.util.Scanner;

public class EchoClient {
    private static final String SERVER_ADDRESS = "127.0.0.1";
    private static final int SERVER_PORT = 34522;

    public static void main(String[] args) {
        try (
            Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);
            DataInputStream input = new DataInputStream(socket.getInputStream());
            DataOutputStream output  = new DataOutputStream(socket.getOutputStream())
        ) {
            Scanner scanner = new Scanner(System.in);
            String msg = scanner.nextLine();
            
            output.writeUTF(msg); // sending message to the server
            String receivedMsg = input.readUTF(); // response message

            System.out.println("Received from server: " + receivedMsg);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

3) Serving multiple long-connected clients

Если мы хотим разработать чат или игровой сервер, наши клиенты не остановятся после отправки одного сообщения. Они будут 
периодически отправлять и получать сообщения на/с сервера.

Попробуем улучшить наш клиент, чтобы он отправлял пять сообщений на эхо-сервер. Вот только измененный клиентский код внутри 
оператора try.

for (int i = 0; i < 5; i++) {
    Scanner scanner = new Scanner(System.in);
    String msg = scanner.nextLine();

    output.writeUTF(msg);
    String receivedMsg = input.readUTF();

    System.out.println(receivedMsg);
}

Сервер также был модифицирован, чтобы принимать все пять сообщений от клиента.

for (int i = 0; i < 5; i++) {
    String msg = input.readUTF(); // reading the next client message
    output.writeUTF(msg); // resend it to the client
}

Но если мы запустим два или более клиентов, то заметим странный эффект. Сервер не будет взаимодействовать со вторым клиентом, пока 
не ответит на все сообщения от первого клиента. Причина в том, что мы используем только один поток для обработки сообщений от всех 
клиентов.

4) Multithreaded server

Самый простой способ работать с несколькими клиентами одновременно — использовать многопоточность! Пусть один поток сервера 
(например, main) принимает новых клиентов, а другие взаимодействуют с уже принятыми клиентами (1 поток на 1 клиента).

Вот наш модифицированный сервер с новой абстракцией под названием Session. Поскольку сеанс работает в отдельном потоке, мы можем 
запускать несколько сеансов одновременно.

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class EchoServer {
    private static final int PORT = 34522;

    public static void main(String[] args) {
        try (ServerSocket server = new ServerSocket(PORT)) {
            while (true) {
                Session session = new Session(server.accept());
                session.start(); // it does not block this thread
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Session extends Thread {
    private final Socket socket;

    public Session(Socket socketForClient) {
        this.socket = socketForClient;
    }

    public void run() {
        try (
            DataInputStream input = new DataInputStream(socket.getInputStream());
            DataOutputStream output = new DataOutputStream(socket.getOutputStream())
        ) {
            for (int i = 0; i < 5; i++) {
                String msg = input.readUTF();
                output.writeUTF(msg);
            }
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Важно отметить, что мы не используем try-with-resources для server.accept(), потому что мы создаем сокет в одном потоке и закрываем 
его в другом потоке. В этом случае try-with-resources подвержена ошибкам, потому что один поток может закрыть сокет, в то время как 
другой поток хочет его использовать.

===========================================Статические поля и методы (Static members)==============================================
1) Статические переменные
Переменная класса (статическое поле) - это поле, объявленное с ключевым словом static. Он может иметь любой примитивный или 
ссылочный тип, как и обычное поле экземпляра. Статическое поле имеет одно и то же значение для всех экземпляров класса. Оно 
принадлежит классу, а не экземпляру класса.
Если мы хотим, чтобы все экземпляры класса имели общее значение, например глобальную переменную, то лучше объявить ее статической. 
Это может сэкономить память, поскольку одна копия статической переменной является общей для всех созданных объектов.

Статические переменные могут быть доступны непосредственно по имени класса. Чтобы получить доступ к статическому полю, вы должны 
написать: ClassName.fieldName;

Пример 1: 
Вот класс с двумя public static переменными:
class SomeClass {

    public static String staticStringField;

    public static int staticIntField;
} 
Мы можем установить их значение и получить их:
SomeClass.staticIntField = 10;
SomeClass.staticStringField = "it's a static member";

System.out.println(SomeClass.staticIntField); // It prints "10"
System.out.println(SomeClass.staticStringField); // It prints "it's a static member"

Объявлять public static non-final fields плохая практика!

Мы также можем получить доступ к значению статического поля через экземпляр класса.
SomeClass.staticIntField = 30;

SomeClass instance = new SomeClass();

System.out.println(instance.staticIntField); // It prints "30"

Пример 2 
Вот класс со статическим полем lastCreated. В этом поле хранится дата последнего созданного экземпляра.
public class SomeClass {

    public static Date lastCreated;

    public SomeClass() {
        lastCreated = new Date();
    }
}
Значение статического поля изменяется в конструкторе класса при каждом создании нового объекта.

Приведенный ниже код создает два экземпляра и выводит промежуточные результаты:
System.out.println(SomeClass.lastCreated);

SomeClass instance1 = new SomeClass();
System.out.println(SomeClass.lastCreated);

SomeClass instance2 = new SomeClass();
System.out.println(SomeClass.lastCreated); 

Output:
null
Sun Aug 20 17:49:24 YEKT 2017
Sun Aug 20 17:49:25 YEKT 2017

2) Константы класса
Статические поля с ключевым словом final являются константами класса. Их нельзя изменить. Согласно соглашению об именовании, 
final поля всегда должны быть записаны в верхнем регистре с нижним подчеркиванием (_) для разделения частей имени.

Стандартный класс Math , например, содержит две статические константы:
public static final double E = 2.7182818284590452354;

public static final double PI = 3.14159265358979323846;

Константы часто имеют модификатор доступа public, но это не обязательное условие.

Пример. Давайте объявим класс Physics с двумя статическими константами:
class Physics {

    /**
     * The speed of light in a vacuum (m/s)
     */
    public static final long SPEED_OF_LIGHT = 299_792_458;

    /**
     * Electron mass (kg)
     */
    public static final double ELECTRON_MASS = 9.10938356e-31;
}

Чтобы использовать константы, давайте напишем следующий код:
System.out.println(Physics.ELECTRON_MASS); // 9.10938356E-31
System.out.println(Physics.SPEED_OF_LIGHT); // 299792458

Поскольку эти поля являются константами, мы не можем изменить их значения. Если мы попытаемся это сделать, то получим ошибку:
Physics.ELECTRON_MASS = 10; // compile-time error

3) Статические методы
Класс может иметь как статические методы, так и статические поля. Такие методы также известны как методы класса. Статический метод 
может быть доступен по имени класса и не нуждается в объекте класса.
Статические методы могут вызываться непосредственно по имени класса. Чтобы получить доступ к методу, вы должны написать:
ClassName.staticMethodName(args);

Статический метод может иметь аргументы, как обычный метод экземпляра, или не иметь аргументов. Но, в отличие от методов экземпляра, 
статические методы имеют несколько особенностей:
- статический метод может получить доступ только к статическим полям, он не может получить доступ к нестатическим полям;
- статический метод может вызывать другой статический метод, но он не может вызывать метод экземпляра;
- статический метод не может ссылаться на ключевое слово this, поскольку в статическом контексте нет экземпляра.

Однако методы экземпляра могут обращаться к статическим полям и методам.
Статические методы часто используются как служебные методы, общие для всего проекта. Например, вы можете создать класс только со 
статическими методами для выполнения типичных математических операций.

Библиотека классов Java предоставляет множество статических методов для различных классов:
- класс Math содержит множество static методов, таких как Math.min(a, b), Math.abs(val), Math.pow(x, y) и другие;
- класс Arrays имеет множество статических методов обработки массивов, таких как toString(...);
- Long.valueOf(...), Integer.parseInt(...), String.valueOf(...) также являются статическими методами.

Пример. Вот класс с одним конструктором, статическим и экземплярным методом.
public class SomeClass {
    
    public SomeClass() {
        invokeAnInstanceMethod(); // this is possible here
        invokeAStaticMethod();    // this is possible here too
    }
    
    public static void invokeAStaticMethod() { 
        // it's impossible to invoke invokeAnInstanceMethod() here
    }
    
    public void invokeAnInstanceMethod() { 
        invokeAStaticMethod();  // this is possible too
    }
}
Этот пример показывает, что вы можете вызвать статический метод из контекста экземпляра (конструкторы и методы экземпляра), но вы 
не можете вызвать метод экземпляра из статического контекста.

Единственный способ вызвать метод экземпляра из статического-это предоставить ссылку на этот экземпляр в качестве аргумента. Вы 
также можете создавать объекты других классов и вызывать их методы аналогичным образом. Вот пример:
public static void invokeAStaticMethod(SomeClass someClassInstance) {

    // calling instance method from static context by passing instance as an argument
    someClassInstance.invokeAnInstanceMethod(); 

    // calling instance and static methods of AnotherClass instance
    AnotherClass anotherClassInstance = new AnotherClass();
    anotherClassInstance.invokeAnotherClassInstanceMethod();
    anotherClassInstance.invokeAnotherClassStaticMethod();
}

Примером статического метода является основной метод. Он всегда должен быть статичным.

====================================================Coding style conventions=======================================================
1) Java Conventions
Есть два общепринятых соглашения Java, которые используются во всем мире:
- Oracle Code Conventions
- Google Style Guide

2) Количество пробелов
- Первое соглашение заключается в использовании 4 пробелов в качестве единицы отступа во всем программном коде. 

3) Расположение фигурных скобок
- Поместите открывающую фигурную скобку в конец линии, где начинается блок.
- Поставьте закрывающую фигурную скобку в начале следующей строки.

4) Избегайте лишних пробелов
Иногда вы можете добавить некоторые пробелы, даже если они вам действительно не нужны. Это снизит читабельность вашего кода.

- Избегайте лишних пробелов в круглых скобках
Good:
System.out.println("Hello!");

Bad:
System.out.println( "Hello!" )

- Избегайте дополнительного пространства перед открытой круглой скобкой.
Good:
System.out.println("OK");

Bad:
System.out.println ("Shifted braces");

- Избегайте лишних пробелов перед точкой с запятой:
Good:
System.out.println("No extra spaces");

Bad:
System.out.println("It has an extra space") ;

5) Длина строки
Соглашения о коде Oracle предлагают избегать строк длиной более 80 символов. Многие разработчики считают это ограничение устаревшим, 
так как современные мониторы могут легко отображать более длинные строки, в то время как другие будут продолжать следовать этому 
правилу, что удобно, например, при использовании ноутбуков.
Другие популярные предельные значения-100, 120, а иногда и 140 символов.


============================================================Computer algorithms(алгоритмы)===========================================
Вы, вероятно, слышали что-то об алгоритмах в реальной жизни. Проще говоря, это пошаговая последовательность действий, которые вам 
необходимо выполнить для достижения полезного результата. Это может быть алгоритм приготовления бутерброда, описанный рецептом, или 
алгоритм одевания в соответствии с сегодняшней погодой и вашим настроением.

Среди всех алгоритмов есть одна специальная группа, называемая компьютерными алгоритмами. Это те, которые обычно создаются и 
используются компьютерами. В этой теме мы подробно обсудим, что такое компьютерные алгоритмы, и объясним, почему важно их изучать.

Компьютерные алгоритмы повсюду вокруг нас. Ваш смартфон может вести вас по городу из одной точки в другую, используя определенный 
алгоритм. Другие алгоритмы могут управлять поведением ваших врагов в компьютерной игре. Такие сервисы, как Google или Yahoo, применяют 
сложные алгоритмы, чтобы предоставить вам наиболее релевантные результаты, когда вы используете их для поиска информации в Интернете. 
Алгоритмы также используются для расчета траектории ракет. И они даже помогают врачам правильно ставить диагнозы!

Важное различие между реальными и компьютерными алгоритмами заключается в том, что компьютер не может угадать, что мы хотим сделать. 
Если что-то идет не так или алгоритм не ясен, человек может скорректировать алгоритм, основываясь на своем опыте. Компьютеры не могут 
сделать то же самое. Таким образом, компьютерный алгоритм должен быть описан точно и однозначно.

Как вы, возможно, знаете, программа-это последовательность инструкций для выполнения некоторых задач на компьютере. Разница между 
программами и алгоритмами заключается в том, что программы пишутся с использованием определенного языка программирования, в то время 
как алгоритмы обычно описываются на более высоком уровне, чем операторы языка программирования. Другими словами, алгоритм подобен 
абстрактной схеме, и программа может быть его реализацией.

Все это также означает, что алгоритмы не зависят от языка: один алгоритм может быть реализован с использованием разных языков 
программирования. Например, вы можете использовать Java, Python, Kotlin или другие языки для реализации того же алгоритма.

Языки программирования обычно содержат реализации некоторых основных алгоритмов для решения типичных задач. Эти алгоритмы содержатся в 
стандартных библиотеках, и разработчики программного обеспечения могут повторно использовать их вместо того, чтобы каждый раз внедрять 
новый. Однако, чтобы иметь возможность правильно и эффективно использовать такие алгоритмы и понимать, как их используют другие 
разработчики, необходимо изучить эти основные алгоритмы и ознакомиться с тем, как они работают под капотом.

Алгоритмы из стандартных библиотек не могут охватить все возможные проблемы, с которыми могут столкнуться разработчики. Таким образом, 
иногда вам нужно будет самостоятельно реализовать решение проблемы с нуля. Это еще одна причина, по которой важно изучать алгоритмы: 
вам нужно знать, какой из них и когда применять и как эффективно его реализовать.

=================================================================The big O notation===================================================
Предположим, вам нужно выбрать один из нескольких алгоритмов для решения проблемы. Как определить лучший из них?

Мы используем The big O notation для классификации алгоритмов в соответствии с тем, как увеличиваются их требования к времени 
выполнения или пространству (например, к дисковой памяти) в зависимости от размера входных данных. Это не зависит от языка 
программирования, операционной системы, аппаратного обеспечения, ваших навыков программиста и других конкретных деталей реализации. 
Знание The big O notation позволяет найти наилучший алгоритм (с точки зрения времени и требований к памяти) для конкретной задачи.

Во-первых, давайте рассмотрим временную сложность алгоритма в The big O notation.

В этой нотации временная сложность алгоритма записывается как O(T(n).
- T(n) - это функция временной сложности, которая описывает, как время выполнения алгоритма увеличивается в зависимости от размера 
входных данных.;
- символ O означает, что, когда входные данные достаточно велики, время выполнения увеличивается пропорционально функции внутри 
круглых скобок. 

The big O notation имеет одно существенное преимущество. Он описывает верхнюю границу скорости роста функции. Другими словами, он 
описывает наихудший сценарий для нашего алгоритма. На практике алгоритм может работать даже лучше, чем показывает big O, но не хуже.

Ниже приведены, от лучшего к худшему, некоторые общие значения функции big O для временной сложности. Обратите внимание, что 
пространственная сложность алгоритма (как увеличиваются требования к памяти в зависимости от размера входных данных) измеряется 
таким же образом. Например, если алгоритм имеет O(n) (линейную) пространственную сложность, требуемая память увеличивается 
пропорционально размеру входных данных.

Алгоритмы отсортированные от самого эфективного к менее эффективному:
- O(1) (постоянное время). Количество необходимых операций не зависит от размера входных данных. Примеры: доступ к элементу массива 
по индексу, вычисление суммы арифметической прогрессии по формуле, печать одного значения.
- O(logn) (логарифмическое время). Количество требуемых операций пропорционально логарифму размера входных данных (основание логарифма 
не имеет значения). Пример: двоичный поиск в отсортированном массиве.
- О(квадратный корень от n) (время квадратного корня). Количество необходимых операций пропорционально квадратному корню из размера 
входных данных.
- O(n) (линейное время). Количество требуемых операций пропорционально размеру входных данных, т. Е. время растет линейно по мере 
увеличения размера входных данных. Часто такие алгоритмы повторяются только один раз. Примеры: последовательный поиск, нахождение 
максимума/минимума массива.
- O(n logn) (логарифмическое линейное время). Время выполнения увеличивается пропорционально n log n.
- O(n^2) (квадратичное время). Количество необходимых операций пропорционально квадрату размера входных данных. Примеры: простые 
алгоритмы сортировки, такие как сортировка пузырьком, сортировка выбора, сортировка вставки.
- O(2^n) (экспоненциальное время). Количество необходимых операций экспоненциально зависит от размера входных данных. Другими словами, 
время выполнения увеличивается пропорционально 2^n.

Как видите, алгоритм с временной сложностью O(n) лучше, чем алгоритм с временной сложностью O(n^2) потому что линейная функция растет 
медленнее, чем квадратичная. Однако алгоритм со сложностью O(log n) лучше, чем оба из них. Алгоритм со сложностью O(2^n) может 
потребоваться слишком много времени для решения проблемы даже при небольшом размере входных данных. Как правило, мы не используем 
такие алгоритмы на практике. Лучшим из них является алгоритм с временной сложностью O(1), потому что время его выполнения вообще не 
увеличивается с размером входных данных.

=============================================================Data structures==========================================================
Давайте посмотрим правде в глаза: вы не можете игнорировать алгоритмы, если надеетесь написать инновационную и эффективную программу. 
Однако алгоритмы-это не единственное, что вам нужно: помимо вопроса обработки, существует также вопрос хранения данных, в том числе о 
том, сколько места это занимает. Здесь структуры данных пригодятся, поэтому давайте изучим основы структур данных.

Структуры данных - это способ организации данных и обеспечения удобного доступа к ним. Довольно абстрактно? Хорошо, давайте рассмотрим 
более конкретный пример.

Представьте, что у нас есть множество банок и бутылок из-под содовой, которые мы хотели бы как-то организовать. Мы могли бы положить 
все это в случайную сумку или построить башню из банок, но таким образом будет нелегко выловить определенный тип соды или даже 
подсчитать их. Немного поразмыслив, мы решаем положить их в торговый автомат. Этот торговый автомат будет представлять собой структуру 
напитков: у него есть определенный заказ, и вы можете легко наблюдать за банками и бутылками, считать их и понимать емкость машины.

Теперь давайте вернемся к определению и попробуем еще раз: структура данных относится к набору элементов, содержащих данные, а также 
отношения между ними и операции с данными. Как правило, структуры данных имеют два типа операций: внутренние, поддерживающие организацию 
данных, и внешние, доступные пользователям для хранения, извлечения или изменения данных.

Существует несколько общих структур данных: массив, linked list, hash table и целый ряд деревьев (binary search tree, heap, 
red-black tree, B-tree, и т. Д.). 

Существует еще один термин: абстрактный тип данных (ADT), который иногда используется как синоним структур данных, хотя это не совсем 
верно. Давайте попробуем выяснить, что такое ADT, рассмотрев еще один пример.

У нас есть закрытый торговый автомат, в котором не видно товара. Вы также можете знать, как с ним взаимодействовать: вы вставляете монету 
и получаете свой напиток. Если вы просто хотите пить, этой информации более чем достаточно. Для вас не имеет значения, как машина организует 
напитки или сколько их там; вам нужно только знать, как получить свою газировку. Так что это абстрактный торговый автомат для вас.

В общем случае Абстрактный тип данных-это тип данных, который определяется значением и набором возможных операций (поведения) 
с точки зрения пользователя. Есть несколько общих ADT, которые должен знать каждый программист: stack, queue и другие. Как правило, 
современные языки программирования, такие как Java, Python и C++, предоставляют им стандартные библиотеки для использования в новых программах.

Существуют различные способы создания простого торгового автомата, который выполняет единственную функцию обмена монеты на напиток. Содовую 
можно хранить в огромной бутылке; она может быть уже в разных бутылках в куче внутри хранилища; бутылки и банки можно поставить в один большой 
ряд или в десять разных рядов. Все эти механизмы можно назвать реализациями простого абстрактного торгового автомата. Если вы хотите создать 
более сложный механизм с несколькими функциями, например, "выберите тип содовой, а затем дайте монету" или "выберите напиток или мороженое", 
некоторые из предыдущих реализаций не будут работать для этого.

ADT контрастируют со структурами данных, которые являются точными представлениями данных; они отражают точку зрения разработчика, а не пользователя. 
Хорошим примером абстрактного типа данных является int. Мы знаем, какие значения они могут иметь и какие операции они поддерживают 
(сложение, вычитание, умножение и так Далее). Они могут быть представлены в виде дополнения одного или двух в памяти компьютера, но нам обычно 
все равно. Нам достаточно знать, что у нас есть целое число, а не число с плавающей запятой.

В некотором смысле ADT определяет логическую форму типа данных, в то время как структура данных реализует физическую форму типа данных.

========================================================Recursion basics(рекурсия)=================================================================
Короче говоря, рекурсия в программировании-это когда функция вызывает саму себя. У неё есть правила, когда она завершается, и набор правил, чтобы 
свести другие случаи к первому случаю. Функция, которая может это сделать, называется рекурсивной функцией.

Думай об этом, как о матрешке. Это кукла, или, точнее, набор кукол, помещенных одна в другую. Вы открываете первую куклу, а там вторая, открываете 
эту и получаете третью, и так далее, пока не доберетесь до последней куклы, которая не откроется.

Представьте, что вам подарили набор таких кукол, и вы хотите не только найти самую маленькую, но и пересчитать их все. Сколько у тебя кукол? 
не имею. Допустим, у нас есть куклы x. Как истинный энтузиаст рекурсии, вы решаете считать их рекурсивно. Каждый раз, когда вы оптимистичны, вы 
задаете себе вопрос: "Эта кукла самая маленькая?" Вам удается открыть куклу x, но вы не теряете надежды. "Ну что ж, может быть, кукла x-1 не 
откроется". Наконец, вы добираетесь до самой крошечной куклы и восклицаете: "Вот кукла, которую нельзя открыть! Эта кукла-первая!" Теперь вы 
понимаете, что кукла, которую вы открыли последней, на самом деле была второй куклой, затем третьей... И тогда вы можете продолжать, 
пока не найдете x.

Еще раз: сначала вы открываете их один за другим, и только когда вы доберетесь до самого маленького, вы сможете пересчитать их, возвращаясь по 
своим следам. Если бы вы были рекурсивной функцией, предназначенной для подсчета матрешек, вы бы работали точно так, как описано.

Большинство (если не все) языков программирования имеют рекурсию (другими словами, они позволяют функции вызывать саму себя). Очень удобно знать, 
как создавать рекурсивные функции, поэтому давайте теперь создадим алгоритм для подсчета кукол. Каждая рекурсивная функция состоит из 
следующих шагов:
- Тривиальный базовый случай останавливает рекурсию. Это тот случай, для которого мы знаем результат. Например, если мы находим куклу, которую не 
можем открыть, мы берем ее и с гордостью заявляем: "Это наша самая маленькая кукла!"
- Шаг сокращения (один или несколько, представьте, что наша кукла содержит в себе две куклы!) Переводит нас от текущей проблемы к более простой. 
Например, если нашу куклу можно открыть, мы открываем ее и смотрим, что внутри.

Если мы говорим о тривиальном случае нашей функции count(), то это всего лишь одна кукла. Другими словами, если x равен 1, то мы можем перестать 
думать и начинать радоваться.

Теперь представляем себе матрешки из реального мира, если x не равен 1. В этом случае нам нужно попробовать нашу функцию count() на x-1. Просто 
имейте в виду, что нам нужно будет добавить эту куклу, которую мы открыли для результата позже.

How to count X dolls:
    If X is 1, the result is 1.
    If X is not 1, see: "How to count X-1 dolls" + 1.

Но подождите, кто так считает? Хороший вопрос! И вот когда мы перейдем к следующему пункту: является ли рекурсия хорошей альтернативой?

Многие рекурсивные функции можно записать по-другому: мы могли бы просто пройти через все числа от 1 до n и вычислить функцию для каждого числа. 
Например, мы можем открыть самую большую куклу, сказать "Одна", выбросить куклу и повторять эти шаги, пока не найдем последнюю. Этот способ 
вычисления называется циклом. Но какой путь более эффективен?

Это зависит от языка программирования. Как правило, в Python и Java циклы более эффективны с точки зрения времени и памяти. Рекурсия медленнее и 
"тяжелее", потому что каждый вызов функции занимает дополнительную память, а рекурсивные функции обычно вызываются много раз.

В таком случае, почему рекурсия? Ну, у неё есть одно определенное преимущество перед циклами: в некоторых случаях она интуитивно понятнее. 
Если вы уверены, что какая-то функция использует саму себя, гораздо быстрее написать 3-4 строки рекурсивного кода, чем думать, как именно должен 
вести себя цикл. Если у вас мало времени, но вам не нужно беспокоиться о потреблении памяти, рекурсия-это ваш выбор.

Классическим примером рекурсии является математическая функция, называемая факториалом.

Факториал неотрицательного целого числа n равен произведению всех положительных целых чисел от 1 до n включительно. Кроме того, по определению, 
факториал 0 равен 1. Давайте возьмем нормальное число: например, факториал 5 (записанный как 5!) равен 1 * 2 * 3 * 4 * 5 = 120.

Итак, мы знаем факториал 0 и факториал 1. Кроме того, мы могли бы сказать, что факториал любого числа n > 1 равен n, умноженному на факториал n-1. 
Например: 4!=4∗3!=4∗3∗2!=4∗3∗2∗1!=4∗3∗2∗1=24

Если мы выберем "функциональный язык", он будет выглядеть следующим образом: 4!=4∗3!=4∗3∗2!=...=4∗3∗2∗1=24

При написании функции для вычисления факториала мы могли бы сделать это рекурсивно! Нет необходимости много думать, потому что рекурсивную функцию 
можно создать, просто используя определение факториала. У нас есть тривиальный случай (для 0 или 1 наша функция возвращает 1) и шаг сокращения 
(если наше число n > 1, функция возвращает n∗(n−1)!). А теперь попробуйте представить факториальную функцию с помощью цикла. Это ведь не так 
очевидно, не так ли?

================================================================RECURSION(рекурсия)===============================================================
Как вы знаете, метод может вызывать другой метод. Что еще более интересно, метод может вызывать сам себя. Эта возможность известна как рекурсия, а 
сам вызывающий метод называется рекурсивным методом.

Как и любой обычный метод, рекурсивный метод может содержать параметры и возвращать что-то, или он может принимать или не возвращать ничего.

Но сколько раз метод должен вызывать сам себя? Это должно быть ограничено. Метод должен иметь специальное условие для остановки рекурсии, в 
противном случае стек вызовов переполнится и выполнение остановится с ошибкой.

Чтобы написать рекурсивные методы, вы должны рассматривать решение проблемы как уменьшенную версию той же проблемы.

Классическим примером рекурсии является математическая функция, вычисляющая факториал.

public static long factorial(long n) {
    if (n == 0 || n == 1) {
        return 1; // the trivial case
    } else {
        return n * factorial(n - 1); // the recursive call
    }
}

Этот метод имеет один long параметр и возвращает long результат. Реализация включает в себя:
- тривиальный случай, который возвращает значение 1 без каких-либо рекурсивных вызовов;
- шаг сокращения с рекурсивным вызовом для упрощения задачи.

Мы предполагаем, что переданный аргумент >= 0. Если переданное значение равно 0 или 1, результат равен 1, в противном случае мы вызываем тот же 
метод, уменьшая аргумент на единицу.

Давайте вызовем метод, передающий разные аргументы:
long fact0 = factorial(0); // 1 (by definition)
long fact1 = factorial(1); // 1
long fact2 = factorial(2); // 2 (1 * 2)
long fact3 = factorial(3); // 6 (1 * 2 * 3)
long fact4 = factorial(4); // 24 (1 * 2 * 3 * 4)

Но что произойдет, если рекурсивный метод никогда не достигнет базового случая? Стек никогда не перестанет расти. Если стек программы превышает 
предельный размер, возникает ошибка StackOverflowError. Это приведет к сбою выполнения.

Каждый рекурсивный метод может быть записан итеративно с использованием цикла.

Давайте перепишем факториальный метод следующим образом:

public static long factorial(long n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

Существует несколько типов рекурсий:
1) Прямая рекурсия. Метод вызывает себя подобно рассматриваемому факторному методу.
2) Косвенная рекурсия. Метод вызывает другой метод, который вызывает исходный метод.
3) Хвостовая рекурсия. Вызов является хвостовым рекурсивным, если после возврата вызова ничего не нужно делать. Т. Е. когда вызов возвращается, 
результат немедленно возвращается из вызывающего метода. Другими словами, хвостовая рекурсия-это когда рекурсивный вызов является последней 
вызываемой строкой в методе.

Рассматриваемый рекурсивный метод вычисления факториала не является хвостовой рекурсией, поскольку после рекурсивного вызова он умножает 
результат на значение. Но его можно записать как хвостовую рекурсивную функцию. Общая идея состоит в том, чтобы использовать дополнительный 
аргумент для накопления факториального значения. Когда n достигает 0, метод должен возвращать накопленное значение.

public static long factorialTailRecursive(long n, long accum) {
    if (n == 0) {
        return accum;
    }
    return factorialTailRecursive(n - 1, n * accum);
}

И напишите специальную оболочку, чтобы вызвать ее более удобным способом:

public static long factorial(long n) {
    return factorialTailRecursive(n, 1);
}

4) Множественная рекурсия. Метод вызывает себя рекурсивно несколько раз. Хорошо известный пример-вычисление N-го числа Фибоначчи с помощью рекурсии.

Fib(n) = Fib(n - 1) + Fib(n - 2); 
Fib(0) = 0, Fib(1) = 1.

Последовательность Фибоначчи начинается с: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

public static int fib(int n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}

Это решение очень неэффективно, это просто пример множественной рекурсии. Попробуйте запустить метод, передающий 45 в качестве аргумента. Это 
занимает слишком много времени. Если вы замените рекурсию циклом, она будет работать намного быстрее. Другой возможной оптимизацией является метод, 
называемый memoization(запоминанием).

Пример рекурсивного метода возведения числа в степень:

public static double pow(double a, long n) {
        if (n == 0) {
            return 1;
        } else if (n % 2 == 0) {
            return pow(a * a, n / 2);
        }
        return a * pow(a, n - 1);
    }

====================================================================Stack(стэк)===================================================================
Стек-это абстрактный тип данных, в котором элементы вставляются и удаляются в соответствии с принципом "последний вход-первый выход" (LIFO). 
Операция push вставляет элемент в верхнюю часть стека, операция pop удаляет верхний элемент из стека. Доступ к произвольным элементам ограничен. 
Как правило, стек также поддерживает операцию peek, которая просто возвращает текущий верхний элемент. В некоторых случаях также может быть полезно 
проверить, пуст ли стек или каков его размер, поэтому эти операции также должны поддерживаться.

Если элемент 1 был добавлен первым, то он будет удален последним. В то же время элемент 5 был добавлен последним и будет первым в очереди для 
удаления.

Базовой структурой данных для реализации стека может быть массив или linked list с ограниченным доступом к его элементам.

Самый простой пример из реальной жизни-стопка книг. Только книга, помещенная сверху, может быть удалена за один раз, но новая книга всегда 
добавляется в верхнюю часть стопки.

Если вы использовали связанный список или классический массив (без изменения размера) в качестве внутренней структуры, операции push и pop всегда 
занимают постоянное время O(1). Это не зависит от того, сколько элементов находится в стеке, поэтому операции выполняются очень быстро.

=========================================================================Call stack=================================================================
Когда вы пишете программу, она, вероятно, содержит несколько методов, вызывающих друг друга, либо определенных программистом, либо стандартных, и 
все они должны быть выполнены. Как машина понимает порядок выполнения? Как она переключается между различными методами? Как она узнает, когда 
выполнение программы закончится? Чтобы пролить свет на эти вопросы, нам нужно узнать об особой структуре данных — стеке вызовов.

JVM использует стек вызовов (или стек выполнения), чтобы понять, какой метод должен быть вызван следующим, и получить доступ к информации о методе. 
Стек вызовов состоит из stack frames, которые хранят информацию о методах, которые еще не завершены. Информация включает в себя адрес метода, 
параметры, локальные переменные, промежуточные вычисления и некоторые другие данные.

Как обычный стек, стек вызовов следует правилу "Last In First Out" (LIFO). Это означает, что новый stack frame добавляется наверх стека вызовов. 
Новый stack frame добавляется, когда метод начинает выполняться. stack frame удаляется из стека вызовов, когда выполнение метода завершено.

Давайте рассмотрим пример стека вызовов для программы, которая выводит следующее четное число. Для простоты мы будем использовать число 99 в 
качестве входных данных.

public class Main {
    public static void main(String[] args) {
        int n = 99;
        printNextEvenNumber(n);
    }
    
    public static void printNextEvenNumber(int n) {
        int next = (n % 2 == 0) ? n + 2 : n + 1;
        System.out.println(next);
    }
}

Программа объявляет два метода: main и printNextEvenNumber

Первый вызываемый метод-main. Каждый раз, когда вызывается метод, создается новый stack frame. stack frame для main структурирован 
следующим образом:
1) Параметры метода (args) помещаются в стек.
2) Адрес метода (показанный на схеме как имя метода — main) добавляется в stack frame, чтобы сохранить ссылку на то, куда следует 
возвращаться из следующих вызовов метода.
3) Локальные переменные (n) помещаются в стек.

n
main
args

На самом деле в стеке хранится только ссылка на массив args, поскольку все ссылочные типы хранятся в памяти кучи. Но в стеке хранится 
фактическое значение n (которое в нашем примере равно 99).

Следующий вызываемый метод-printNextEvenNumber. Как всегда, создается новый stack frame. Параметры метода (n), 
адрес (printNextEvenNumber для простоты) и локальные переменные (next) добавляются в новый stack frame.

Теперь у нас есть два полных фрейма стека для методов main и printNextEvenNumber в стеке выполнения:

1) stack frame
next
printNextEvenNumber
n

2) stack frame
n
main
args

Обратите внимание, что оба фрейма имеют переменные с именем n, но эти переменные не совпадают, так как 
они принадлежат разным методам.

Затем программа выполняет метод в верхней части стека вызовов (printNextEvenNumber). После выполнения 
текущий stack frame printNextEvenNumber удаляется из стека вызовов, а предыдущий stack frame main продолжает выполнение.

Стандартный метод println работает так же, как и методы, которые мы определили — создается новый stack frame, и когда 
println завершает свою работу, printNextEvenNumber продолжает выполнение.

Количество возможных вызовов методов зависит от объема памяти, выделенной стеку. Когда ваш стек содержит слишком много 
stack frame, он может быть переполнен. Это приводит к ошибке StackOverflowError, которая остановит выполнение. Размер 
стека можно установить с помощью переключателя командной строки-Xss, например:
java YourProgramName -Xss256k

Но мы рекомендуем вам быть осторожными с этим и прочитать некоторые статьи в Интернете, прежде чем изменять размер стека 
по умолчанию. Кроме того, иногда ошибка StackOverflowError указывает на неправильные вызовы рекурсии в вашей программе. 
В этом случае увеличение размера стека вам не поможет.

=============================================minimax algorithm(алгоритм)===================================================
Как профессиональный шахматист, этот алгоритм видит на несколько шагов вперед и ставит себя на место своего противника. Он 
продолжает играть вперед до тех пор, пока не достигнет конечного расположения доски (терминального состояния), что 
приведет к ничьей, выигрышу или проигрышу. Оказавшись в терминальном состоянии, ИИ назначит произвольный положительный балл 
(+10) за победу, отрицательный балл (-10) за проигрыш или нейтральный балл (0) за ничью.

В то же время алгоритм оценивает ходы, которые приводят к конечному состоянию, на основе хода игроков. Он выберет ход с 
максимальным счетом, когда настанет очередь ИИ, и выберет ход с минимальным счетом, когда настанет очередь игрока-человека. 
Используя эту стратегию, Минимакс избегает проигрыша игроку-человеку.

Минимаксный алгоритм лучше всего определить как рекурсивную функцию, которая выполняет следующие действия:
1) возвращает значение, если найдено терминальное состояние (+10, 0, -10)
2) пройдите через доступные места на доске,
3) вызовите функцию минимакса на каждом доступном месте (рекурсия)
4) оцените возвращаемые значения из вызовов функций
5) верните наилучшее значение

Чтобы полностью понять мыслительный процесс Минимакса, давайте реализуем его в коде и увидим его в действии в следующих 
двух разделах.

Minimax in Code
В этом уроке вы будете работать над почти конечным состоянием игры, которое показано на рисунке 2 ниже. Поскольку minimax 
оценивает каждое состояние игры (сотни тысяч), близкое к конечному состояние позволяет вам легче выполнять рекурсивные 
вызовы minimax (9).

Для следующего рисунка предположим, что AI-это X, а игрок-человек-O.

O _ X
X _ X
_ O O

Чтобы легче работать с доской Ti Tac Toe, вы должны определить ее как массив из 9 элементов. Каждый элемент будет иметь 
свой индекс в качестве значения. Это пригодится позже. Поскольку приведенная выше доска уже заполнена некоторыми ходами 
X и Y, давайте определим доску с уже находящимися на ней ходами X и Y (origBoard).

var origBoard = ["O",1,"X","X",4,"X",6,"O","O"];

Затем объявите переменные AIPlayer и HUPlayer и установите для них значения “X” и “O” соответственно.

Кроме того, вам нужна функция, которая ищет выигрышные комбинации и возвращает true, если она их найдет, а также функция, 
которая перечисляет индексы доступных мест на доске.

/* the original board
 O |   | X
 ---------
 X |   | X
 ---------
   | O | O
 */
var origBoard = [“O”,1 ,”X”,”X”,4 ,”X”, 6 ,”O”,”O”];

// human
var huPlayer = “O”;

// ai
var aiPlayer = “X”;

// returns list of the indexes of empty spots on the board
function emptyIndexies(board){
  return  board.filter(s => s != "O" && s != "X");
}

// winning combinations using the board indexies
function winning(board, player){
 if (
 (board[0] == player && board[1] == player && board[2] == player) ||
 (board[3] == player && board[4] == player && board[5] == player) ||
 (board[6] == player && board[7] == player && board[8] == player) ||
 (board[0] == player && board[3] == player && board[6] == player) ||
 (board[1] == player && board[4] == player && board[7] == player) ||
 (board[2] == player && board[5] == player && board[8] == player) ||
 (board[0] == player && board[4] == player && board[8] == player) ||
 (board[2] == player && board[4] == player && board[6] == player)
 ) {
 return true;
 } else {
 return false;
 }
}

Теперь давайте погрузимся в хорошие части, определив минимаксную функцию с двумя аргументами newBoard и player. Затем 
вам нужно найти индексы доступных мест на доске и установить их в переменную под названием availSpots.

// the main minimax function
function minimax(newBoard, player){
  
    //available spots
    var availSpots = emptyIndexies(newBoard);

Кроме того, вам нужно проверить терминальное состояние и вернуть значение. Если O выиграет, вы должны вернуть -10, если 
X выиграет, вы должны вернуть +10. Кроме того, если длина массива доступных точек равна нулю, это означает, что больше 
нет места для игры, игра привела к ничьей, и вы должны вернуть ноль.

  // checks for the terminal states such as win, lose, and tie 
  //and returning a value accordingly
  if (winning(newBoard, huPlayer)){
     return {score:-10};
  }
	else if (winning(newBoard, aiPlayer)){
    return {score:10};
	}
  else if (availSpots.length === 0){
  	return {score:0};
  }

Затем вам нужно собрать баллы с каждого из пустых мест, чтобы оценить их позже. Поэтому создайте массив под названием 
"moves" и пройдите по пустым местам, собирая индекс и оценку каждого перемещения в объекте под названием 
"moves".

Затем установите индексный номер пустого места, которое было сохранено в качестве номера в исходной панели, в свойство 
index объекта move. Позже установите пустое место на новой доске для текущего игрока и вызовите функцию minimax с 
другим игроком и недавно измененной новой доской. Затем следует сохранить объект, полученный в результате вызова 
функции minimax, которая включает свойство score в свойство score объекта move.

Наконец, Minimax сбрасывает newBoard на то, что было раньше, и помещает объект move в массив move.

// an array to collect all the objects
  var moves = [];

  // loop through available spots
  for (var i = 0; i < availSpots.length; i++){
    //create an object for each and store the index of that spot 
    var move = {};
  	move.index = newBoard[availSpots[i]];

    // set the empty spot to the current player
    newBoard[availSpots[i]] = player;

    /*collect the score resulted from calling minimax 
      on the opponent of the current player*/
    if (player == aiPlayer){
      var result = minimax(newBoard, huPlayer);
      move.score = result.score;
    }
    else{
      var result = minimax(newBoard, aiPlayer);
      move.score = result.score;
    }

    // reset the spot to empty
    newBoard[availSpots[i]] = move.index;

    // push the object to the array
    moves.push(move);
  }

Затем алгоритм минимакса должен оценить лучший ход в массиве ходов. Он должен выбрать ход с наибольшим счетом, когда 
играет ИИ, и ход с наименьшим счетом, когда играет человек. Поэтому, если игрок является игроком AIPlayer, он 
устанавливает переменную под названием bestScore на очень низкое число и перебирает массив ходов, если ход имеет более 
высокий балл, чем bestScore, алгоритм сохраняет этот ход. В случае, если есть ходы с одинаковым счетом, будет сохранен 
только первый.

Тот же процесс оценки происходит, когда игрок является HUPlayer, но на этот раз bestScore будет установлен на высокое 
число, и Minimax ищет ход с наименьшим счетом для хранения.

В конце Minimax возвращает объект, хранящийся в bestMove

// if it is the computer's turn loop over the moves and choose the move with the highest score
  var bestMove;
  if(player === aiPlayer){
    var bestScore = -10000;
    for(var i = 0; i < moves.length; i++){
      if(moves[i].score > bestScore){
        bestScore = moves[i].score;
        bestMove = i;
      }
    }
  }else{

// else loop over the moves and choose the move with the lowest score
    var bestScore = 10000;
    for(var i = 0; i < moves.length; i++){
      if(moves[i].score < bestScore){
        bestScore = moves[i].score;
        bestMove = i;
      }
    }
  }

// return the chosen move (object) from the moves array
  return moves[bestMove];
}

====================================================Regexps basics(регулярные выражения)==================================================================
Манипулирование текстовыми данными-довольно популярная задача как в программировании, так и в реальной жизни. Например, нам часто может потребоваться 
проанализировать текст, найти все конкретные строки в файле и так далее. Обработка текстовых данных может быть довольно сложной задачей. Вот почему 
существует специальный инструмент под названием регулярные выражения, который делает это проще и быстрее.

Регулярное выражение (сокращенно regex или regexp) - это последовательность символов, которая описывает общий шаблон для набора строк. Такие шаблоны 
можно использовать для поиска, редактирования и манипулирования текстами. Они могут либо проверить, соответствует ли целая строка или ее подстрока 
заданному шаблону, либо заменить подстроку другой.

Когда нам нужны такие шаблоны? Допустим, мы хотим получить все файлы с одинаковым расширением (например,*. pdf) или извлечь все записи определенного 
имени в разных формах (например, Эдгар По, Эдгар Аллан По, Э. А. По и т. Д.), Все адреса электронной почты или даже найти все числовые структуры, 
обозначающие даты (02/03/2020). С регулярными выражениями такие задачи могут выполняться с помощью одной строки.

Как выглядят такие паттерны? Ну, поначалу они могут показаться запутанными, посмотрите, например, на \d+(\.\d)? или [a-zA-Z]. И они часто значительно 
длиннее. Однако мы начнем с основ.

Регулярные выражения можно рассматривать как своего рода подъязык, поддерживаемый большинством языков программирования, но есть некоторые различия в 
синтаксисе, называемые "flavors". В этом разделе мы рассмотрим регулярные выражения в отрыве от языков программирования, чтобы понять общую идею.

Давайте начнем с изучения того, как формально работает сопоставление. Хотя шаблон регулярного выражения может быть довольно сложным выражением, 
содержащим символы со специальным значением, самое простое регулярное выражение-это просто строка простых символов. Предположим, существует набор 
слов: PARK, SPARK, PARKING, MARK, QUARKS. Вам нужно проверить, в каком из них содержится слово PARK. Это то, что происходит, например, при выполнении 
поиска Ctrl+F на веб-странице.

Мы можем легко решить эту проблему, используя шаблон PARK. Шаблон означает, что символы P, A, R, K в слове должны следовать друг за другом слева направо. 
Мы предполагаем, что все слово соответствует шаблону, если какая-либо часть (подстрока) слова соответствует ему.

слово PARK в точности соответствует нашему образцу;
слово sPARK соответствует нашему шаблону, потому что у него есть подходящая подстрока;
слово PARKing соответствует нашему шаблону по той же причине;
слово mARK не соответствует нашему шаблону из-за буквы М;
слово "quARKs" не соответствует нашему шаблону, поскольку в нем нет подходящей части.

В регулярных выражениях важен регистр символов: park не совпадает с PARK.

Однако поиск подстрок не очень впечатляет. Реальная сила регулярных выражений приходит, когда вы начинаете использовать специальные метасимволы, 
называемые wildcards. Они позволяют определить шаблон, поэтому вы можете сопоставлять строки, которые не обязательно содержат одинаковую 
последовательность символов. Вы можете пропустить некоторые символы в строке или сопоставить разные символы в одних и тех же позициях, или даже 
повторить символ несколько раз.

Давайте представим два простейших wildcards: точку и вопросительный знак.

Символ точки . соответствует любому отдельному символу, включая буквы, цифры и т. Д., За исключением символа новой строки, если он не указан.

Как вы помните, в предыдущем примере два слова не соответствовали шаблону из-за одного неподходящего символа. Давайте рассмотрим их, а также добавим 
два дополнительных слова. Вот наш новый шаблон .ARK с символом точки. В нем говорится: "На месте точки может быть любой символ".

Ура, слова MARK, и QUARKS соответствуют новому шаблону! Но WARm не подходит.

Вопросительный знак ? это специальный символ, который имеет значение “предыдущий символ или ничего". Вопросительный знак ? сигнализирует, что символ 
перед ним может встречаться один или ноль раз в строке, чтобы соответствовать шаблону. Когда мы сможем его использовать?

Возможно, с помощью этого примера вы, наконец, начнете чувствовать магию регулярных выражений. Рассмотрим разницу между английской и американской 
орфографией. Представьте себе, мы пытаемся найти все исследования, в которых упоминается дальтонизм, в архиве некоторых публикаций. Однако он содержит 
разные источники, и их написание может отличаться. Какое слово мы должны искать? Ответ - и то, и другое!

Выражение colou?r будет соответствовать словам colour и color.

Давайте вернемся к нашему предыдущему примеру. Слово ARK не соответствует шаблону .ARK . Но если мы добавим ? сразу после символа точки .?ARK , 
слово ARK будет соответствовать новому шаблону, так как первый символ теперь необязателен.

ИТОГ:
Регулярные выражения позволяют находить соответствующие строки по определенному шаблону. Они используют специальные символы со специальными значениями 
наряду с простыми символами в их буквальной интерпретации:
- точка . соответствует любому отдельному символу, кроме \n;
- вопросительный знак ? означает что "предыдущий символ может отсутствовать в строке";
- регулярные выражения чувствительны к регистру.

====================================================================Regexps in Java=======================================================================
Регулярное выражение-это последовательность символов, которая задает набор строк и используется для поиска, редактирования и манипулирования текстом. 
Как и большинство языков программирования, Java поддерживает регулярные выражения. Мы уже изучили некоторые основы языка регулярных выражений. В этом 
уроке мы рассмотрим, как это реализовано в Java.

Прежде всего, мы можем создать регулярное выражение с помощью класса String. Взгляните на следующий пример:
String aleRegex = "ale"; // the "ale" regex

В Java String имеет встроенную поддержку регулярных выражений. Строки имеют специальный метод, называемый matches(), который принимает шаблон регулярного 
выражения в качестве аргумента и проверяет, соответствует ли строка этому шаблону. Имейте в виду, что метод возвращает true только тогда, когда вся строка 
соответствует регулярному выражению, в противном случае он возвращает false. Шаблон, определенный регулярным выражением, применяется к тексту слева 
направо.

В приведенном ниже примере мы пытаемся сопоставить aleRegex и разные строки:
"ale".matches(aleRegex);  // true
"pale".matches(aleRegex); // false, "pale" string has an additional character
"ALE".matches(aleRegex);  // false, uppercase letters don't match lowercase and vice versa 

Вы можете видеть, что строка "pale" не соответствует нашему шаблону регулярных выражений. Причина в том, что реализация регулярных выражений Java 
проверяет, может ли вся строка вписываться в шаблон регулярных выражений, а не только некоторая подстрока. В этом отношении Java отличается от многих 
других языков программирования.

Вот еще один пример. Шаблон helloRegex состоит из двух слов, разделенных запятой и пробелом:
String helloRegex = "Hello, World";

"Hello, World".matches(helloRegex); // true
"Hello, world".matches(helloRegex); // false
"Hello,World".matches(helloRegex); // false

Как вы помните, реальная сила регулярных выражений заключается в специальных символах, которые помогают вам определить шаблон, соответствующий 
нескольким различным строкам одновременно. В этом уроке мы рассмотрим два специальных символа, с которыми вы уже знакомы.

Точка . соответствует любому отдельному символу, включая буквы, цифры, пробелы и так далее. Единственный символ, с которым он не может совпадать - это 
символ новой строки \n. Приведенные ниже примеры должны показаться вам знакомыми:

String learnRegex = "Learn.Regex";

"Learn Regex".matches(learnRegex); // true
"Learn.Regex".matches(learnRegex); // true
"LearnRegex".matches(learnRegex); // false
"Learn, Regex".matches(learnRegex); // false
"Learn\nRegex".matches(learnRegex); // false

Как вы помните, вопросительный знак ? это специальный символ, который означает “предыдущий символ или ничего". Слова с немного различным написанием на 
американском и британском английском служат традиционным примером применения этого символа:

String pattern = "behaviou?r";

"behaviour".matches(pattern); // true
"behavior".matches(pattern);  // true

Теперь давайте объединим символ точки . и вопросительный знак ? в одном шаблоне регулярных выражений. Эта комбинация означает, что 
"может быть какой-либо один символ или два символа":

String pattern = "..?";

"I".matches(pattern);  // true
"am".matches(pattern); // true
"".matches(pattern);   // false

Прямо сейчас вы, вероятно, задаетесь вопросом, что нам делать, если мы хотим использовать точку . или ? как обычный знак препинания, а не как специальный 
символ в шаблоне регулярных выражений?

Ну, в этом случае мы должны защитить наш специальный символ, поставив перед ним обратный слэш \. Обратный слэш называется escape-символом, потому что он 
помогает символам "избежать" своих рабочих обязанностей. Обратите внимание, что если вы хотите использовать обратный слэш \ в его буквальном значении, 
вам нужно поставить ещё один обратный слэш! Таким образом, двойной обратный слэш \\ в вашем регулярном выражении означает один обратный слэш в 
соответствующей строке.

Обратный слэш \ работает как escape-символ не только для регулярных выражений, но и для String. Таким образом, на самом деле мы должны использовать 
дополнительный обратный слэш, чтобы избежать того, который нам нужнен в регулярном выражении, например:

String endRegex = "The End\\.";

"The End.".matches(endRegex); // true
"The End?".matches(endRegex); // false

Например, регулярное выражение для любой последовательности из пяти символов, которая заканчивается точкой, выглядит следующим образом:

String pattern = ".....\\.";

"a1b2c.".matches(pattern); // true
"Wrong.".matches(pattern); // true
"Hello!".matches(pattern); // false

==========================================================Rejex Sets, ranges, alternations================================================================
Символ точки позволяет нам писать общие шаблоны для сопоставления. Точка, однако, соответствует почти каждому возможному символу, и иногда мы хотим быть 
более конкретными в нашем регулярном выражении.

Каждый набор соответствует одному символу в строке, но какой именно символ это может быть, определяется содержимым набора. Набор записывается в квадратных 
скобках, []. Например, набор "[abc]" означает, что ему может соответствовать один символ "a", "b" или "c". Взгляните на пример ниже:

String pattern = "[bcr]at"; // it matches strings "bat", "cat", "rat", but not "fat"

"rat".matches(pattern); // true
"fat".matches(pattern); // false

Вы можете использовать столько наборов, сколько захотите, и комбинировать их с обычными символами в строке. В следующем примере есть два набора:

String pattern = "[ab]x[12]"; // can match a or b followed by x followed by either 1 or 2

Этот шаблон может быть успешно сопоставлен следующими строками:
"ax1", "ax2", "bx1", "bx2"

Как вы можете видеть, порядок наборов в регулярных выражениях важен. С другой стороны, порядок размещения символов в наборе не имеет значения

Иногда мы хотим сделать наши наборы символов довольно большими. В этом случае нам не нужно записывать их все: вместо этого мы можем указать диапазон, 
обозначенный символом тире. Символ, предшествующий тире, обозначает начальную точку диапазона, символ, следующий за ним, является последним символом, 
который попадает в диапазон. Если необходимые символы сразу следуют друг за другом в таблице кодировки ASCII/Unicode, мы можем поместить их в набор в 
виде диапазона символов. Это включает в себя буквы в алфавитном порядке и числовые значения. Например, мы можем написать набор, который соответствует 
каждой цифре:

String anyDigitPattern = "[0-9]"; // matches any digit from 0 to 9

То же самое работает для диапазонов букв, таких как "[a-z]" или "[A-Z]". Эти диапазоны соответствуют всем латинским строчным и прописным буквам 
соответственно. Поскольку шаблоны чувствительны к регистру, в случае, если мы хотим сопоставить любую букву, игнорирующую регистр, мы можем написать 
следующее регулярное выражение:

String anyLetterPattern = "[a-zA-Z]"; // matches any letter "a", "b", ..., "A", "B", ...

Обратите внимание, что, хотя диапазон [A-z] технически допустим, он включает дополнительные символы, которые помещаются между прописными и строчными 
буквами в таблице ASCII.

Как видите, вы можете легко поместить несколько диапазонов в один набор и смешать их с отдельными символами в любом порядке:

String anyLetterPattern = "[a-z!?.A-Z]"; // matches any letter and "!", "?", "."

В некоторых случаях необходимо указать какие символы не нужны. Затем мы можем написать набор, который будет соответствовать всему, кроме упомянутых в нем 
символов. Для этого мы пишем символ ^ как первый в наборе.

String regex = "[^abc]"; // matches everything except for "a", "b", "c"

"a".matches(regex); // false
"b".matches(regex); // false
"c".matches(regex); // false
"d".matches(regex); // true

То же самое работает для диапазонов:

String regex = "[^1-6]";

"1".matches(regex); // false
"2".matches(regex); // false
"0".matches(regex); // true
"9".matches(regex); // true

Общее правило состоит в том, что вам не нужно избегать специальных символов в наборах, если они используются в их буквальном значении. Например, 
набор [.?!] будет соответствовать одной точке, вопросительному знаку, восклицательному знаку и ничему другому. Однако символов, образующих набор или 
диапазон, следует избегать или помещать в нейтральное положение – в случае, если мы ищем их буквальные символы:

- чтобы соответствовать самому символу тире, мы должны поместить его в первую или последнюю позицию в наборе: "[-a-z]" соответствует строчным буквам и 
тире, а "[A-Z-]" соответствует прописным буквам и тире; 
- ^ не нужно избегать, если она помещена где-либо, кроме начала. Таким образом, набор "[^a-z^]" соответствует всему, кроме строчных букв и символа ^;
- всегда следует избегать квадратных скобок:
	String pattern = "[\\[\\]]"; // matches "[" and "]"

Есть еще один способ сопоставить один из перечисленных элементов, который включает в себя более длинные последовательности на выбор. 
Вертикальная полоса | используется для сопоставления последовательностей символов до или после символа.

String pattern = "yes|no|maybe"; // matches "yes", "no", or "maybe", but not "y" or "e"

"no".matches(pattern); // true

Это полезно в ситуациях, когда мы хотим найти одно из конкретных слов, например, "bear", "bat" or "bird", чтобы завершить предложение, 
The giant ___ scared me, и когда легче указать целые слова. Вертикальную полосу можно использовать вместе со скобками, которые обозначают границы 
чередующихся подстрок: все, что находится в скобках, является необязательной подстрокой, которая может соответствовать блоку чередования:

String pattern = "(b|r|go)at"; // matches "bat", "rat" or "goat"
String answer = "The answer is definitely (yes|no|maybe)";

В общем, чередования служат цели, сходной с целью наборов: они описывают несколько альтернатив, которым может соответствовать определенная часть 
шаблона. Однако, хотя наборы могут соответствовать только одному символу в строке, чередования используются для определения многозначных альтернатив.

==================================================================Shorthands==========================================================================
Есть некоторые наборы, которые используются чаще, чем другие: наборы для цифр, буквенно-цифровых символов или пробелов (мы должны сказать, что пробелов 
довольно много). Чтобы сделать использование таких наборов проще и быстрее, существуют специальные сокращения, которые эквивалентны определенным наборам, 
но имеют более короткие "имена".

Каждое сокращение имеет ту же первую букву, что и ее представление (Digit, Space, Word, Boundsry). Символы верхнего регистра используются для 
обозначения ограничительных сокращений.

Существует несколько предопределенных сокращений для часто используемых наборов символов:
\d-любая цифра из диапозона [0-9];
\s-это символ пробела (включая табуляцию и новую строку), сокращенный от [ \t\n\x0B\f\r];
\w-буквенно-цифровой символ (слово), сокращение от [a-zA-Z_0-9];
\b-это граница слова. Это немного сложнее: он не соответствует какому-либо конкретному символу, он скорее соответствует границе между буквенно-цифровым 
символом и не буквенно-цифровым символом (например, символ пробела) или границе строки (конец или начало ее). Таким образом, "\ba" соответствует всем 
словам (последовательностям буквенно-цифровых символов), начинающимся с "a", "a\b" соответствует всем словам, заканчивающимся "a", а 
"\ba\b" соответствует всем отдельным "a", которым предшествуют и за которыми следуют не буквенно-цифровые символы.

Существуют также аналоги этих сокращений, которые эквивалентны ограничительным наборам и соответствуют всему, кроме символов, упомянутых выше:
\D-кроме цифр, сокращение от [^0-9];
\S-кроме пробелов, сокращенный от [^ \t\n\x0B\f\r];
\W-кроме буквенно-цифрового символа, сокращенный от [^a-zA-Z_0-9].
\B-это граница без слов. Он соответствует ситуации, противоположной ситуации с сокращением \b: он находит свое соответствие каждый раз, когда нет 
"разрыва" между буквенно-цифровыми символами. Например, "a\B" соответствует всем словам, начинающимся с "a".

Давайте рассмотрим пример с сокращениями. Помните, что в Java мы используем дополнительный символ обратного слэша \ для экранирования.

String regex = "\\s\\w\\d\\s";

" A5 ".matches(regex); // true
" 33 ".matches(regex); // true
"\tA4\t".matches(regex); // true, because tabs are whitespace as well

"q18q".matches(regex); // false, 'q' is not a space
" AB ".matches(regex); // false, 'B' is not a digit
" -1 ".matches(regex); // false, '-' is not an alphanumeric character, but '1' is OK. 

Вот как будет выглядеть скоращение границ(\b) в коде Java:
String startRegex = "\\bcat"; // matches the part of the word that starts with "cat"
String endRegex = "cat\\b"; // matches the part of the word that ends with "cat"
String wholeRegex = "\\bcat\\b"; // соответствует целому слову "cat"

До сих пор мы не применяем их на практике, потому что мы имеем дело только с методом matches, который требует полной строки для соответствия 
регулярному выражению.

Если вы не хотите использовать сокращения, мы можем написать то же регулярное выражение, что и ниже:
String regex = "[ \\t\\n\\x0B\\f\\r][a-zA-Z_0-9][0-9][ \\t\\n\\x0B\\f\\r]";

=====================================================================Quantifiers==========================================================================
Существует тип символов, называемый кванторами, который определяет, как часто другой символ может встречаться в шаблоне регулярных выражений. Квантор 
может быть записан как после обычного символа, так и после специального. В общем, кванторы являются одной из наиболее существенных и важных особенностей 
языка регулярных выражений, поскольку они позволяют одному шаблону соответствовать различным строкам различной длины.

Вот список кванторов, которые следует запомнить:
+ соответствует одному или нескольким повторениям предыдущего символа;
* соответствует нулю или более повторений предыдущего символа;
{n} соответствует ровно n повторениям предыдущего символа;
{n,m} соответствует по крайней мере n, но не более m повторений предыдущего символа;
{n,} соответствует как минимум n повторениям предыдущего символа;
{0,m} соответствует не более чем m повторениям предыдущего символа.

Обратите внимание, что существует также другой квантор ?, который делает предыдущий символ необязательным. Это сокращение от {0,1}.

Здесь мы демонстрируем символ +, который соответствует одному или нескольким повторениям предыдущего символа:

String regex = "ca+b";

"cab".matches(regex); // true
"caaaaab".matches(regex); // true
"cb".matches(regex); // false because it does not have at least one repetition of 'a'

Как вы можете видеть, он соответствует только тем строкам, которые имеют одно или несколько повторений символа "а".

В приведенном ниже примере показан символ *, который соответствует нулю или более повторениям предыдущего символа:

String regex = "A[0-3]*";

"A".matches(regex);  // true because the pattern matches zero or more repetitions
"A0".matches(regex); // true
"A000111222333".matches(regex); // true

Как вы можете видеть, квантор звезды, в отличие от квантора плюс, позволяет шаблону также соответствовать строкам, которые вообще не имеют 
"квантифицированного" символа.

В следующем примере есть шаблон, описывающий строку "John", расположенную между неопределенным количеством неопределенных символов в тексте:

String johnRegex = ".*John.*"; // it matches all strings containing the substring "John"

String textWithJohn = "My friend John is a computer programmer";

textWithJohn.matches(johnRegex); // true

String john = "John";

john.matches(johnRegex); // true

String textWithoutJohn = "My friend is a computer programmer";

textWithoutJohn.matches(johnRegex); // false

Таким образом, квантор звезды можно использовать для проверки соответствия подстроки строки шаблону. Используя его, мы можем пропустить пробелы или 
любые другие символы, которые мы не хотим указывать в нашем шаблоне.

Оба предыдущих квантора имеют широкий спектр применений, но они не позволяют указать, сколько раз символ может быть повторен. К счастью, существует 
группа кванторов, которые позволяют указать количество повторений в фигурных скобках: {n}, {n,m}, {n,}.

Важное уточнение: внутри фигурных скобок не должно использоваться пробелов. Там может быть только одно или два числа и, по желанию, запятая. Помещение 
пробелов в фигурные скобки приводит к "деактивации" квантора и, как следствие, к совершенно другому регулярному выражению. Например, "a{1, 2}" будет 
соответствовать только точной строке "a{1, 2}", а не "a" или "aa".

Взгляните на пример, где мы демонстрируем, как точно сопоставить n повторений предыдущего символа с помощью квантора {n} :

String regex = "[0-9]{4}"; // four digits

"6342".matches(regex);  // true
"9034".matches(regex);  // true

"182".matches(regex);   // false
"54312".matches(regex); // false

Сопоставление от n до m повторений возможно благодаря квантору {n,m}. Обратите внимание, что диапазон, указанный в фигурных скобках, начинается и 
заканчивается включительно: m встреченных повторений также считается совпадением. Это стандартно для языка регулярных выражений независимо от реализации, 
хотя это может показаться немного нелогичным для пользователей Java, поскольку диапазоны Java заканчиваются исключительно.

String regex = "1{2,3}";

"1".matches(regex);    // false
"11".matches(regex);   // true
"111".matches(regex);  // true
"1111".matches(regex); // false

В последнем примере показано, как сопоставить как минимум n повторений с помощью квантора {n,}:

String regex = "ab{4,}";

"abb".matches(regex); // false, not enough 'b'
"abbbb".matches(regex); // true
"abbbbbbb".matches(regex); // true

Квантификатор, который соответствует не более чем m повторениям, работает аналогично.

================================================================Regexes in programs=======================================================================
Регулярные выражения имеют очень широкую область применения. Они используются в текстовых редакторах и в реализациях языков программирования, для 
синтаксического анализа и подсветки синтаксиса, для извлечения полезной информации из файлов и веб-сайтов. В этом уроке мы хотели бы показать вам 
пример простой, но мощной программы, использующей регулярное выражение для обработки строк.

Давайте рассмотрим программу, которая проверяет, является ли входная строка допустимым логином. Мы предполагаем, что логин может содержать любую 
латинскую букву, число, символ подчеркивания _ и знак доллара $. Длина должна быть не менее 5 символов и не более 12 символов. //s*[a-zA-Z0-9_$]{5,12}//s*

Есть еще одна особенность: мы должны игнорировать все пробелы в начале и конце входной строки.

import java.util.Scanner;

class CheckLoginProblem {

    public static void main(String[] args) {

       /* The scanner object to read data from the standard input */
       Scanner scanner = new Scanner(System.in);
       
       /* The common pattern for valid logins */
       String loginRegex = "\\s*[a-zA-Z0-9_$]{5,12}\\s*";

       /* The read string which may be a login */
       String mayBeLogin = scanner.nextLine();

       boolean isLogin = mayBeLogin.matches(loginRegex);

       System.out.println(isLogin);
    }
}

Помните, что регулярное выражение "\\s*" является очень полезным практическим инструментом для поиска пробелов. Предпочтительнее использовать 
это сокращение вместо прямого ввода " ".

Проверяет пароль на то, чтобы в нём была как минимум одна заглавная и одна прописная буква, одна цифра, длин пароля минимум 12 символов

 Scanner scanner = new Scanner(System.in);
        String in = scanner.nextLine();

        String regex1 = ".*[a-z]+.*";
        String regex2 = ".*[A-Z]+.*";
        String regex3 = ".*[0-9]+.*";
        String regex4 = "............+";

        if (in.matches(regex1) && in.matches(regex2) && in.matches(regex3) && in.matches(regex4)) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
        }

============================================================Patterns and Matcher======================================================
Библиотека классов Java имеет два специальных класса, обладающих расширенными функциями для работы с регулярными выражениями: 
java.util.regex.Pattern и java.util.regex.Matcher. Объект Matcher предоставляет нам множество полезных методов для обработки регулярных 
выражений, в то время как объект Pattern представляет собой само регулярное выражение.

Предположим, у нас есть текст, хранящийся в строковой переменной:

String text = "We use Java to write modern applications";

Мы хотим использовать регулярное выражение, чтобы проверить, содержит ли текст подстроки "Java" или "java". Мы можем выполнить это в 
три простых шага с помощью классов Pattern и Matcher.

1. Создайте объект класса Pattern, передав строку регулярного выражения в метод compile():

Pattern pattern = Pattern.compile(".*[Jj]ava.*"); // regex to match "java" or "Java" in a text

2. Создайте Matcher, вызвав метод matcher() и создав объект для данной строки:

Matcher matcher = pattern.matcher(text); // it will match the passed text

3. Вызовите метод matches для сопоставления строки:

boolean matches = matcher.matches(); // true

Метод matches() класса Matcher работает точно так же, как метод matches() класса String, с которым мы уже знакомы.

На данный момент может показаться, что нет смысла в Pattern и Matcher классах, поскольку у нас уже есть простое представление 
регулярных выражений в виде строк. Однако есть две основные причины обратить внимание на эти классы:

1) Производительность. На самом деле метод matches класса String внутренне вызывает метод matches класса Matcher, но он также вызывает 
Pattern.compile(...) каждый раз, когда он выполняется. Это неэффективно. Если один и тот же шаблон используется несколько раз, его компиляция 
будет более разумной.

2) Богатый API. Класс Matcher может предложить больше, чем один метод matches(): существует множество полезных методов для обработки строк, 
а класс Pattern предоставляет нам возможность подробно настроить его, например, включить сопоставление без учета регистра.

Как вы знаете, класс Pattern используется для создания объекта класса Matcher. Однако, если мы не собираемся повторно использовать наше регулярное 
выражение, мы можем просто вызвать метод matches класса Pattern в одной строке.

Pattern.matches(".*[Jj]ava.*", "We use Java to write modern applications"); // true

Это похоже на вызов метода matches класса String, но имеет ту же проблему с производительностью.

Рассмотрим предыдущий пример еще раз. Он не может соответствовать таким словам, как "JAVA", потому что он не игнорирует регистр, как это делают все 
регулярные выражения по умолчанию. К счастью, есть специальный режим Pattern.CASE_INSENSITIVE, который может быть установлен во время компиляции шаблона. 
Это позволяет вашему регулярному выражению сопоставлять строки без учета регистра.

Pattern pattern = Pattern.compile(".*java.*", Pattern.CASE_INSENSITIVE);

String text = "We use Java to write modern applications";

Matcher matcher = pattern.matcher(text);

System.out.println(matcher.matches()); // true

Еще один режим, который вы, возможно, захотите запомнить, - это Pattern.DOTALL, который делает метасимвол точки . соответствующим всем символам, включая 
переход на новую строку \n.

Режим без учета регистра доступен даже без класса Matcher. Вам просто нужно добавить (?i) в начале вашего регулярного выражения. Чтобы символ точки 
соответствовал символу новой строки, добавьте (?s). Вы можете включить оба режима, написав(?is).

Взгляните, как это работает:

Pattern.matches("(?is).*java.*", "\n\nJAVA\n\n"); // true

Экземпляр Matcher предоставляет нам любопытные методы для сопоставления шаблонов и строк. В этом уроке мы рассмотрим только один из них.

Так же, как метод matches класса String, метод matches класса Matcher возвращает true только тогда, когда шаблон соответствует всей строке, в противном 
случае он возвращает false. Это не очень удобно в некоторых ситуациях, верно? Например, если мы хотим проверить, есть ли где-то в нашем тексте 
определенная подстрока, мы должны добавить .* в начале и в конце шаблона.

Благодаря классу Matcher мы также можем применить метод find(). Он похож на метод matches() , но вместо того, чтобы проверять совпадение со всей строкой, 
он пытается найти подстроку, соответствующую шаблону. Посмотрите на следующий пример, чтобы понять разницу между этими методами:

String text = "Regex is a powerful tool for programmers";

Pattern pattern = Pattern.compile("tool");
Matcher matcher = pattern.matcher(text);

System.out.println(matcher.matches()); // false, the whole string does not match the pattern
System.out.println(matcher.find()); // true, there is a substring that matches the pattern

Помните пограничные символы(\b), которые мы изучали раньше? Они могут быть применены для изменения поведения метода find, чтобы сделать его работу 
несколько похожей на метод matches. Чтобы убедиться, что метод find будет соответствовать подстроке, расположенной в начале строки, мы можем добавить 
символ шляпы ^ в начале регулярного выражения. Чтобы он соответствовал подстроке в конце строки, мы можем добавить символ доллара $ в конце регулярного 
выражения. Комбинируя эти символы, мы делаем из найденной копии совпадения:

Pattern pattern = Pattern.compile("^tool$");
Matcher matcher = pattern.matcher(text);

System.out.println(matcher.matches()); // false
System.out.println(matcher.find());   // false 

По умолчанию оба метода matches() и find() работают со всей строкой. Однако можно сузить их область, вызвав метод range, который позволяет нам указать 
первый (инклюзивный) и последний (эксклюзивный) индексы подстроки, которые мы хотим, чтобы наши методы рассматривали.

=====================================================================Match results========================================================================
Простая проверка того, содержит ли строка подстроку, соответствующую нашему регулярному выражению, - это не единственное, что мы можем сделать с 
Matcher object. Он также предоставляет нам дополнительную информацию о соответствиях, которая необходима в некоторых задачах.

Как вы знаете, метод find() класса Matcher может проверить, соответствует ли подстрока строки шаблону. Вот пример:

String javaText = "Java supports regular expressions. LET'S USE JAVA!!!";

Pattern javaPattern = Pattern.compile("java", Pattern.CASE_INSENSITIVE);
Matcher matcher = javaPattern.matcher(javaText);

System.out.println(matcher.find()); // prints "true"

Когда метод find() возвращает true, можно получить некоторую информацию о подстроке, соответствующей шаблону. start() и end() возвращают начальный и 
последний индексы совпадения соответственно, в то время как group() возвращает саму совпадающую подстроку.

System.out.println(matcher.start()); // 0, the starting index of match
System.out.println(matcher.end());   // 4, the index followed the last index of match
System.out.println(matcher.group()); // "Java", a substring that matches the pattern

Существует специальный class MatchResult, который содержит всю эту информацию:

MatchResult result = matcher.toMatchResult(); // a special object containing match results
        
System.out.println(result.start()); // 0
System.out.println(result.end());   // 4
System.out.println(result.group()); // "Java"

Будьте осторожны, если вы вызовете методы start, end, group перед вызовом метода find() или в случае, если он был вызван и вернул false, они вызовут 
исключение IllegalStateException. Чтобы избежать исключения, вы всегда должны проверять логический результат функции find() перед вызовом этих методов.

if (matcher.find()) {
    System.out.println(matcher.start());
    System.out.println(matcher.end());
    System.out.println(matcher.group());
} else {
    System.out.println("No matches found");
}

Иногда более одной подстроки соответствует одному и тому же шаблону. В предыдущем примере есть две подходящие строки "Java" и "JAVA", поскольку шаблон 
не учитывает регистр. Метод find() позволяет нам перебирать в цикле все подстроки, соответствующие шаблону.

String javaText = "Java supports regular expressions. LET'S USE JAVA!!!";

Pattern javaPattern = Pattern.compile("java", Pattern.CASE_INSENSITIVE);
Matcher matcher = javaPattern.matcher(javaText);

while (matcher.find()) {
    System.out.println("group: " + matcher.group() + ", start: " + matcher.start());
}

Этот код выводит следующие строки:

group: Java, start: 0
group: JAVA, start: 45

================================================================Replacing characters=======================================================================
Иногда нам может потребоваться заменить подстроку другой строкой. Java предоставляет нам несколько удобных методов для этого, и регулярные выражения 
играют важную роль в этом процессе.

Существует два метода строк для замены подстрок:

1) String replaceFirst(String regex, String replacement)
заменяет первое вхождение regex в строке на replacement

2) String replaceAll(String regex, String replacement)
заменяет все вхождения regex в строке на replacement

где
regex-это регулярное выражение, соответствующее подстрокам, которые должны быть заменены;
replacement-это строка, которая заменит подстроку, соответствующую регулярному выражению (это должна быть просто строка, а не регулярное выражение!).

Поскольку строки являются неизменяемыми объектами, оба метода возвращают новую строку с необходимыми изменениями.

Будьте осторожны, метод replace выполняет аналогичную операцию, но НЕ поддерживает регулярные выражения.

String digitRegex = "\\d"; // a regex to match a digit

String str = "ab73c80abc9"; // a string consisting of letters and digits

String result1 = str.replaceAll(digitRegex, "#"); // it replaces each digit with #

System.out.println(result1); // "ab##c##abc#"

String result2 = str.replaceFirst(digitRegex, "#"); // it replaces only the first digit with #

System.out.println(result2); // "ab#3c80abc9"

В качестве первого аргумента этих методов можно использовать любое регулярное выражение. В следующем примере показано, как заменить все 
последовательности прописных латинских букв в строке одним символом тире.

String regex = "[A-Z]+";

String str = "aBoeQNmDFEFu";

String result = str.replaceAll(regex, "-"); // "a-oe-m-u"

Однако класс Matcher имеет те же методы. Давайте быстро взглянем на них.

Объект Matcher также имеет два метода для замены подстроки, найденной с помощью регулярного выражения:

Matcher replaceFirst(String replacement);
Matcher replaceAll(String replacement).

Разница между строковыми методами и этими заключается в том, что методы класса Matcher не принимают регулярные выражения в качестве аргументов: 
любой объект класса Matcher получает свое регулярное выражение при инициализации. См. Пример ниже.

Pattern pattern = Pattern.compile("\\d"); // a regex to match a digit

String str = "ab73c80abc9"; // a string consisting of letters and digits

Matcher matcher = pattern.matcher(str);

System.out.println(matcher.replaceAll("#"));   // ab##c##abc#
System.out.println(matcher.replaceFirst("#")); // ab#3c80abc9

=========================================================Boxing and unboxing===================================================================
Каждый примитивный тип имеет класс, посвященный ему. Эти классы известны как оболочки(wrappers), и они immutable (как и String). Классы обертки 
могут использоваться в различных ситуациях:
- когда переменная может быть null (отсутствие значения);
- когда вам нужно хранить значения в общих коллекциях (будет рассмотрено в следующих разделах);
- когда вы хотите использовать специальные методы этих классов.

Primitive		Wrapper Class		Constructor Argument
boolean			Boolean			boolean or String
byte			Byte			byte or String
char			Character		char
int			Integer			int or String
float			Float			float, double or String
double			Double			double or String
long 			Long 			long or String		
short			Short			short or String

Как вы можете видеть, Java предоставляет восемь классов-оболочек: по одному для каждого примитивного типа. В третьем столбце 
показан тип аргумента, необходимый для создания объекта соответствующего классу-оболочке.

Boxing - это преобразование примитивных типов в объекты соответствующих классов-оболочек. Unboxing - это обратный процесс. 
Следующий код иллюстрирует оба процесса:

int primitive = 100;
Integer reference = Integer.valueOf(primitive); // boxing
int anotherPrimitive = reference.intValue();    // unboxing

Autoboxing и auto-unboxing-это автоматические преобразования, выполняемые компилятором Java.

double primitiveDouble = 10.8;
Double wrapperDouble = primitiveDouble; // autoboxing
double anotherPrimitiveDouble = wrapperDouble; // auto-unboxing

Вы можете смешивать как автоматические, так и ручные процессы упаковки/распаковки в своих программах.

Autoboxing работает только тогда, когда левая и правая части задания имеют один и тот же тип. 
В других случаях вы получите ошибку компиляции.

Long n1 = 10L; // OK, assigning long to Long
Integer n2 = 10; // OK, assigning int to Integer 

Long n3 = 10; // WRONG, assigning int to Long
Integer n4 = 10L; // WRONG assigning long to Integer

Классы-оболочки имеют конструкторы для создания объектов из других типов. Например, объект класса-оболочки может быть 
создан из String (за исключением класса Character).

Integer number = new Integer("10012"); // an Integer from "10012"
Float f = new Float("0.01");           // a Float from "0.01"
Long longNumber = new Long("100000000"); // a Long from "100000000"
Boolean boolVal = new Boolean("true");   // a Boolean from "true"

Вы также можете создавать объекты-оболочки с помощью специальных методов:

Long longVal = Long.parseLong("1000");      // a Long from "1000"
Long anotherLongVal = Long.valueOf("2000"); // a Long from "2000"

Если входная строка имеет недопустимый аргумент (например, "1d0o3"), оба этих метода вызывают исключение NumberFormatException.

Обратите внимание, что начиная с Java 9 конструкторы устарели. Вы должны использовать специальные методы для создания объектов классов-оболочек.

Как и для любого ссылочного типа, оператор == проверяет, действительно ли два объекта-оболочки равны, т. Е. Ссылаются ли они на один 
и тот же объект в памяти. С другой стороны , метод equals проверяет, являются ли два объекта-оболочки значимо равными, например, он 
проверяет, имеют ли две оболочки или строки одинаковое значение.

Long i1 = Long.valueOf("2000");
Long i2 = Long.valueOf("2000");
System.out.println(i1 == i2);      // false
System.out.println(i1.equals(i2)); // true

Существует одна возможная проблема при распаковке. Если объект-оболочка имеет значение null, распаковка вызывает исключение NullPointerException.

Long longVal = null;
long primitiveLong = longVal; // It throws NPE

Чтобы исправить это, мы можем добавить условный оператор, который создает значение по умолчанию:

long unboxed = val != null ? val : 0; // No NPE here

Этот код не создает исключения.

Другим примером являются арифметические операции с Integer, Long, Double и другими типами числовых оболочек. Они могут вызвать NPE, 
так как происходит автоматическая распаковка.

Integer n1 = 50;
Integer n2 = null;
Integer result = n1 / n2; // It throws NPE

В этом разделе мы рассмотрели классы-оболочки для примитивных типов данных. Классы-оболочки позволяют нам представлять примитивные 
типы в виде объектов, которые являются ссылочными типами данных.

Вот несколько важных моментов, которые следует иметь в виду:
- обработка значений примитивных типов выполняется быстрее, чем обработка объектов-оболочек;
- обертки можно использовать, когда вам нужен null в качестве индикатора отсутствия значения;
- примитивные типы не могут использоваться в стандартных коллекциях (например, списках, наборах или других), но обертки могут.

===============================================Introduction to generic programming===================================================
Существуют ситуации, когда методы и классы не зависят от типов данных, с которыми они работают. Например, алгоритм поиска элемента в 
массиве может обрабатывать массивы строк, целых чисел или пользовательских классов. Не имеет значения, что хранится в массиве: 
алгоритм всегда один и тот же. Тем не менее, мы не можем написать этот алгоритм как единый метод, потому что он требует разных 
аргументов (int[], String[] и т. Д.).

Начиная с версии 5, Java поддерживает generic программирование, которое вводит абстракцию над типами. Общие методы и классы могут 
обрабатывать различные типы одним и тем же общим способом. Конкретный тип определяется только тогда, когда разработчик создает объект 
класса или вызывает метод. Такой подход позволяет нам писать более абстрактный код и разрабатывать многоразовые библиотеки программного 
обеспечения. Давайте рассмотрим это шаг за шагом, используя примеры, написанные на Java.

generic тип-это generic класс (или интерфейс), который параметризуется по типам. Чтобы объявить generic класс, мы должны объявить класс 
с разделом параметров типа, разделенным угловыми скобками после имени класса.

В следующем примере класс GenericType имеет один параметр типа с именем T. Мы предполагаем, что тип T является "некоторым типом", и пишем 
тело класса независимо от конкретного типа.

class GenericType<T> { 

    /**
     * A field of "some type"
     */
    private T t;

    /**
     * Takes a value of "some type" and set it to the field
     */
    public GenericType(T t) {
        this.t = t;
    }

    /**
     * Returns a value of "some type"
     */
    public T get() {
        return t;
    }

    /**
     * Takes a value of "some type", assigns it to a field and then returns it
     */
    public T set(T t) {
        this.t = t;
        return this.t;   
    }
}

После объявления параметр типа может использоваться внутри тела класса как обычный тип. Например, в приведенном выше 
примере параметр типа T используется как:

- тип поля 
- тип аргумента конструктора 
- аргумент метода экземпляра и тип возвращаемого значения

Поведение обоих методов экземпляра не зависит от конкретного типа T; он может принимать/возвращать строку или число одним 
и тем же способом.

Класс может иметь любое количество параметров типа. Например, в следующем классе их три.

class Three<T, U, V> {
    T t;
    U u;
    V v;
}

Но большинство generic классов имеют только один или два параметра типа.

Существует соглашение об именовании, которое ограничивает выбор имени параметра типа отдельными прописными буквами. 
Без этого соглашения было бы трудно определить разницу между переменной типа и обычным именем класса.

T – Type
S, U, V etc. – 2nd, 3rd, 4th types
E – Element (used extensively by different collections)
K – Key
V – Value
N – Number

Чтобы создать объект универсального класса (стандартного или пользовательского), мы должны указать аргумент типа после имени типа.

GenericType<Integer> obj1 = new GenericType<Integer>(10);

GenericType<String> obj2 = new GenericType<String>("abc");

Важно отметить, что аргумент типа должен быть ссылочным типом. Примитивные типы, такие как int или double, являются недопустимыми 
аргументами типа.

Java 7 позволила заменить аргументы типа, необходимые для вызова конструктора generic класса, пустым набором аргументов типа, если 
компилятор может вывести аргументы типа из контекста.

GenericType<Integer> obj1 = new GenericType<>(10);

GenericType<String> obj2 = new GenericType<>("abc");

The pair of angle brackets <> is informally called the diamond operator.

Иногда объявление переменной с generic типом может быть длительным и трудным для чтения. К счастью, мы можем написать var вместо 
определенного типа, чтобы заставить автоматический вывод типа на основе типа присвоенного значения.

var obj3 = new GenericType<>("abc");

После того, как мы создали объект с указанным аргументом типа, мы можем вызвать методы класса, которые принимают или возвращают параметр типа:

Integer number = obj1.get(); // 10
String string = obj2.get();  // "abc"

System.out.println(obj1.set(20));    // prints the number 20
System.out.println(obj2.set("def")); // prints the string "def"

Если класс имеет несколько параметров типа, мы должны указать их все при создании экземпляров:

GenericType<Type1, Type2, ..., TypeN> obj = new GenericType<>(...);

В качестве более сложного примера рассмотрим следующий класс, представляющий общий immutable массив. В нем есть одно поле для хранения элементов 
типа T, конструктор для установки элементов, метод для получения элемента по его индексу и другой метод для получения длины внутреннего массива. 
Класс является immutable, поскольку он не предоставляет методов для изменения массива элементов.

public class ImmutableArray<T> {

    private T[] items;

    public ImmutableArray(T[] items) {
        this.items = items;
    }

    public T get(int index) {
        return items[index];
    }

    public int length() {
        return items.length;
    }
}

Этот класс показывает, что generic класс может иметь методы (например, length), которые вообще не используют тип параметра.

Следующий код создает экземпляр ImmutableArray для хранения трех строк, а затем выводит элементы в стандартный вывод.

var stringArray = new ImmutableArray<>(new String[] {"item1", "item2", "item3"});

for (int i = 0; i < stringArray.length(); i++) {
    System.out.print(stringArray.get(i) + " ");
}

Можно параметризовать ImmutableArray с любым ссылочным типом, включая массивы, стандартные классы или ваши собственные классы.

var doubleArray = new ImmutableArray<>(new Double[] {1.03, 2.04});

MyClass obj1 = ..., obj2 = ...; // suppose, you have two objects of your custom class

var array = new ImmutableArray<>(new MyClass[] {obj1, obj2});

В приведенных выше примерах мы использовали var для экономии места. Вместо использования var мы могли бы явно указать тип, 
например, ImmutableArray<String> stringArray = ...; и так далее.

================================================Generics and Object============================================================
Как вы знаете, Generics позволяют нам параметризовать типы при определении классов (или интерфейсов) и методов. Параметризованные 
типы позволяют повторно использовать один и тот же код при обработке различных конкретных типов.

Давайте рассмотрим универсальный класс с именем GenericType, который хранит значение "some type".

class GenericType<T> { 

    private T t;

    public GenericType(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }
}

Можно создать объект с конкретным типом (например, String):

GenericType<String> instance1 = new GenericType<>("abc");
String str = instance1.get();

Мы также можем создавать экземпляры с другими типами (Integer, Character), а затем вызывать метод get для доступа к внутреннему 
полю. Таким образом, дженерики позволяют нам использовать один и тот же класс и методы для обработки разных типов.

Но есть и другой способ повторного использования кода. Если мы объявим поле типа Object, мы можем присвоить ему значение любого 
ссылочного типа. Этот подход широко использовался до появления дженериков в Java 5.

Следующий класс демонстрирует эту концепцию:

class NonGenericClass {

    private Object val;

    public NonGenericClass(Object val) {
        this.val = val;
    }

    public Object get() {
        return val;
    }
}

Теперь мы можем создать экземпляр этого класса с той же строкой, что и в предыдущем примере (см. GenericType).

NonGenericClass instance2 = new NonGenericClass("abc");

Также можно создать экземпляр, передав значение типа Integer, Character или любого другого ссылочного типа.

Использование класса Object таким образом позволяет нам повторно использовать один и тот же класс для хранения различных типов данных.

После вызова метода get() мы получаем Object, а не String или Integer. Мы не можем получить строку непосредственно из метода.

NonGenericClass instance2 = new NonGenericClass("abc");
String str = instance2.get(); // Compile-time error: Incompatible types

Чтобы вернуть строку, мы должны выполнить явное приведение типа к классу String.

String str = (String) instance2.get(); // "abc"

Это работает, потому что строка была передана в instance2. Но что, если экземпляр хранит не строку, а число? В этом случае код создает исключение. 
Вот пример:

NonGenericClass instance3 = new NonGenericClass(123);
String str = (String) instance3.get(); // throws java.lang.ClassCastException

Теперь мы видим главное преимущество дженериков перед классом Object. Поскольку нет необходимости выполнять явное приведение типов, мы никогда не 
получаем исключения во время выполнения. Если мы делаем что-то не так, мы можем увидеть это во время компиляции.

GenericType<String> instance4 = new GenericType<>("abc");
        
String str = instance4.get(); // There is no type-casting here
Integer num = instance4.get(); // It does not compile

Ошибка во время компиляции будет обнаружена программистом, а не пользователем программы. Поскольку дженерики позволяют 
компилятору заботиться о приведении типов, дженерики являются более безопасными и гибкими по сравнению с классом Object.

При создании экземпляра универсального класса у вас есть возможность вообще не указывать тип аргумента.

GenericType instance5 = new GenericType("my-string");

В этом случае полем класса является Object, и метод get также возвращает Object.

Приведенный выше код эквивалентен следующей строке:

GenericType<Object> instance5 = new GenericType<>("abc"); // it is parameterized with Object

Обычно вы не будете использовать универсальные параметры, параметризованные типом Object, из-за тех же проблем, что и выше. 
Просто помните, что такая возможность существует.

==================================================Generic methods==============================================================
В предыдущих разделах мы обсуждали Generic классы и то, как их можно использовать. Но в Java также есть Generic методы, которые 
могут быть очень полезны. Универсальные методы позволяют передавать параметры типа в метод и использовать их в его логике. Они 
также позволяют параметру типа быть возвращаемым типом.

Все методы могут объявлять свои собственные параметры типа, независимо от класса, к которому они принадлежат. Это означает, что 
non-generic класс может содержать generic методы.

Статические методы не могут использовать параметры типа своего класса! Параметры типа класса, к которому принадлежат эти методы, 
могут использоваться только в методах экземпляра. Если вы хотите использовать параметры типа в статическом методе, объявите 
собственные параметры типа этого метода.

Следующий статический метод объявлен как универсальный. Мы напоминаем вам, что он может принадлежать к универсальному или не 
универсальному классу, поскольку это не имеет значения для универсальных методов.

public static <T> T doSomething(T t) {
    return t;
}

Параметр типа T может использоваться для объявления типа возвращаемого значения и типа аргументов метода. Универсальный метод 
также может принимать или возвращать значения не универсальных типов. Например, следующий метод берет универсальный массив и 
возвращает его размер в виде int.

public static <E> int length(E[] array) {
    return array.length;
}

Тело универсального метода объявляется так же, как и тело любого другого метода.

Мы можем передать массив целых чисел в метод, который мы определили ранее, и найти его длину:

Integer[] array = { 1, 2, 3, 4 };
int len = length(array); // pass an array of Integers

Мы могли бы использовать этот же метод для определения длины массива строк (или любого другого ссылочного типа).

String[] stringArray = { "a", "b", "c", "d" };
len = length(stringArray); 

В качестве еще одного примера универсального метода рассмотрим метод, который печатает элементы универсального массива.

public static <E> void print(E[] array) {
    for (int i = 0; i < array.length; i++) {
        System.out.print(array[i] + " ");
    }
    System.out.println();
}

Давайте создадим массив и распечатаем его с помощью этого метода.

Character[] characters = { 'a', 'b', 'c' };
print(characters);

The output will be:

a b c 

Как и в универсальных классах, раздел параметров типа может содержать несколько параметров типа, разделенных запятыми.

public static <T, U> void method(T t, U u) {
    // do something
}

Статические универсальные методы часто используются для написания универсальных алгоритмов, которые не зависят от типа, 
с которым они работают. Это может быть удобно, когда метод должен использоваться независимо от класса, к которому он 
принадлежит. Мы часто используем общие статические методы для различных операций с массивами и коллекциями: сортировка 
массива, поиск значения в коллекции, реверсирование массива и так далее.

Как и статические методы, методы экземпляра могут иметь свои собственные параметры типа. Нет никакой разницы в их 
объявлении по сравнению со статическими методами, за исключением отсутствия ключевого слова static.

class SimpleClass {
 
    public <T> T getParameterizedObject(T t) {
        return t;
    }
}

Класс выше не предоставляет параметр типа, поэтому мы должны указать параметр типа в его объявлении, чтобы сделать метод 
getParameterizedObject универсальным.

Обратите внимание, что в этом примере мы не можем использовать T в качестве типа для поля в классе, поскольку оно принадлежит 
методу, а не самому классу.

Теперь мы можем создать экземпляр класса и вызвать метод. Он вернет значение того же типа, что и переданное значение.

SimpleClass instance = new SimpleClass();
Integer value = instance.getParameterizedObject(601); // this will return 601

Хотя универсальные методы могут принадлежать к классам, не являющимся универсальными, более распространено, чтобы универсальный 
метод принадлежал классу, который также является универсальным. Ниже приведен пример универсального класса, содержащего 
универсальный метод экземпляра.

class SimpleClass<T> {
 
    public <U> T getParameterizedObject(T t, U u) {
        return t;
    }
}

Метод получает аргументы как типа класса (T), так и собственного типа метода (U). Поскольку T уже был объявлен в заголовке класса, 
метод должен объявить только универсальный тип U. Метод возвращает переменную типа T.

=====================================================Type Bounds===============================================================
В предыдущих статьях мы упоминали, что дженерики могут принимать любой тип параметра и позволяют повторно использовать некоторый код. 
Давайте теперь рассмотрим пример, который раскроет еще один аспект дженериков. Представьте, что у нас есть универсальный класс 
Storege<T>, который может содержать объекты любого класса. Но есть некоторые ситуации, когда мы хотим ограничить эти объекты. 
Мы можем сказать, например, что хранилище должно содержать только книги. В таких ситуациях мы должны использовать границы типов.

Давайте подробнее рассмотрим границы типов. Рассмотрим этот код:

class Storage<T> {
    private T nameOfElements;
    //other methods
}

Мы можем поместить любой тип объекта в Storage<T>. Как уже говорилось ранее, мы хотели бы ограничить этот класс возможностью хранения 
только книг. Давайте предположим, что у нас есть класс Books для представления всех книг. Затем мы можем реализовать наше ограничение, 
добавив <T extends Books>:

class Storage<T extends Books> {
    private T nameOfElements;
    //other methods
}

Let us create three classes:

public class Books { }
public class Brochures extends Books { }
public class Computers { }

Now creating three Storage objects will lead to different results:

Storage<Books> storage1 = new Storage<>(); //no problem
Storage<Brochures> storage2 = new Storage<>(); //no problem
Storage<Computers> storage3 = new Storage<>(); //a compile-time error

Первые две строки будут скомпилированы без проблем. Третий, однако, вернет ошибку:
Type parameter 'Computers' is not within its bound; should extend Books.
Поскольку это ошибка времени компиляции, мы улавливаем эту проблему до того, как она может появиться в реальном приложении. 
По этой причине границы типов безопасны в использовании.

Обратите внимание, что extends может означать не только расширение определенного класса, но и реализацию интерфейса. Вообще говоря, 
это слово используется в качестве замены для расширения обычных классов, а не универсальных классов. Попытка расширить универсальный 
класс (например, Storage<Brochures> extends Storage<Books>) приведет к ошибке.

Ограничение типа включает в себя два ключевых слова: "extends" и "super", каждое из которых имеет свои собственные правила, регулирующие 
их использование. Однако в этом разделе мы рассмотрим наиболее распространенное использование границ типов: установка верхней границы с 
помощью ключевого слова "extends". Мы узнаем больше о принципах, лежащих в основе этих ключевых слов, в разделе "Wildcards".

Обратите внимание, что под капотом каждая переменная типа, объявленная в качестве параметра типа, имеет привязку. Если привязка не объявлена, 
привязкой является Object. По этой причине,

class SomeClass<T> {...}
is equivalent to

class SomeClass<T extends Object> {...}

Переменная типа может иметь одну привязку типа:

<T extends A>

или иметь несколько границ:

<T extends A & B & C & ...>

Первая привязка типа ("A") может быть классом или интерфейсом. Остальные границы типа ("B" и далее) должны быть интерфейсами.

Примечание: если T имеет привязку, которая является классом, этот класс должен быть указан первым! В противном случае возникает ошибка времени компиляции:

<T extends B & C & A & ...> //an error if A is a class

========================================================Wildcards========================================================================================
Ранее, когда мы обсуждали границы типов, мы упоминали Wildcards как функцию, которая служит аналогичной цели и имеет широкое применение.
Wildcards-это специфический инструмент Java, который позволяет реализовать некоторую совместимость между различными универсальными объектами. По сути, 
Wildcards-это знак "?", используемый для указания того, что класс, метод или поле совместимы с различными параметрами типа.

Как объектно-ориентированный язык, Java опирается на концепцию наследования. Но поскольку универсальные типы являются типобезопасными структурами, 
невозможно ввести наследование для универсальных объектов.

Чтобы проиллюстрировать эту проблему, рассмотрим два класса:

class Book {}
class Album extends Book {}

Мы могли бы предположить, что список альбомов можно рассматривать как список книг, поскольку Album-это подкласс Book. Но компилятор думает иначе:

List<Album> albums = new ArrayList<>();
List<Book> books = albums; // compile-time error

Корень проблемы заключается в том, что List<Album> не является подклассом List<Book>: наследование не применяется к общим классам. Такое поведение 
известно как инвариантность. Не имеет значения, что альбом расширяет Книгу, потому что контейнеры, такие как List<T>, Set<T> и другие, 
рассматриваются как независимые классы.

В приведенном выше примере могут помочь wildcards. Универсальный класс или метод, объявленный с помощью wildcards, может избежать проблем с наследованием. 
Для реализации wildcards используйте "?" в угловых скобках (<?>). Давайте используем его для устранения ошибки компилятора:

List<Album> albums = new ArrayList<>();
List<? extends Book> albumsAndBooks = albums; // it is ok

List<Album> albums = new ArrayList<>();
List<? super Album> albumsAndBooks = albums; // it is ok as well

Since wildcards are used with type bounding, they can be divided into three groups: unbounded wildcards, upper bounded wildcards, and lower bounded ones.

Верхние границы wildcars используются, когда мы хотим установить верхнюю границу. Он задается с помощью ключевого слова extends:

<? extends ReferenceType>

Этот код можно прочитать как "любой тип, который является подтипом ReferenceType". Другими словами, если S является подтипом T, то тип List<S> считается 
подтипом List<? extends T>. Эта особенность известна как ковариация.

Предположим, что наша программа представляет собой библиотеку, в которой мы хотим хранить только различные типы книг: обычные книги, буклеты, фотоальбомы 
и так далее. Как бы мы избежали хранения других типов носителей, таких как аудиозаписи? Допустим, у нас есть еще два класса:

public class Booklet extends Book {}
public class AudioFile {}

Мы можем использовать wildcards для создания списка, в котором хранятся только различные типы книг:

List<? extends Book> storage = new ArrayList<>();

List<Album> albums = new ArrayList<>();
storage = albums; // it works, Album is a subtype of Book

List<Booklet> booklets = new ArrayList<>();
storage = booklets; // it works, Booklet is a subtype of Book

List<AudioFile> recordings = new ArrayList<>();
storage = recordings; // compile-time error, AudioFile is not a subtype of Book

Используя wildcards с верхней границей, мы убедились, что переменная storage может быть установлена только для подтипов Book.

Теперь давайте рассмотрим еще одно ограничение верхней границы.

/**
* Hierarchy: Book -> Album
*                 -> Booklet
* Allowed types: List<Book>, List<Album>, List<Booklet>
*/
public void upperBoundedMethod(List<? extends Book> books) {
    Book book = books.get(0); // It is fine

    books.add(new Album()); // compile-time error
    books.add(new Book());  // compile-time error
    books.add(null); // also fine, because of null is a special type-independent value
}

Удивительно, но некоторые строки upperBoundedMethod не будут компилироваться. Верхние wildcards могут считывать содержимое как 
тип книги, но они не могут записывать любое содержимое, кроме нулевого значения.

Давайте объясним логику, лежащую в основе этих разрешений на чтение и запись. Поскольку метод принимает списки, параметризованные 
классом Book или любым из ее подтипов (List<Books>, List<Album> or List<Booklet>), любой аргумент может быть прочитан как объект 
типа Книга. Однако запись в wildcard аргумент запрещена, чтобы избежать ошибок во время выполнения. Чтобы понять, почему, предположим, 
что был передан List<Album>, но затем мы попытаемся добавить экземпляр Book в этот список. В будущем этот объект Book будет рассматриваться 
как объект Album, что, скорее всего, приведет к runtime error.

Нижние wildcards вводятся с ключевым словом super, за которым следует нижняя граница:

<? super ReferenceType>

Это означает "любой тип, который является супертипом ссылочного типа". Например, если S является супертипом T, то List<S> считается 
супертипом List<? super T>. Эта особенность называется контравариантностью.

Давайте снова подумаем о книгах. Теперь мы хотели бы написать код, который позволит добавить список Albums и их суперклассы в общую библиотеку.

List<? super Album> storage = new ArrayList<>();

List<Album> albums = new ArrayList<>();
storage = albums; // it works

List<Book> books = new ArrayList<>();
storage = books; // it works, Book is a supertype for Album

List<Booklet> booklets = new ArrayList<>();
storage = booklets; // compile-time error, Booklet is not a supertype for Album

Здесь мы убедились, что в хранилище можно добавлять только супертипы класса Album.

Теперь давайте рассмотрим некоторые ограничения нижней границы.

/**
* Hierarchy: Album <- Book <- Object  
* Allowed types: List<Album>, List<Book>, List<Object>
*/
public void lowerBoundedMethod(List<? super Album> albums) {
    Object object = albums.get(0); // it is ok. Object is upper bound of Album
    Book book = albums.get(0);     // compile-time error
    Album album = albums.get(0);   // compile-time error

    albums.add(new Object()); // compile-time error
    albums.add(new Book());   // compile-time error
    albums.add(new Album());  // OK
    albums.add(null);         // OK, null is type-independent
}

Подобно wildcards с верхней границей, некоторые действия, связанные с wildcards с нижней границей, приводят к ошибкам во время компиляции. 
Поскольку любой из List<Album>, List<Book>, List<Object> может быть передан в метод lowerBoundedMethod, мы не можем утверждать, что 
считываемый объект имеет тип Album или Book. Мы можем быть уверены только в том, что он имеет тип Object, поскольку все классы наследуются от Object.

В то время как Object -это единственный тип, который можно прочитать из альбомов, Album-это единственный тип, который можно добавить. Причина в том, 
что только экземпляр Album может также рассматриваться как экземпляр Book и Object. Если бы мы попытались добавить экземпляр Book, в будущем этот экземпляр 
рассматривался бы как Album. Компилятор предотвращает такие ошибки, выдавая предупреждение во время компиляции.

Чтобы решить, следует ли использовать extends или super, стоит вспомнить принцип Get и Put:

1) Используйте верхние wildcards, когда вы получаете значения только из структуры (т. Е. Когда вы используете только геттеры или аналогичные методы).

2) Используйте нижние wildcards, когда вы только помещаете значения в структуру (т. Е. Когда вы используете только сеттеры или аналогичные методы).

3) Используйте неограниченные wildcards (просто <?>), когда вы одновременно получаете и помещаете значения (т. Е. Когда вам нужно использовать как геттеры, так и сеттеры).

Чтобы запомнить этот принцип, вы также можете использовать PECS: Producer Extends, Consumer Super. Это означает, что если вы получаете значение из универсального класса, 
метода или любого другого объекта, который создает то, что вам нужно, вы используете extends. Если вы помещаете или устанавливаете значение в универсальный класс, метод 
или любой другой объект, который потребляет то, что вы вводите, вы используете super.

Помните, что в тип, объявленный с помощью wildcard extends, невозможно поместить что-либо, кроме значения null, которое может представлять любой ссылочный тип. Аналогично, 
невозможно извлечь что-либо из типа, объявленного с помощью wildcards, за исключением экземпляра Object, родительского для каждого ссылочного типа.

Вы не можете использовать как нижнюю, так и верхнюю границу в wildcards или границах типов

Обратите внимание, что класс или интерфейс, используемый с ключевым словом extends или super, сам включается в наследование. Например, Box<T> совместим и ковариантен с 
Box<? extends T> or Box<? super T>.

Также обратите внимание, что неограниченный wildcard ? эквивалентно <? extends Object>.

Давайте рассмотрим пример:

public static void reverse(List<?> list) {
  List<Object> tmp = new ArrayList<Object>(list);
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(list.size() - i - 1)); // compile-time error
  }
}

Что вызывает ошибку во время компиляции? Напомним, что <?> эквивалентно <? extends Object>. Компилятор сигнализирует об ошибке, поскольку он не знает тип объекта, 
записываемого в список. Этот сценарий известен как проблема захвата wildcards и может быть решен с помощью трюка:

public static void reverse(List<?> list) { 
  reverseCaptured(list); 
}

private static <T> void reverseCaptured(List<T> list) {
  List<T> tmp = new ArrayList<T>(list);
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(list.size() - i - 1));
  }
}

Здесь мы ввели вспомогательный метод reverseCaptured, который имеет параметр определенного типа T для всех элементов списка. Метод безошибочен, потому что это просто 
универсальный метод; он не сталкивается с какими-либо ограничениями из-за wildcards.

==========================================================================Type Erasure===============================================================================
Дженерики были введены для реализации универсального программирования и управления безопасностью типов во время компиляции. Эта функция доступна с Java 5. Для 
поддержки обратной совместимости с предыдущими версиями Java информация об универсальных типах стирается компилятором. Мы рассмотрим, какие именно типы стираются в 
будущих темах.

Это означает, что во время выполнения все эти объекты будут иметь один и тот же тип:

// Generic types
List<Integer> integers = new List<>();
List<String> strings = new List<>();

// Raw type
List objects = new List();

The transformation process is called type erasure.

Прежде всего, стирание типов заменяет параметры универсальных типов их границами. Неограниченные типы заменяются Object классом. 
Это означает, что информация о типах стирается при переводе программы в байтовый код. В результате байтовый код содержит только 
обычные не универсальные классы и интерфейсы.

Давайте рассмотрим данные универсального класса Data:

class Data<T> {
    private T data;

    public T get() {
        return data;
    }

    public void set(T data) {
        this.data = data;
    }
}

Компилятор Java заменит параметр T на Object, поскольку T неограничен. Ниже приведен код, который фактически совпадает с Data<T> после компиляции:

class Data {
    private Object data;

    public Object get() {
        return data;
    }

    public void set(Object data) {
        this.data = data;
    }
}

Теперь предположим, что Data параметризуются с помощью <T exxtends Number>. В этом случае преобразованный код будет выглядеть аналогично последнему фрагменту 
кода с одним отличием: Object будет заменен на Number.

Если присвоено значение, generic замена может повлиять на точность программы. Если необходимо сохранить безопасность типов, компилятор вставляет приведение типов. 
Давайте посмотрим на код:

Data<String> data = new Data("stored value");
String stored = data.get();

After type erasure is performed the code above is equivalent to:

Data data = new Data("stored value");
String stored = (String) data.get();

Чтобы сохранить полиморфизм с помощью приведения типов, иногда компилятору приходится генерировать синтетические методы. Давайте рассмотрим расширение класса Data:

public class NumberData extends Data<Number> {
    public void set(Number number) {
        System.out.println("NumberData set");
        super.set(number);
    }
}

После стирания типа метод NumberData остается set(Number number), в то время как исходный метод данных set(Object obj). Поскольку NumberData расширяет данные, можно 
вызвать set(Object obj) из экземпляра NumberData и установить объекты произвольного типа. Но мы хотим установить только объекты Number типа. Чтобы решить эту проблему 
и сохранить полиморфизм универсальных типов после стирания типов, компилятор Java генерирует так называемый bridge метод в классе NumberData. Он переопределяет 
параметризованные родительские методы и обеспечивает приведение типов к определенным параметрам:

public class NumberData extends Data {
    // Bridge method generated by the compiler
    public void set(Object object) {
        super.set((Number) object);
    }

    public void set(Number number) {
        super.set(number);
    }

    ...
}

Метод моста-это синтетический метод, созданный компилятором как часть процесса стирания типов. Он существует только в байтовом коде и недоступен для прямого 
использования из кода Java. Обычно вы непосредственно не сталкиваетесь с методами моста, хотя иногда они могут появляться в трассировке стека.

======================================================================Reification===========================================================================
Стирание типов влияет только на определенные типы данных — другие типы не затрагиваются и сохраняют свои данные типа в байтовом коде. Типы, которые сохраняют 
информацию о себе во время стирания типов, называются reifiable(повторяемыми), в то время как типы, информация о которых стирается, называются non reifiable. 
Термин "Reification" относится к процессу предоставления определенных параметров типа во время выполнения, а также во время компиляции.

Давайте вспомним, какие типы заменяются во время стирания типов и могут быть названы non reifiable. non reifiable типы включают:

1) параметризованные типы, такие как <T>, которые заменяются классом Object.
2) дженерики c верхней или нижней границей или wildcards. Например, <T extends Number> и <? extends Number> заменяются на Number.

Reifiable типы более обширны. Они включают в себя:

1) примитивные типы, такие как int и double.
2) непараметризованные типы, такие как String, Number и другие non-generic классы.
3) более сложные Reifiable типы, которые технически эквивалентны классу Object. Первый - это raw тип. Это тип, который может быть параметризован, но не является 
таковым. Например, если класс Box<T> объявлен как Box box = new Box(), то это raw тип. Второй-это неограниченный тип wildcard, например, Box<?>. 

Тот факт, что non reifiable типы отсутствуют во время выполнения, приводит к некоторым ограничениям:

1) Запрещается создавать экземляр non reifiable типа.
Предположим, вам нужно создать экземпляр класса типа T внутри параметризованного класса. Вызов универсального конструктора выглядит нормально, однако это приводит 
к ошибке компиляции

class Box<T> {
    private T instance;

    public void init() {
        instance = new T(); // compile-time error: Type parameter T cannot be instantiated directly
    }
}

Это ограничение является разумным, поскольку у нас нет возможности гарантировать, что T будет реализовывать какой-либо конкретный конструктор.

2) Еще одно ограничение для non reifiable типа включает использование оператора instanceof.

class Box<T> {
    ...
    public boolean isIntegerSuperType() {
        return Integer.valueOf(0) instanceof T; // compile-time error: Illegal generic type for instanceof
    }
}

Эта операция запрещена, поскольку байт-код во время выполнения не содержит информации о non reifiable типах, что делает невозможным проверку того, 
является ли объект экземпляром такого типа.

3) Только reifiable типы могут расширять java.lang.Throwable.
Предположим, что существует универсальный класс, который расширяет Throwable.

class MyException<T> extends Exception {}

Учитывая этот код, компилятор вызывает сообщение Generic class may not extend java.lang.Throwable. Чтобы проиллюстрировать проблему, предположим, 
что компилятор проигнорировал эту ошибку и выполнил следующий код:

try {
    ...
} catch (MyException<String> e) {
    System.out.println("String");
} catch (MyException<Long> e) {
    System.out.println("Long");
}

После стирания типов оба пойманных типа будут переведены в один тип MyException без параметров. В результате у нас возникает дилемма о том, как 
обрабатывать MyException – программа не будет знать, какое сообщение об исключении печатать. По этой причине любые generic расширения Throwable запрещены.

4) Для создания экземпляра массива требуется reifiable тип. Это ограничение также относится к Varargs, который преобразует параметры в массив.

Давайте посмотрим на сигнатуру метода <T> T[] toArray(T[] a) в классе Collection. Основная задача массива, передаваемого в качестве аргумента, заключается 
в предоставлении информации о типе во время выполнения.

Помните, что из-за стирания типа код

Collection<Integer> col = new ArrayList<Integer>();
Integer[] array = col.toArray(new Integer[0]);

эквивалентно:

Collection col = new ArrayList();

// col has no type parameter information at runtime. 
// Which array type should we create inside toArray() method without a parameter?
Integer[] array = (Integer[]) col.toArray();

Поскольку стирание типов обрабатывает приведение типов, совершенно нормально вызвать этот метод следующим образом:

Collection<Integer> col = ... initializing of this Collection

// toArray will create array of appropriate size 
Integer[] array = col.toArray(new Integer[0]);

Таким образом, использование reifiBLE типа, такого как Integer, сохраняет информацию о типе во время выполнения.

5) Приведение к non-reifiable типам обычно приводит к предупреждению, уведомляющему программиста о том, что эта практика может привести к исключениям.

=================================================================What are collections================================================================
Язык Java поддерживает массивы для хранения нескольких значений или объектов одного типа вместе. Массив инициализируется с заданным размером во время 
создания. Размер не может быть изменен в будущем, и это накладывает некоторые ограничения на их использование для решения бизнес-задач. Если мы хотим 
хранить больше данных, нам нужно создать новый массив большего размера, а затем скопировать данные в этот массив вручную. Это может быть неэффективно 
для программ, которые обрабатывают много данных.

К счастью, существует набор контейнеров, называемых коллекциями, для группировки элементов в единое целое. Они используются для хранения, извлечения, 
обработки и передачи агрегированных данных.

Коллекции более сложны и гибки, чем массивы. Прежде всего, они изменяются по размеру: вы можете добавить любое количество элементов в коллекцию. 
Коллекция автоматически обработает удаление элемента из любой позиции. Второй момент заключается в том, что коллекции предоставляют богатый набор 
методов, которые уже реализованы для вас.

Существует несколько типов коллекций с различной структурой внутреннего хранилища. Вы можете выбрать тип коллекции, наиболее соответствующий вашей 
проблеме, чтобы ваши наиболее частые операции были удобными и эффективными.

Существует несколько специфических особенностей коллекций в Java:

1) Они представлены различными классами из стандартной библиотеки Java.
2) Все современные коллекции являются универсальными типами, в то время как старые коллекции не являются универсальными. Мы сосредоточимся только на 
новых коллекциях. Как обычные generics, они могут хранить любые ссылочные типы, включая классы, определенные вами (например, Person или что-то еще).
3) Коллекции могут быть mutable (можно добавлять и удалять элементы) и immutable.

В дополнение к стандартным коллекциям существует ряд внешних библиотек с коллекциями. Одной из таких библиотек является коллекция Guava, разработанная 
компанией Google. Его можно использовать, если стандартных коллекций недостаточно для решения ваших проблем.

Вот пример простой коллекции под названием ArrayList. Чтобы использовать её, выполните следующий импорт:

java.util.ArrayList;

Он работает аналогично обычному массиву, но вам не нужно вручную изменять его размер, чтобы добавлять и удалять элементы.

ArrayList<String> list = new ArrayList<>();

list.add("first");
list.add("second");
list.add("third");

System.out.println(list); // [first, second, third]

System.out.println(list.get(0)); // first
System.out.println(list.get(1)); // second
System.out.println(list.get(2)); // third

list.remove("first");

System.out.println(list); // [second, third]

System.out.println(list.size()); // 2

Все современные коллекции используют дженерики, поэтому вы можете указать любой ссылочный тип в качестве дженерика и сохранить его в коллекции. 
Но есть одно ограничение: коллекции вообще не могут хранить примитивные значения (int, long, char, double и так далее). Вместо этого вы должны 
использовать один из классов-оболочек (Integer, Long, Character, Double или другой).

====================================================================ArrayList=================================================================
Одним из наиболее широко используемых классов библиотеки классов Java является класс с именем ArrayList, представляющий изменяемый массив 
объектов указанного типа. В отличие от стандартного массива, обозначаемого как [], он может динамически расти после добавления и сжиматься после 
удаления его элементов. Такое поведение очень полезно, если вы заранее не знаете размер массива или вам нужен массив, который может изменять 
размеры в течение всего срока службы программы.

Фактически, этот класс построен поверх стандартного массива Java, расширяя его набором удобных операций. Как и стандартный массив, он позволяет 
получить текущее количество элементов (его размер), а также получить доступ к его элементам по их индексам.

Существует только одно ограничение: ArrayList: будучи джнереик классом, он не может хранить примитивные типы. Однако он может хранить любые 
ссылочные типы, включая String, классы-оболочки (например, Integer), другие ArrayList и пользовательские классы.

Чтобы начать использовать класс по его короткому имени, выполните следующий импорт:

import java.util.ArrayList;

Давайте рассмотрим несколько способов создания экземпляров этого класса.

1) Самый простой способ-использовать конструктор без аргументов:

ArrayList<String> list = new ArrayList<>();

Созданный список пуст, но его начальная емкость равна 10 (по умолчанию).

2) Мы также можем указать начальную емкость:

ArrayList<String> list = new ArrayList<>(50);

Этот список пуст, но его начальная емкость установлена на 50.

3) Или вы можете создать ArrayList, состоящий из элементов другого списка:

ArrayList<String> list = new ArrayList<>(anotherList);

Коллекция имеет набор удобных методов, которые эмулируют и расширяют функциональность стандартных массивов. Давайте обсудим, что это такое. 
Во-первых, давайте инициализируем некоторую коллекцию:

ArrayList<String> names = new ArrayList<>(); // empty collection of strings

Прежде всего, существует метод size() для определения размера коллекции, который возвращает количество элементов списка. Давайте попробуем 
узнать размер нашего:

System.out.println(names.size()); // 0

Как и ожидалось, он пуст, и результат равен нулю. Мы также можем узнать значение указанной позиции объекта. Для этого у коллекций есть метод 
get(int index), который возвращает объект списка, присутствующий в указанном индексе.

Далее, существует множество методов для добавления элементов и установки значений коллекции:

add(Object o) добавляет переданный элемент в последнюю позицию коллекции;
add(int index, Object o) добавляет переданный элемент в указанную позицию коллекции;
set(int index, Object o) заменяет элемент, присутствующий в указанном индексе, объектом;

Let's add some names to our collection:

names.add("Justin");      // [Justin]
names.add("Helen");       // [Justin, Helen]
names.add(1, "Joshua");   // [Justin, Joshua, Helen]
names.add(0, "Laura");    // [Laura, Justin, Joshua, Helen]

And replace one name with another:

names.set(3, "Marie"); // now: [Laura, Justin, Joshua, Marie]

We can check that everything is as expected:

System.out.println(names);        // [Laura, Justin, Joshua, Marie]
System.out.println(names.size()); // 4
System.out.println(names.get(0)); // the first element is "Laura"
System.out.println(names.get(3)); // the last element is "Marie"

Наконец, существуют методы удаления элементов из коллекции:

remove(Object o) removes the object;
remove(int index) удаляет первое вхождение элемента с заданным индексом;
clear() removes all elements from the collection.

Let's try removing elements by value and index:

names.remove("Justin"); // [Laura, Joshua, Marie]
names.remove(1);        // [Laura, Marie]
names.clear();          // []

Мы проиллюстрировали возможности основных методов для коллекций в Java, применяемых к объекту ArrayList. Но у этого класса есть еще 
несколько собственных методов. Во-первых, давайте создадим еще один ArrayList:

/* an ArrayList of Integers, not ints */
ArrayList<Integer> numbers = new ArrayList<>();

numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(1);

Существует также метод addAll(Collection c) для добавления всей коллекции в список ArrayList. Он добавляет элементы предоставленной 
коллекции в конец списка:

ArrayList<Integer> numbers2 = new ArrayList<>();    // creating another list of Integers
numbers2.add(100);
numbers2.addAll(numbers); // [100, 1, 2, 3, 1]

Класс также имеет метод contains, который проверяет, содержит ли список значение или нет, и два метода indexOf и lastIndexOf, которые 
находят индекс первого и последнего вхождения элемента соответственно. Они возвращают -1, если такого индекса нет.

System.out.println(numbers.contains(2));    // true
System.out.println(numbers.contains(4));    // false
System.out.println(numbers.indexOf(1));     // 0
System.out.println(numbers.lastIndexOf(1)); // 3
System.out.println(numbers.lastIndexOf(4)); // -1

Можно перебирать элементы экземпляра класса. Это делается так же, как и итерация по массиву. В следующем примере мы используем циклы for 
и for-each, чтобы добавить пять первых степеней десяти в список, а затем вывести числа в стандартный вывод.

ArrayList<Long> powersOfTen = new ArrayList<>();

int count = 5;
for (int i = 0; i < count; i++) {
    long power = (long) Math.pow(10, i);
    powersOfTen.add(power);
}

for (Long value : powersOfTen) {
    System.out.print(value + " ");
}

The code prints the following:

1 10 100 1000 10000 

add(DataType element) - добавить элемент
add(int index, element) - добавить элемент на конкретный индекс
addAll(ArrayList  aL) - добавляет в указанный ArrayList в конец текущего
addAll(int index, ArrayList  aL) - добавляет в указанный ArrayList в указанный индекс текущего
get(int index) - возвращает элемент с указанным индексом
set(int index, DataType element) - заменяет элемент с указанным индексом на новый элемент
remove(Object element) - удалить элемент
remove(int index) - удалить элемент c указанным индексом
removeIf(elem -> elem < 0)
removeAll(Collection<?> c) - удаляет элементы из вызываемой коллекции, которые находятся в коллекции из парамтера
retainAll(Collection<?> c) - оставляет в вызываемой коллекции элементы, которые находятся в коллекции из парамтера(остальные удаляет)
indexOf(Object element) - возвращает индекс первого встреченного элемента, если элемент не найден, то возвращает -1
lastIndexOf(Object element) - возвращает индекс последнего встреченного элемента, если элемент не найден, то возвращает -1
isEmpty() - выяснить пусть ли список, возвращает true или false соответственно
contains(Object element) - возвращает true если искомый элемент присутствует, иначе false
containsAll(Collection<?> c) - возвращает true если все элементы из передаваемой коллекции присутствуют в вызываемой коллекции, иначе false
size() - узнать размер списка
clear() - очищает ArrayList
toString() - выводит ArrayList как строку
List<E> subList(int fromIndex, int toIndex) возвращает список начиная с fromIndex включительно и до toIndex не включительно(является view вызываемой 
коллекции) т.е. если добавить елемент в возвращённую коллекцию, то элемент добавится и в основную коллекцию

clone() - возвращает объект с копией элементов ArrayList
ArrayList <StringBuilder> list2 = (ArrayList <StringBuilder>) list1.clone()
list1.get(0) == list2.get(0) // true т.к. ссылаются на один объект
list1 == list2 // false т.к. это разные объекты

toArray() - возвращает Object[]
Object[] array = list.toArray();
 
toArray(DataType[] array) - возвращает DataType[]
StringBuilder[] array = list.toArray(new StringBuilder[10]);

Arrays.asList(DataType[]) - возвращает List<DataType> , причём, изменить размер List нельзя, все изменения в массиве отразятся в List
StringBuilder[] array = {sb1, sb2, sb3, sb4};
List <StringBuilder> list = Arrays.asList(array);

Collections.sort(ArrayList <DataType>) - сортирует ArrayList

equals(ArrayList<DataType>) -> boolean - сравнивает количество элементов. элементы и их порядок в ArrayListах


=================================================================The List interface========================================================
Интерфейс List<E> представляет список как абстрактный тип данных. Он расширяет интерфейс Collection<E>, приобретая его методы, и добавляет 
некоторые новые методы:

E set(int index, E element) заменяет элемент в указанной позиции в этом списке указанным элементом и возвращает элемент, который был заменен;
E get(int index) возвращает элемент в указанной позиции в списке;
int indexOf(Object obj) возвращает индекс первого вхождения элемента в список или -1, если такого индекса нет;
int lastIndexOf(Object obj) возвращает индекс последнего вхождения элемента в списке или -1, если такого индекса нет;
List<E> subList(int fromIndex, int toIndex) возвращает список начиная с fromIndex включительно и до toIndex не включительно

Как вы можете видеть, методы предполагают, что список является упорядоченной коллекцией.

Вы не можете создать экземпляр интерфейса List, но вы можете создать экземпляр одной из его реализаций: ArrayList или LinkedList или immutable 
список, а затем использовать его через общий интерфейс List. У вас будет доступ ко всем методам, объявленным в интерфейсах List<E> и Collection<E>.

Работа со списками через интерфейс List считается хорошей практикой в программировании, поскольку ваш код не будет зависеть от внутренних 
механизмов конкретной реализации.

Самый простой способ создать список-вызвать метод of интерфейса List.

List<String> emptyList = List.of(); // 0 elements
List<String> names = List.of("Larry", "Kenny", "Sabrina"); // 3 elements
List<Integer> numbers = List.of(0, 1, 1, 2, 3, 5, 8, 13);  // 8 elements

Он возвращает неизменяемый список, содержащий либо все переданные элементы, либо пустой список. Использование этого метода удобно при создании 
констант списка или тестировании некоторого кода.

Давайте выполним несколько операций:

List<String> daysOfWeek = List.of(
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday"
);

System.out.println(daysOfWeek.size()); // 7
System.out.println(daysOfWeek.get(1)); // Tuesday
System.out.println(daysOfWeek.indexOf("Sunday")); // 6

List<String> weekDays = daysOfWeek.subList(0, 5);
System.out.println(weekDays); // [Monday, Tuesday, Wednesday, Thursday, Friday]

Поскольку он неизменяем, будут работать только методы, которые не изменяют элементы в списке. Другие создадут исключение.

daysOfWeek.set(0, "Funday"); // throws UnsupportedOperationException
daysOfWeek.add("Holiday");   // throws UnsupportedOperationException

Эта ситуация ясно показывает, когда необходимы неизменяемые списки. Трудно представить, что кто-то переименует один день или добавит другой!

Будьте осторожны при работе с неизменяемыми списками. Иногда даже опытные разработчики получают исключение UnsupportedOperationException.

До Java 9 другим способом создания неизменяемых списков было следующее:

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

Когда вам нужно использовать изменяемый список, вы можете взять одну из двух реализаций интерфейса List.

Один из них вам знаком: класс ArrayList<E>. Он представляет собой массив с изменяемым размером. В дополнение к реализации интерфейса List, 
он предоставляет методы для управления размером массива, который используется внутри. Эти методы не нужны в программах часто, поэтому лучше 
использовать объект этого класса через интерфейс List.

List<Integer> numbers = new ArrayList<>();

numbers.add(15);
numbers.add(10);
numbers.add(20);

System.out.println(numbers); // [15, 10, 20]

numbers.set(0, 30); // no exceptions here

System.out.println(numbers); // [30, 10, 20]

Если у вас есть неизменяемый список, вы можете сделать из него изменяемую версию, используя следующий код:

List<String> immutableList = Arrays.asList("one", "two", "three");
List<String> mutableList = new ArrayList<>(immutableList); 

Другой изменяемой реализацией интерфейса List является класс LinkedList. Он представляет собой двусвязный список, основанный на 
связанных между собой узлах. Все операции, индексирующие список, будут проходить по списку с начала или с конца, в зависимости от 
того, что ближе к указанному индексу.

List<Integer> numbers = new LinkedList<>();
        
numbers.add(10);
numbers.add(20);
numbers.add(30);

System.out.println(numbers); // [10, 20, 30]

Доступ к первому и последнему элементу списка всегда осуществляется за постоянное время O(1), поскольку ссылки постоянно хранятся в первом и 
последнем элементе, поэтому добавление элемента в конец списка не означает, что вам придется перебирать весь список в поисках последнего элемента. 
Но доступ/настройка элемента по его индексу занимает O(n) времени для связанного списка.

В общем случае LinkedList проигрывает ArrayList в потреблении памяти и скорости операций. Но это зависит от проблемы, которую вы пытаетесь решить.

Нет никаких проблем с перебором элементов списка.

List<String> names = List.of("Larry", "Kenny", "Sabrina");

1) Using the "for-each" loop:

// print every name
for (String name : names) {
    System.out.println(name);
}

2) Using indexes and the size() method:

// print every second name
for (int i = 0; i < names.size(); i += 2) {
    System.out.println(names.get(i));
}

Когда вам нужно просмотреть все элементы списка, мы рекомендуем выбрать цикл for each. цикл for хорош, когда вам нужно пропустить 
некоторые элементы в зависимости от их положения в списке.

Последний вопрос заключается в том, как сравниваются списки. Два списка равны, если они содержат одни и те же элементы в одном и том же порядке. 
Равенство не зависит от типов самих списков (ArrayList, LinkedList или что-то еще).

Objects.equals(List.of(1, 2, 3), List.of(1, 2, 3));    // true
Objects.equals(List.of(1, 2, 3), List.of(1, 3, 2));    // false
Objects.equals(List.of(1, 2, 3), List.of(1, 2, 3, 1)); // false

List<Integer> numbers = new ArrayList<>();
        
numbers.add(1);
numbers.add(2);
numbers.add(3);

Objects.equals(numbers, List.of(1, 2, 3)); // true


======================================================LinkedList vs. ArrayList==========================================================
В предыдущих разделах вы встречали два класса, которые очень похожи: ArrayList и LinkedList. Они оба реализуют интерфейс List и предоставляют 
полезные функции для хранения элементов и доступа к ним. Какой из них использовать? Правда жизни в том, что разные проблемы требуют разных 
подходов. Чтобы сделать правильный выбор, вам нужно понять, кто в какой ситуации является победителем. И сегодня вы, наконец, будете готовы 
сделать этот выбор: мы отправляемся в увлекательное путешествие по подробному сравнению ArrayList и LinkedList.

Давайте начнем с краткого и наглядного обзора того, как наши списки выглядят внутри.
Внутри ArrayList-это массив объектов с изменяемым размером, где каждый элемент имеет индекс.

LinkedList-это двусвязный список, основанный на подключенных nodes. LinkedList хранит его head и tail.

Node<E>-это класс, имеющий три поля: E item, Node E next и Node E prev.

Логика ArrayList проста: поскольку внутренне это массив, операции get(int index) и set(int index, элемент E) будут выполняться быстро. Другими 
словами, временная сложность доступа по индексу равна O(1).

Если вы используете операцию add(E e), в конец списка ArrayList будет добавлен новый элемент. Это также будет быстро и займет постоянное время, 
поэтому сложность будет одинаковой: O(1).

Но если вы хотите вставить элемент в ArrayList с помощью операции add(int index, E element), ситуация будет другой. Чтобы поместить новый элемент 
в определенный индекс, ArrayList должен переместить все последующие элементы.

В нашем примере после вставки элемент "Массив" будет иметь индекс 4, а элемент "Список!" будет иметь индекс 5. Если есть много последующих 
элементов, эта операция будет довольно длительной с временной сложностью O(n).

Если вы хотите добавить новый элемент в полный список ArrayList, сначала будет создан новый массив большего размера. Затем все существующие элементы 
будут скопированы в этот новый массив. И только тогда будет добавлен ваш новый элемент. Таким образом, наихудшая временная сложность будет O(n).

Последняя операция - remove(int index). Когда вы хотите удалить элемент, все последующие элементы должны быть перемещены.

Из-за перемещения всех последующих элементов эта операция будет не очень эффективной для длинного списка с временной сложностью O(n).

LinkedList не является массивом, поэтому он не поддерживает быстрый доступ по индексу. Но он может достичь элемента по его индексу. Для этого LinkedList 
решает, что будет ближе к этому индексу: голова или хвост. А затем, начиная с головы или хвоста, LinkedList пересекает все элементы, прежде чем достигнет 
требуемого.

fistElement.next.next.next.next.next.next...

Давайте начнем с операций get(int index) и set(int index, E elem).

Чтобы получить элемент "am" с индексом 1, LinkedList будет начинать с головы. В нашем примере LinkedList нужно будет пройти только по одной ссылке: между 
элементом "I" и элементом "am". Но если у вас длинный список ссылок и требуемый индекс находится посередине, эти операции get(int index) и set(int index, элемент E) 
займут много времени. Таким образом, в плохой ситуации временная сложность была бы O(n).

Добавление элемента в конец LinkedList - это быстрая операция. LinkedList соединит новый элемент "Hello!" с последним элементом "List" и сделает элемент "Hello" новым хвостом.

Таким образом, это всегда занимает постоянное время, а сложность add(E e) равна O(1).

Помимо метода add(E e) существуют два других метода: addFirst(E e) и addLast(E e). Как вы можете понять из их имен, они добавляют элемент в начале и в конце списка ссылок 
соответственно. Их внутренний механизм абсолютно такой же, как и с методом add(E e). И их сложность также равна O(1). Метод addLast(E e) эквивалентен методу add(E e). 
Разница в том, что метод add(E e) возвращает boolean значение, а метод addLast(E e) возвращает void.

А как насчет вставки элемента в конкретный индекс с помощью операции add(int index, E element)?

Чтобы добавить элемент LinkedList, необходимо достичь требуемой позиции, а затем изменить только ссылки соседей нового элемента.

И все: соедините новый элемент с предыдущим и следующим элементом, и вставка будет выполнена. Нет необходимости перемещать элементы, как в ArrayList.

Если вы добавите новые элементы рядом с головой или хвостом, временная сложность будет равна O(1). В большинстве ситуаций это быстрая операция. Но если ваш список очень 
длинный, то добраться до элемента в середине будет не так быстро. Таким образом, в плохой ситуации временная сложность была бы O(n).

Последняя-операция remove(int index). Механизм тот же, LinkedList должен добраться до элемента и изменить ссылки.

При изменении связей соседей элемент будет удален. И опять же, в большинстве ситуаций это быстрая операция. Но для удаления элемента из середины очень длинного LinkedList 
временная сложность будет равна O(n).

LinkedList имеет два других полезных метода: removeFirst() и removeLast(). Для них LinkedList не нужно пересекать элементы. Он просто удаляет первый или последний элемент 
и меняет голову или хвост соответственно. Временная сложность для обеих операций равна O(1).

				ArrayList		LinkedList
get(int index)			fast O(1)		mostly long O(n)
set(int index, E element)	fast O(1)		mostly long O(n)
add(E e)			fast O(1)		fast O(1)
add(int index, E element)	mostly long O(n)	mostly fast
remove(int index)		mostly long O(n)	mostly fast


=========================================The Collections Framework overview====================================================
Java предоставляет collections framework, который состоит из классов и интерфейсов для часто используемых структур данных, таких как списки, 
динамические массивы, наборы и так далее. Платформа имеет единую архитектуру для представления и управления коллекциями, что позволяет использовать 
коллекции независимо от деталей реализации через ее интерфейсы.

The framework includes:

- интерфейсы, представляющие различные типы коллекций;
- основные реализации интерфейсов;
- устаревшие реализации из более ранних выпусков (известные как "старые коллекции");
- реализации специального назначения (например, неизменяемые коллекции);
- алгоритмы, представленные статическими методами, которые выполняют полезные операции над коллекциями.

В этом разделе мы рассмотрим только основные интерфейсы из фреймворка коллекций, размещенного в пакете java.util.

Существует два корневых универсальных интерфейса Collection<E> и Map<K,V>, а также некоторые более конкретные интерфейсы для представления 
различных типов коллекций.

Интерфейс List расширяет интерфейс Collection
Интерфейс SortedSet расширяет интерфейс Set, a интерфейс Set расширяет интерфейс Collection
Интерфейс Deque расширяет интерфейс Queue, a интерфейс Queue расширяет интерфейс Collection

Интерфейс SortedMap расширяет интерфейс Map

Интерфейс Collection<E> представляет собой абстрактную коллекцию, которая является контейнером для объектов одного типа. Он предоставляет некоторые общие 
методы для всех других типов коллекций.

Интерфейсы List<E>, Set<E>, Queue<E>, SortedSet<E> и Deque<E> представляют различные типы коллекций. Вы не можете напрямую создать их объект, так как они 
являются просто интерфейсами. Но каждый из них имеет несколько реализаций. Например, класс ArrayList, представляющий массив с изменяемым размером, является 
основным представлением интерфейса List<E>. Другие интерфейсы, а также их реализации будут рассмотрены в следующих разделах.

Другой корневой интерфейс- Map<K,V> , представляющий коллекцию для хранения пар ключ-значение, где K-тип ключей, а V-тип хранимых значений. В реальном мире 
хорошим примером является телефонная книга, где ключи-это имена ваших друзей, а значения-их телефоны. Интерфейс Map<K,V> не является подтипом интерфейса 
Collection<E>, но часто рассматриваtтся как коллекциz, поскольку они являются частью структуры коллекции и имеют аналогичные методы.

Вот общие методы, предоставляемые интерфейсом Collection.

int size() возвращает количество элементов в этой коллекции;
boolean isEmpty() возвращает true, если эта коллекция не содержит элементов;
boolean contains(Object o) возвращает true, если эта коллекция содержит указанный элемент;
boolean add(E e) добавляет элемент в коллекцию. Возвращает true, если элемент был добавлен, else возвращает false;
boolean remove(Object o) удаляет один экземпляр указанного элемента;
boolean removeAll(Collection<?> collection) удаляет элементы из этой коллекции, которые также содержатся в указанной коллекции;
void clear() удаляет все элементы из этой коллекции.

Можно ссылаться на любую конкретную коллекцию через этот базовый интерфейс, поскольку, как вы знаете, суперкласс может использоваться для ссылки на любой объект 
подкласса, производный от этого суперкласса.

Давайте создадим коллекцию languages и добавим в нее три элемента:

Collection<String> languages = new ArrayList<>();

languages.add("English");
languages.add("Deutsch");
languages.add("Français");

System.out.println(languages.size()); // 3

Этот подход позволяет заменить конкретную коллекцию в любое время без изменения кода, который ее использует. Он также способствует повторному использованию 
программного обеспечения, предоставляя стандартный интерфейс для коллекций и алгоритмов для управления ими. Сейчас это может показаться сложным, но чем больше вы 
будете работать с коллекциями, тем более понятным это станет.

Невозможно получить элемент по индексу через интерфейс Collection, потому что он очень абстрактен и не предоставляет такого метода. Но если для вас не имеет значения, 
какую именно коллекцию использовать, вы можете работать через этот интерфейс.

Важно понимать, что порядок элементов в списке ArrayList в любом случае сохраняется. Мы просто не можем вызвать метод get через интерфейс коллекции.

Каждую коллекцию можно представить как строку с помощью toString и сравнить с другой коллекцией с помощью метода equals. Эти методы исходят из класса Object, и их 
поведение зависит от элементов, хранящихся в коллекции, и типа самой коллекции.

Все коллекции можно разделить на две большие группы: изменяемые и неизменяемые. Они оба реализуют интерфейс Collection<E>, но неизменяемые коллекции будут вызывать 
исключение UnsupportedOperationException при попытке вызвать некоторые методы, которые их изменяют: например, add, remove, clear.

Если вы хотите перебрать элементы любой коллекции, вы можете использовать цикл для каждого стиля. Давайте вернемся к нашей коллекции Languages:

for (String lang : languages) {
    System.out.println(lang);
}

This code prints all elements of this collection.

English
Deutsch
Français

Порядок элементов при итерации зависит от типа конкретной коллекции, которая фактически используется.

Если вы уже знакомы с method references или лямбда-выражениями, вы можете использовать другой стиль для итераций с использованием метода forEach(Consumer<T> consumer):

languages.forEach(System.out::println); // with method reference
languages.forEach(elem -> System.out.println(elem)); // with lambda expression

Также можно удалить элементы из изменяемой коллекции (например, ArrayList).

languages.remove("Deutsch");

System.out.println(languages.size()); // 2

Обратите внимание, что методы remove, а также contains зависят от метода equals. Если вы храните нестандартные классы в коллекции, equals вместе с hashCode должны быть переопределены.

Опять же, если вы уже знакомы с лямбда-выражениями, вы можете вызвать метод removeIf, чтобы удалить все элементы, удовлетворяющие данному предикату:

languages.removeIf(lang -> lang.startsWith("E")); // it removes English

System.out.println(languages.size()); // 1

==================================================================Method references==================================================================
Как вы знаете, лямбда-выражения позволяют использовать код в качестве данных и передавать его в качестве аргументов метода. Другой способ сделать это - 
использовать Method references. Они часто даже более читабельны, чем соответствующие лямбда-выражения. Кроме того, ссылки на методы заставляют 
разработчиков разбивать программу на набор коротких методов с четкими областями ответственности.

Под Method references мы подразумеваем функцию, которая ссылается на конкретный метод через его имя и может быть вызвана в любое время, когда нам это 
нужно. Базовый синтаксис Method references выглядит следующим образом:

objectOrClass :: methodName   

где objectOrClass может быть именем класса или конкретным экземпляром класса.

Вот пример, мы создаем ссылку на стандартный статический метод max класса Integer.

BiFunction<Integer, Integer, Integer> max = Integer::max;

Здесь Integer::max-это ссылка на метод статического метода.

Этот код работает, потому что определение метода int max(int a, int b) соответствует BiFunction<Integer, Integer, Integer> : оба они означают принятие 
двух целочисленных аргументов и возврат целочисленного значения.

Теперь у нас есть объект max, который можно использовать в качестве функции, вызвав метод apply. Давайте используем его!

System.out.println(max.apply(50, 70)); // 70

Вот альтернативный способ создания одного и того же объекта с помощью лямбда - выражения:

BiFunction<Integer, Integer, Integer> max = (x, y) -> Integer.max(x, y);

Рекомендуется использовать method references, а не лямбда-выражения, если вам просто нужно вызвать стандартный метод без других операций. Ваш код будет короче, 
читабельнее и проще в тестировании.

It's possible to write method references to both static and instance (non-static) methods.

In general, there are four kinds of method references:
- reference to a static method;
- reference to an instance method of an existing object;
- reference to an instance method of an object of a particular type;
- reference to a constructor.

1) Ссылка на статический метод

The general form is the following:

ClassName :: staticMethodName

Давайте взглянем на ссылку на статический метод sqrt класса Math:

Function<Double, Double> sqrt = Math::sqrt;

Теперь мы можем вызвать метод sqrt для double значений:

sqrt.apply(100.0d); // the result is 10.0d

Метод sqrt также может быть записан с использованием следующего лямбда-выражения:

Function<Double, Double> sqrt = x -> Math.sqrt(x);

2) Ссылка на метод экземпляра объекта

The general form looks like this:

objectName :: instanceMethodName

Here is the result of applying it to different arguments:

System.out.println(indexWithinWhatsGoingOnText.apply("going")); // 7
System.out.println(indexWithinWhatsGoingOnText.apply("Hi"));    // -1

Как вы можете видеть, на самом деле мы всегда работаем с объектом whatsGoingOnText, захваченным из контекста.

Следующий пример лямбда-выражения является полным эквивалентом приведенной выше ссылки и может улучшить ваше понимание ситуации:

Function<String, Integer> indexWithinWhatsGoingOnText = string -> whatsGoingOnText.indexOf(string);

3) Ссылка на метод экземпляра объекта определенного типа

Here is a general form of a reference:

ClassName :: instanceMethodName

В этом случае вам необходимо передать экземпляр класса в качестве аргумента функции.

Давайте сосредоточимся на следующей ссылке на экземпляр метода doubleValue класса Long:

Function<Long, Double> converter = Long::doubleValue;

Now we can invoke the converter for long values:

converter.apply(100L); // the result is 100.0d
converter.apply(200L); // the result is 200.0d

Also, we can write the same converter using the following lambda expression:

Function<Long, Double> converter = val -> val.doubleValue();

4) Ссылка на конструктор

This reference has the following declaration:

ClassName :: new

For example, let's consider our custom class Person with a single field name.

class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}

Here is a reference to the constructor of this class:

Function<String, Person> personGenerator = Person::new;

This function produces new Person objects based on their names.

Person johnFoster = personGenerator.apply("John Foster"); // we have a John Foster object

Here is the corresponding lambda expression that does the same.

Function<String, Person> personGenerator = name -> new Person(name);


=======================================================Functional interfaces=========================================================
В этом разделе вы узнаете о новой концепции, называемой функциональными интерфейсами. Это жизненно важное знание, потому что такие 
интерфейсы позволяют разработчикам использовать функциональное программирование поверх концепций ООП и, в некотором смысле, соединяют 
оба этих мира вместе. Это функциональные интерфейсы, которые позволяют использовать лямбда-выражения, method reference и другие функциональные 
вещи. Мы предполагаем, что вы уже знакомы с интерфейсами, лямбда-выражениями и анонимными классами. Теперь мы покажем вам, как все они 
связаны друг с другом.

Если интерфейс содержит только один абстрактный метод (такой интерфейс иногда называют типом SAM), его можно рассматривать как функцию. 
В дополнение к стандартным способам реализации интерфейсов через наследование или анонимные классы, эти интерфейсы могут быть реализованы 
с помощью лямбда-выражения или method reference.

Вот клон стандартного интерфейса Function<T, R>, который демонстрирует основную идею:

@FunctionalInterface 
interface Func<T, R> { 
    R apply(T val); // single abstract method
}

Аннотация @FunctionalInterface используется для обозначения функциональных интерфейсов и для выбрасывания ошибки во время компиляции, если 
интерфейс не удовлетворяет требованиям функционального интерфейса. Использование этой аннотации не является обязательным, но рекомендуется.

Интерфейс Func<T, R> отвечает требованиям, предъявляемым к функциональному интерфейсу, поскольку он имеет один метод apply, который принимает 
значение типа T и возвращает результат типа R.

Вот пример лямбда - выражения, реализующего этот пользовательский интерфейс:

Func<Integer, Integer> multiplier10 = n -> n * 10
System.out.println(multiplier10.apply(5)); // 50

Аналогичным образом, все стандартные функции могут быть представлены в виде функциональных интерфейсов, включая BiFunction<T, U, R>. Концепция 
функциональных интерфейсов - это еще один способ моделирования функций вместо использования обычных методов.

Стоит отметить, что статические методы и default методы разрешены в функциональных интерфейсах, поскольку эти методы не являются абстрактными:

@FunctionalInterface 
interface Func<T, R> { 
    R apply(T val);

    static void doNothingStatic() { }

    default void doNothingByDefault() { } 
}

Существует несколько способов реализации функционального интерфейса. Как вы знаете из предыдущей теории ООП, невозможно напрямую создать экземпляр 
интерфейса. Тогда что же нам делать?

Прежде всего, мы должны имплемнтировать интерфейс для создания конкретного класса. Затем создайте экземпляр этого конкретного класса. Главное требование-
реализовать метод apply, чтобы получить конкретное поведение.

Давайте рассмотрим три способа сделать это.

1) Anonymous classes.

Конечно, как и любой другой интерфейс, функциональный интерфейс может быть реализован с помощью анонимного класса или обычного наследования.

Чтобы реализовать функциональный интерфейс, давайте создадим анонимный класс и переопределим метод apply. Переопределенный метод вычисляет квадрат заданного значения:

Func<Long, Long> square = new Func<Long, Long>() {
    @Override
    public Long apply(Long val) {
        return val * val;
    }
};

long val = square.apply(10L); // the result is 100L

В этом примере мы моделируем математическую функцию, которая возыодит в квадрат заданное значение. Этот код работает отлично, но он немного сложен, так как содержит много 
дополнительных символов для выполнения одной строки полезного кода.

Мы не будем приводить вам пример обычного класса, потому что он имеет те же (и даже больше) недостатки.

2) Lambda expressions.

Функциональный интерфейс также может быть реализован и создан с помощью лямбда-выражения.

Вот лямбда - выражение, которое имеет то же поведение, что и анонимный класс выше:

Func<Long, Long> square = val -> val * val; // the lambda expression

long val = square.apply(10L); // the result is 100L

Тип функционального интерфейса (слева) и тип лямбды (справа) одинаковы с семантической точки зрения. Параметры и результат 
лямбда-выражения соответствуют параметрам и результату одного абстрактного метода функционального интерфейса.

Код, создающий лямбда-выражение, может выглядеть так, как если бы был создан объект типа интерфейса. Как вы знаете, это невозможно. 
На самом деле компилятор Java автоматически создает специальный промежуточный класс, реализующий функциональный интерфейс, а затем 
создает объект этого класса, а не объект типа интерфейса. Имя такого класса может выглядеть как Functions$$Lambda$14/0x0000000100066840 
или что-то подобное.

class Predicate {

    @FunctionalInterface
    public interface TernaryIntPredicate {
        boolean test(int a, int b, int c);
    }

    public static final TernaryIntPredicate allValuesAreDifferentPredicate = (a, b, c) -> {
        if (a != b && a != c && b != c) {
            return true;
        } else {
            return false;
        }
    };

    public static void main(String[] args) {
        System.out.println(allValuesAreDifferentPredicate.test(2, 3, 4));
    }
}

class Predicate {

    public static TernaryIntPredicate allValuesAreDifferentPredicate = (x, y, z) -> x != y && x != z && y != z;

    @FunctionalInterface
    public interface TernaryIntPredicate {
        boolean test(int a, int b, int c);
    }
}

3) Method references.

Другой способ реализации функционального интерфейса-использование Method references. В этом случае сигнатура метода должна совпадать с сигнатурой 
единственного абстрактного метода функционального интерфейса.

Предположим, существует метод square, который принимает и возвращает long значение:

public static long square(long val) {
    return val * val;
}

Сигнатура этого метода соответствует функциональному интерфейсу Func<Long, Long>. Это означает, что мы можем создать ссылку на метод и назначить ее 
объекту типа Func<Long, Long> :

Func<Long, Long> square = Functions::square;

Имейте в виду, что компилятор создает промежуточный скрытый класс, который реализует интерфейс Func<Long, Long> аналогично случаю лямбда-выражений.


==============================================================Functional interfaces=================================================================
You've got two arithmetic sequences:

First:
11 12 20 6 9 7 14 1 16 13 19 8 2 4 18 10 17 3 5 15 

Second:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

Какой из них легче запомнить? В котором вы бы быстрее нашли число 5? Вполне вероятно, что ваш ответ на оба вопроса будет заключаться в том, что легче 
получить информацию из второй последовательности. Главная причина этого-ordering(порядок).

1) Total order

Если вы знакомы с арифметикой начальной школы, вы можете легко различить totaly ordered numbers(полностью упорядоченные числа). Для натуральных чисел 
наименьшее число равно 1, затем идут 2, 3, 4 и т. Д. Этот порядок имеет строгие правила, которые мы можем описать формально.

Мы говорим, что последовательность имеет totaly order(общий порядок) с отношением меньше или равно, когда для каждого a, b, c из этой последовательности 
верны следующие утверждения:

if a≤b and b≤a then a = b
if a≤b and b≤c then a≤c
a≤b or b≤a

Вы можете посмотреть на вторую последовательность выше и проверить, можно ли применить эти правила там.

Помимо чисел, мы можем расположить любые другие типы данных в общем порядке, все, что нам нужно, - это определить операцию less or equal(меньше или равно).

2) Lexicographical order

То, как мы сравниваем строки, отличается от того, как мы сравниваем числа. Чем больше цифр имеет положительное целое число, тем оно больше, но это не верно 
для строк. Их порядок аналогичен алфавитному.

Особенность алфавитного порядка проявляется, когда мы сравниваем строчные(lower case) и прописные буквы(upper case). Например, в кодировке ASCII все прописные 
буквы латинского алфавита меньше любой строчной буквы, что означает, что Z < a. Кроме того, мы можем сравнить любые символы с буквами, потому что все они имеют 
целочисленные значения, и мы знаем, как сравнивать числа.

Чтобы сравнить две строки, сделайте это шаг за шагом:

- Сравните каждое слово буква за буквой с первой позиции. Когда две буквы в одной и той же позиции различаются, порядок слов соответствует порядку этих букв: 
cord < core.
- Когда в одном из слов не осталось букв, префиксное слово всегда меньше или равно другому, поэтому ball < ballet.

Учтите, что пустая строка является префиксом для любой другой строки, поэтому это самая маленькая строка из-за лексикографического порядка.

3) Chronological order

Можете ли вы сказать, какой день был раньше: 1969-06-20 или 1965-03-18? Порядок дат прост, поскольку мы сравниваем их по годам, затем по месяцам и, наконец, 
по дате. Когда мы встретим первое различие, мы сможем определить, какая дата меньше.

Почти ничего не меняется, когда вы добавляете время к дате. Вы шаг за шагом сравниваете две метки времени:

by year
by month
by day
by hour
by minute
by second
...

Как и в реальной жизни, будущие даты больше, чем текущее время, а прошлое меньше.

4) Application of ordering

Давайте вспомним последовательность из начала темы:

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

Упорядочение имеет несколько применений, основанных на его полезных свойствах, поэтому, глядя на эту последовательность, мы можем:

- сжать информацию (скажем, у нас есть элементы от 1 до 20)
- искать элементы быстрее (в нем легко найти элементы и ответить, каких элементов нет)
- проанализируйте структуру данных (по беглому взгляду мы можем найти минимальные и максимальные элементы в последовательности)

Вы можете найти приложения упорядочения в алгоритмах сжатия, поисковых системах, базах данных, инструментах аналитики и многих других программах.

==================================================================Comparator====================================================================
Каждый раз, когда нам нужно отсортировать набор данных, нам нужно сравнить его элементы друг с другом, чтобы определить, какие из них должны идти 
первыми, а какие-последними. Это не имеет большого значения, если нам нужно сравнить цифры или даты, но становится немного сложнее для многих 
других реальных примеров, таких как школьники, сообщения в социальных сетях или банковские счета. Именно здесь Comparator приходит на помощь, и 
мы подробно обсудим, как его использовать в этой теме.

Давайте создадим класс, моделирующий общее сообщение. Для простоты мы предполагаем, что содержимое такого сообщения может быть представлено строкой:

class Message {

    private final String content;

    public Message(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }

    @Override
    public String toString() {
        return content;
   }
}

Теперь нам нужно поместить несколько таких сообщений в коллекцию для работы:

List<Message> messages = new ArrayList<>();

messages.add(new Message("Hello"));
messages.add(new Message("humans!"));
messages.add(new Message("We"));
messages.add(new Message("came"));
messages.add(new Message("with"));
messages.add(new Message("peace!"));

Если мы попытаемся отсортировать список этих объектов, мы получим ошибку компиляции, поскольку наш класс Message не поддерживает никаких методов, 
позволяющих сравнивать его экземпляры. Чтобы решить эту проблему, давайте создадим Comparator, который будет определять порядок сортировки для 
объектов класса Message.

Comparator<T>-это универсальный интерфейс, который имеет один абстрактный метод сравнения и довольно много неабстрактных методов, которые мы 
рассмотрим позже. Чтобы создать Comparator, нам нужно определить класс, который реализует интерфейс Comparator и переопределяет его единственный 
абстрактный метод:

class MessageContentComparator implements Comparator<Message> {

    @Override
    public int compare(Message message1, Message message2) {
        // here we should define how these two arguments will be compared
        return 0;
    }
}

Ожидается, что мы реализуем этот метод в соответствии со следующими правилами:

1) Он должен возвращать 0, если оба аргумента равны;
2) Он должен возвращать положительное число, если первый аргумент больше второго;
3) Он должен возвращать отрицательное число, если первый аргумент меньше второго.

Таким образом, мы можем даже переопределить естественный порядок для любого типа, реализующего сопоставимый интерфейс.

В контексте Java естественный порядок-это порядок, определенный методом compareTo сопоставимого интерфейса.

В этом примере мы хотим отсортировать наши сообщения по длине их содержимого:

class MessageContentComparator implements Comparator<Message> {

    @Override
    public int compare(Message message1, Message message2) {
        int firstLength = message1.getContent().length();
        int secondLength = message2.getContent().length();
        return Integer.compare(firstLength, secondLength);
    }
}

Здесь мы использовали статический метод compare класса Integer для безопасного сравнения двух чисел int. Давайте отсортируем список сообщений с 
помощью MessageContentComparator:

messages.sort(new MessageContentComparator());
messages.forEach(System.out::println);

Here is the output:

We
came
with
Hello
peace!
humans!

Сообщения были напечатаны в порядке длины их содержимого, а не в порядке их добавления в список. Кроме того, мы можем иметь несколько классов 
Comparator для нашего класса и сортировать его экземпляры, используя различные порядки в зависимости от наших потребностей.

Во-первых, давайте расширим класс Message, а затем посмотрим, как мы можем реализовать сортировку:

class Message {

    private final String from;
    private final String content;
    private final LocalDate created;
    private int likes;

    public Message(String from, String content, int likes, String created) {
        this.from = from;
        this.content = content;
        this.likes = likes;
        this.created = LocalDate.parse(created);
    }

    // getters and setters

    @Override
    public String toString() {
        return created.toString() + " " + from + " wrote: " + 
                content + " (" + likes + ")";
    }
}

После этого нам нужно создать новый список сообщений, чтобы попробовать разные критерии сортировки.

List<Message> messages = new ArrayList<>();

messages.add(new Message("Alien", "Hello humans!", 
        32, "2034-03-25"));
messages.add(new Message("Pirate", "All hands on deck!", 
        -2, "2034-01-05"));
messages.add(new Message("User765214", "Bump!", 
        1, "2033-02-17"));
messages.add(new Message("Unregistered", "This message was marked as spam", 
        -18, "2033-01-14"));

В дополнение к компаратору, который у нас уже есть, мы создадим еще несколько:

class MessageDateComparator implements Comparator<Message> {

    @Override
    public int compare(Message message1, Message message2) {
        return message1.getCreated().compareTo(message2.getCreated());
    }
}

class MessageAuthorComparator implements Comparator<Message> {

    @Override
    public int compare(Message message1, Message message2) {
        return message1.getFrom().compareTo(message2.getFrom());
    }
}

Теперь мы можем использовать эти классы для сортировки списка экземпляров сообщений по различным критериям, например:

By date:

messages.sort(new MessageDateComparator());

Output:

2033-01-14 Unregistered wrote: This message was marked as spam (-18)
2033-02-17 User765214 wrote: Bump! (1)
2034-01-05 Pirate wrote: All hands on deck! (-2)
2034-03-25 Alien wrote: Hello humans! (32)

By author's name:

messages.sort(new MessageAuthorComparator());
Output:

2034-03-25 Alien wrote: Hello humans! (32)
2034-01-05 Pirate wrote: All hands on deck! (-2)
2033-01-14 Unregistered wrote: This message was marked as spam (-18)
2033-02-17 User765214 wrote: Bump! (1)

Поскольку Comparator имеет только один абстрактный метод (SAM) и, следовательно, является функциональным интерфейсом, мы можем использовать 
лямбда-функции для создания экземпляров компаратора. Например, вместо полного объявления класса мы можем переписать MessageDateComparator следующим образом:

Comparator<Message> dateComparator = (m1, m2) -> 
        m1.getCreated().compareTo(m2.getCreated());
messages.sort(dateComparator);

Мы даже можем избежать использования именованного объявления и передать лямбду непосредственно методу сортировки в качестве аргумента:

messages.sort((m1, m2) -> m1.getCreated().compareTo(m2.getCreated()));

Если вы не собираетесь повторно использовать объект компаратора, объявление его как отдельного класса было бы ненужным, поэтому вы можете просто определить 
его как лямбда - функцию и использовать его немедленно.

Comparator также имеет несколько неабстрактных методов, которые могут быть использованы для объединения компараторов для создания сложных условий для 
сравнения объектов. Давайте взглянем на некоторые из них.

Comparator.naturalOrder возвращает Comparator применимого типа, который сравнивает сопоставимые объекты в естественном порядке. Это означает, что если класс, 
который вы хотите сравнить с помощью этого метода, не реализует сопоставимый интерфейс, вы получите ошибку компиляции.

Comparator.ReverseOrder аналогичен приведенному выше, но сравнивает сопоставимые объекты, используя обратный естественный порядок.

reversed вызывается на Comparator и возвращает новый Comparator, который накладывает обратный порядок соответствующего Comparator.
Будьте осторожны при использовании метода reversed(): он перевернет всю цепочку предыдущих компараторов. Используйте круглые скобки, чтобы ограничить его 
область действия, если это необходимо.

Comparator.comparing принимает функцию, которая извлекает Comparable ключ сортировки и возвращает Comparator, который сравнивает объекты по этому ключу.

Comparator.thenComparing возвращает Comparator лексикографического порядка с функцией, которая извлекает Comparable ключ сортировки.

Пример:
Есть класс User с текстовым полем Name и int полем age. Необходим компаратор, который сравнит сначала имена, если имена одинаковые, то сравнит возраст в обратном порядке.
При использовании метода reverse(), важно заключить кострукцию в дополнительные скобки, чтобы обратный порядок применился только к этой части кода

public static void sortUsers(List<User> users) {
        users.sort(Comparator.comparing(User::getName)
                .thenComparing((Comparator.comparingInt(User::getAge).reversed())));
    }


Вот несколько примеров того, как мы можем использовать эти методы для сортировки коллекции в соответствии с нашими потребностями:

По дате, сначала новый, используя ссылку на метод для передачи функции извлечения ключа сортировки:

messages.sort(Comparator.comparing(Message::getCreated).reversed());
Output:

2034-03-25 Alien wrote: Hello humans! (32)
2034-01-05 Pirate wrote: All hands on deck! (-2)
2033-02-17 User765214 wrote: Bump! (1)
2033-01-14 Unregistered wrote: This message was marked as spam (-18)

По количеству лайков, в порядке убывания, а затем, для сообщений с равным количеством лайков, по имени автора, в порядке возрастания:

messages.sort(Comparator.comparing(Message::getLikes)
        .reversed()
        .thenComparing(Message::getFrom));

Comparator vs Comparable

Оба этих интерфейса обеспечивают схожую функциональность: они позволяют сравнивать объекты одного и того же класса. Какой из них вы должны выбрать? 
Это зависит от многих факторов.

Comparable определяет естественный порядок для объектов класса, реализующего его. Поэтому он идеально подходит в тех случаях, когда мы сравниваем объекты, 
которые по своей сути имеют определенный естественный порядок, такие как числа или даты. Если ваш класс имеет очевидный естественный порядок, то использование 
Comparable-это правильный путь.

В других случаях, когда ваш класс имеет несколько свойств, например, имя и возраст или цена, вы можете не определить естественный порядок для таких объектов. 
Кроме того, может возникнуть ситуация, когда класс, экземпляры которого необходимо сравнить, не реализует сопоставимый интерфейс, и вы не можете изменить 
исходный код этого класса. Во всех таких случаях интерфейс компаратора-это ваш выбор.

Кроме того, компаратор служит расширением и позволяет настраивать процесс сортировки. С его помощью вы можете легко переопределить естественный порядок или 
добавить новые правила сортировки объектов. Кроме того, это позволяет комбинировать порядок сортировки для создания сложной логики сортировки, основанной на 
различных свойствах объектов.

Пример:

import java.util.Comparator;

class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

class UserComparator implements Comparator<User> {

    @Override
    public int compare(User user1, User user2) {
        return user1.getName().compareTo(user2.getName());
    }
}


=====================================================================Deque=========================================================================================
Deque-это обобщение queue, которое позволяет вставлять и удалять элементы с обоих ее концов. Термин deque происходит от "двусторонней очереди". Он объединяет правила 
доступа, предоставляемые queue (FIFO) и stack (LIFO) вместе.

четыре основные операции:

1) вставьте элемент в начало;
2) вставьте элемент в конец;
3) удалите элемент из начала;
4) удалите элемент с конца.

В deque часто есть некоторые дополнительные операции, которые позволяют нам видеть первый и последний элементы, не удаляя их (исследуйте начало и конец), а также 
получать количество элементов в нем. Обычно deques не поддерживают индексацию, но некоторые реализации могут ее обеспечить.

Разработчики используют deque реже, чем обычные queue. Наиболее распространенными примерами deque являются:

1) undo-redo операции в программном обеспечении, таком как графические редакторы или IDE;
2) steal task scheduling algorithms процессор берет первую задачу из своего deque и выполняет ее; когда один из процессоров завершает выполнение своих собственных 
задач, он крадет последнюю задачу из deque другого процессора и выполняет ее.


==========================================================================Queue and Stack==============================================================================
Queue-это коллекция с ограниченным доступом к элементам: элементы вставляются в ее конец и удаляются из начала. Коллекция следует принципу "первым вошел-первым вышел" 
(FIFO). Queue предназначены для хранения элементов перед обработкой: задач, событий или чего-то еще.

Отличным примером Queue в реальной жизни является очередь студентов в фуд-корте. Новые люди встают в конец очереди, в то время как удаление (или обслуживание) происходит 
в начале очереди.

В Java все Queue представлены интерфейсом Queue<E>. Однако иерархия Queue сложнее, чем кажется на первый взгляд. Основными реализациями Queue<E> являются LinkedList<E> и 
ArrayDeque<E>. Существует также PriorityQueue, который мы рассмотрим в отдельной теме.

Обе основные реализации наследуют интерфейс Deque<E> , который расширяет Queue<E> и представляет собой двустороннюю очередь, поддерживающую принципы доступа FIFO и LIFO. 
В то же время класс LinkedList<E> также реализует интерфейс List<E>, поэтому его можно использовать как очередь и как список в зависимости от задачи.

Если вы пишете программу, которая обрабатывает небольшое количество элементов, нет большой разницы в том, какую реализацию использовать. Но для обработки огромного 
количества элементов ArrayDeque более эффективен в памяти, чем LinkedList, поскольку ему не нужно создавать внутренние узлы для каждого элемента.

The Queue<E> interface extends Collection<E> and adds some new methods:

boolean offer(E e) - вставляет указанный элемент в Queue, если это возможно сделать немедленно, не нарушая ограничений емкости; он возвращает true / false в зависимости 
от результата этой операции;
E remove() - извлекает и удаляет 1 элемент в начале Queue; если он пуст, метод вызывает исключение NoSuchElementException;
E poll() - извлекает и удаляет 1 элемент в начале Queue или возвращает значение null, если эта очередь пуста;
E element() - извлекает, но не удаляет 1 элемент в начале Queue; если он пуст, метод вызывает исключение NoSuchElementException;
E peek() - извлекает, но не удаляет 1 элемент в начале Queue или возвращает значение null, если эта очередь пуста.

Различия между некоторыми из этих методов и методами, унаследованными от Коллекции, могут быть не столь очевидными. Давайте посмотрим:

метод add(E e) делает то же самое, что и offer(E e), но вызывает исключение IllegalStateException, если в данный момент нет свободного места;
remove() и element() вызывает исключение NoSuchElementException, когда очередь пуста, но poll() и peek() в этом случае просто возвращают null.

Давайте рассмотрим пример использования ArrayDeque в качестве queue (FIFO).

Queue<String> q = new ArrayDeque<>();

q.offer("first");
q.offer("second");
q.offer("third");

System.out.println(q.peek()); // first
System.out.println(q.peek()); // first
System.out.println(q.poll()); // first,

System.out.println(q.peek()); // second
System.out.println(q.poll()); // second
System.out.println(q.poll()); // third

System.out.println(q.isEmpty()); // true

Просто помните, что peek() возвращает текущий head элемент, но не удаляет его из очереди, в то время как poll() делает это. Использование LinkedList в качестве 
Queue аналогично.

Как мы уже упоминали ранее, Deque<E> расширяет Queue<E> и представляет собой очередь, в которую можно вставлять и удалять элементы с обоих концов. Он объединяет 
правила доступа, предоставляемые очередью (FIFO) и стеком (LIFO) вместе.

Интерфейс Deque предоставляет методы для работы с первым и последним элементом очереди. Некоторые методы вызывают исключение, в то время как другие просто возвращают 
специальное значение (null). Посмотрите на таблицу:

			Throws exception	Special value		Throws exception	Special value
insert			addFirst(e)		offerFirst(e)		addLast(e)		offerLast(e)
remove			removeFirst()		pollFirst()		removeLast()		pollLast()
examine			getFirst()		peekFirst()		getLast()		peekLast()

Поскольку ArrayDeque и LinkedList реализуют этот интерфейс, они оба могут работать как очередь (FIFO), стек (LIFO) или deque.

Как вы, вероятно, помните, стек-это абстрактный тип данных, в котором элементы вставляются и удаляются в соответствии с принципом "последний вход-первый выход" (LIFO). 
Самый простой пример из реальной жизни-стопка книг. Только книга, помещенная сверху, может быть удалена за один раз, но новая книга всегда добавляется в верхнюю часть 
стопки.

The Standard Class Library предоставляет класс Stack, но, согласно JavaDoc, более полный и согласованный набор операций Stack LIFO обеспечивается интерфейсом Deque и 
его реализациями, которые следует использовать в предпочтении к этому классу. Таким образом, рекомендуется использовать Deque для стеков.

В следующем примере мы проиллюстрируем некоторые операции Deque, используя его в качестве стека.

Deque<String> stack = new ArrayDeque<>();

stack.offerLast("first");
stack.offerLast("second");
stack.offerLast("third");

System.out.println(stack); // [first, second, third]

System.out.println(stack.pollLast()); // third
System.out.println(stack.pollLast()); // second
System.out.println(stack.pollLast()); // first

System.out.println(stack.pollLast()); // null

Иногда старый класс Stack<E> с более минималистичным API можно найти в устаревшем исходном коде. Он не реализует интерфейс Deque или очереди. Вот простой пример.

Stack<String> stack = new Stack<>();

stack.push("first");
stack.push("second");
stack.push("third");

System.out.println(stack); // [first, second, third]

System.out.println(stack.pop()); // "third"
System.out.println(stack.pop()); // "second"
System.out.println(stack.pop()); // "first"

System.out.println(stack.pop()); // throws EmptyStackException

Если вам нужно работать с очередью (FIFO), попробуйте использовать ArrayDeque через стандартный интерфейс Queue. Эта реализация довольно эффективна, и интерфейс 
обеспечивает все необходимые операции. Если вам нужна работа со стеком (LIFO) или deque (FIFO+LIFO), попробуйте использовать ArrayDeque через интерфейс Deque, 
который обеспечивает операции для обоих концов очереди. LinkedList также можно использовать в качестве реализации, но он считается менее эффективным при работе с 
большим количеством элементов.


==============================================================The utility class Collections=============================================================================
Платформа Java Collections включает в себя класс Collections, который содержит ряд статических методов для создания и обработки коллекций. Некоторые из методов 
представляют собой generic алгоритмы, что означает, что они могут работать с различными типами коллекций.

Часто бывает так, что программисты забывают об этом классе и изобретают его методы с нуля. Очевидно, что лучше помнить об этом классе и проверить, содержит ли он 
операции, необходимые для выполнения с коллекцией.

Пожалуйста, не путайте класс Collections и интерфейс Collection. Они оба принадлежат к пакету java.util, но представляют собой совершенно разные вещи.

Первая группа-это набор методов для создания пустых и одноэлементных неизменяемых коллекций.

List<String> emptyList = Collections.emptyList();
Set<Integer> emptySet = Collections.emptySet();

List<Integer> singletonList = Collections.singletonList(100);
Set<String> singletonSet = Collections.singleton("Hello");

Использование этих методов выглядит довольно простым. Но зачем нам нужны пустые и одноэлементные коллекции? Например, пустые коллекции часто используются в качестве 
возвращаемых значений из методов вместо null, чтобы избежать NPE.

public static Collection<Integer> algorithm(Collection<Integer> numbers) {
    // lots lines of codes
    if (some_condition) {
        return Collections.emptyList(); // instead of null
    }
    // lots lines of codes
}

Одноэлементные коллекции чрезвычайно оптимизированы для работы с одним значением. В качестве примера класс singletonList<E> выглядит следующим образом:

class SingletonList<E> extends .. implements ... {

    private final E element;  // storing a single elment

    SingletonList(E obj) {
        element = obj;
    }

    // some fields and methods
}

Кроме того, класс также предоставляет методы для создания неизменяемых коллекций из других коллекций:

List<Integer> numbers = new ArrayList<>();
numbers.add(10);
numbers.add(12);
List<Integer> immutableList = Collections.unmodifiableList(numbers);

Существуют аналогичные методы: unmodifiableSet(набор) и другие.

Помните, что невозможно изменить элементы в неизменяемых коллекциях. Методы, которые изменяют элементы (add, clear и т. Д.), Будут вызывать исключение 
UnsupportedOperationException при вызове.

List<Integer> singletonList = Collections.singletonList(10);
singletonList.add(20); // throws UnsupportedOperationException

Начиная с Java 9, существует альтернативный способ создания неизменяемых коллекций: List.of(), List.of(1, 2), Set.of("Привет"). Но все же полезно знать о 
предыдущем способе сделать это, поскольку он часто присутствует в существующем коде.

There are also some methods for performing list-specific operations: sorting, reversing, rotating, and shuffling lists.

Check them out on the following example:

var numbers = new ArrayList<>(List.of(1, 2, 3, 2, 3, 4)); // getting a mutable list

Collections.sort(numbers);    // [1, 2, 2, 3, 3, 4]
Collections.reverse(numbers); // [4, 3, 3, 2, 2, 1]
Collections.shuffle(numbers); // randomly permutes the list

System.out.println(numbers);  // a result can be any: [4, 2, 3, 2, 3, 1]

Метод rotate сдвигает элементы в указанном списке на заданное расстояние.

List<Integer> numbers = new ArrayList<>(List.of(1, 2, 3, 2, 3, 4));

Collections.rotate(numbers, 1); // [4, 1, 2, 3, 2, 3]
Collections.rotate(numbers, 2); // [2, 3, 4, 1, 2, 3]

Есть некоторые методы, которые могут быть применены к любым коллекциям, так как методы принимают интерфейс Collection в качестве аргумента.

frequency - подсчитывает количество элементов, равное указанному объекту;
min and max - находит минимальные и максимальные элементы в соответствии с естественным порядком элементов;
disjoint - проверяет, не содержат ли две коллекции общих элементов.(если содержат, то возвращает false)

Вот пример применения перечисленных методов.

List<Integer> numbers = List.of(1, 2, 3, 2, 3, 4);

System.out.println(Collections.frequency(numbers, 3)); // 2
System.out.println(Collections.min(numbers)); // 1
System.out.println(Collections.max(numbers)); // 4

System.out.println(Collections.disjoint(numbers, List.of(1, 2))); // false
System.out.println(Collections.disjoint(numbers, List.of(5, 6))); // true

Если коллекция пуста, методы поиска min и max вызовут исключение NoSuchElementException. Но frequency просто вернет 0.

Мы хотели бы продемонстрировать один сложный и интересный пример с некоторыми операциями изменения неизменяемых коллекций. Просто взгляните на следующий код:

List<Integer> singletonList = Collections.singletonList(1);

Collections.sort(singletonList);    // it doesn't throw an exception
Collections.shuffle(singletonList); // it doesn't throw an exception

List<Integer> numbers = Collections.unmodifiableList(List.of(2, 1, 3));
Collections.shuffle(numbers); // it throws UnsupportedOperationException

Первая и вторая операции работают без исключения, так как список, содержащий только один элемент, не требует каких-либо изменений для сортировки или перетасовки, 
в отличие от списка с тремя элементами. Но если вы замените Collections.singletonList(1) на List.of(1), первая и вторая операции также завершатся неудачно. Даже 
неизменяемые коллекции имеют поведенческие особенности.

Чтобы не смущать других программистов, лучше не полагаться на такие несколько нелогичные функции Java в своих решениях, даже если они достаточно забавны. Через 
некоторое время вы также забудете, почему такой код работает.


====================================================================The Set interface=============================================================================
Если вам нужно сохранить только уникальные элементы в коллекции, чтобы избавиться от дубликатов в последовательности, или если вы намерены выполнить некоторые 
математические операции, вы можете использовать set.

Set-это набор уникальных элементов, подобных математическому набору. Set существенно отличается от массива или списка, так как невозможно получить элемент по его индексу.

Collections framework предоставляет интерфейс Set<E> для представления set в виде абстрактного типа данных. Он наследует все методы из интерфейса Collection<E>, но 
не добавляет новых. Наиболее широко используемые методы включают contains, add, addAll, remove, removeAll, size и другие, которые мы рассмотрели в предыдущем разделе о 
структуре коллекций.

Методы add и addAll добавляют элементы в набор только в том случае, если эти элементы еще не находятся в наборе. Набор всегда содержит только уникальные элементы.

Один метод заслуживает особого внимания, когда речь идет об интерфейсе Set<E>, так как он часто используется с наборами: 
retainAll(Collection<E> coll). способен сохранять все элементы из одного списка, которые также присутствуют в другом списке. Другими словами, метод retain() удаляет 
все элементы из целевого списка, которые не найдены в другом списке. Полученный список является пересечением двух списков.

Чтобы начать использовать set, вам необходимо создать экземпляр одной из его реализаций: HashSet, TreeSet и LinkedHashSet. Это изменяемые наборы, и они используют 
разные правила для упорядочения элементов и имеют некоторые дополнительные методы. Они также оптимизированы для различных типов операций. Существуют также неизменяемые 
наборы, имена которых не важны для программистов. Они также реализуют интерфейс Set<E>.

Самый простой способ создать set-вызвать метод of.

Set<String> emptySet = Set.of();
Set<String> persons = Set.of("Larry", "Kenny", "Sabrina");
Set<Integer> numbers = Set.of(100, 200, 300, 400);

Он возвращает неизменяемый set, содержащий либо все переданные элементы, либо пустой набор. Использование метода of удобно при создании заданных констант или 
тестировании некоторого кода.

Порядок элементов неизменяемых set не фиксирован:

System.out.println(emptySet); // []
System.out.println(persons);  // [Kenny, Larry, Sabrina] or another order
System.out.println(numbers);  // [400, 200, 300, 100] or another order

Одной из наиболее широко используемых операций seta является проверка того, содержит ли set элемент. Вот пример:

System.out.println(emptySet.contains("hello")); // false
System.out.println(persons.contains("Sabrina")); // true
System.out.println(persons.contains("John")); // false
System.out.println(numbers.contains(300)); // true

Для неизменяемых наборов можно вызывать только методы contains, size и isEmpty. Все остальные создадут исключение UnsupportedOperationException, так как 
попытаются изменить набор. Если вы хотите добавить / удалить элементы, используйте один из HashSet, TreeSet или LinkedHashSet.

1) HashSet

Класс HashSet представляет набор, поддерживаемый хэш-таблицей. Он использует хэш-коды элементов для их эффективного хранения. Он не дает никаких гарантий относительно 
порядка итераций набора; в частности, он не гарантирует, что порядок будет оставаться постоянным с течением времени.

В следующем примере показано создание HashSet и добавление в него стран (с дубликатом). Выходной результат не содержит дубликатов.

Set<String> countries = new HashSet<>();

countries.add("India");
countries.add("Japan");
countries.add("Switzerland");
countries.add("Japan");
countries.add("Brazil");

System.out.println(countries); // [Japan, Brazil, Switzerland, India]
System.out.println(countries.contains("Switzerland")); // true

Хотя технически порядок HashSet в некоторой степени определяется хэш-кодом, полагаться на такие функции-плохая практика, поскольку зависимость довольно сложная. 
HashSet следует рассматривать как неупорядоченный набор.

Класс HashSet обеспечивает постоянную производительность O(1) времени для основных операций (add, remove, and contains), при условии, что хэш-функция правильно 
распределяет элементы по сегментам.

На практике наборы часто используются для проверки того, принадлежат ли им некоторые элементы. Класс HashSet особенно рекомендуется для таких случаев, так как его 
работа с содержимым сильно оптимизирована.

2) TreeSet

Класс TreeSet представляет набор, который дает нам гарантии в отношении порядка элементов. Это соответствует порядку сортировки элементов, определяемому либо их 
естественным порядком (если они реализуют Comparable интерфейс), либо конкретной реализацией Comparator.

Порядок сортировки элементов такой же, как если бы вы использовали алгоритм сортировки массива или списка, содержащего эти элементы.

Класс TreeSet реализует интерфейс SortedSet, который расширяет интерфейс Set. Интерфейс SortedSet предоставляет некоторые новые методы, связанные с сравнением элементов:

Comparator<? super E> comparator() - возвращает компаратор, используемый для упорядочения элементов в наборе, или значение null, если набор использует естественный 
порядок своих элементов;
SortedSet<E> headSet(E toElement) - возвращает подмножество, содержащее элементы, которые строго меньше элемента toElement
SortedSet<E> tailSet(E fromElement) - возвращает подмножество, содержащее элементы, которые больше или равны fromElement
SortedSet<E> subSet(E fromElement, E toElement) - returns a subset containing elements in the range fromElement (inclusive) toElement (exclusive);
E first() returns the first (lowest) element in the set;
E last() returns the last (highest) element in the set.

The following example demonstrates some of the listed methods:

SortedSet<Integer> sortedSet = new TreeSet<>();

sortedSet.add(10);
sortedSet.add(15);
sortedSet.add(13);
sortedSet.add(21);
sortedSet.add(17);

System.out.println(sortedSet); // [10, 13, 15, 17, 21]

System.out.println(sortedSet.headSet(15)); // [10, 13]
System.out.println(sortedSet.tailSet(15)); // [15, 17, 21]
 
System.out.println(sortedSet.subSet(13,17)); // [13, 15] 

System.out.println(sortedSet.first()); // minimum is 10
System.out.println(sortedSet.last());  // maximum is 21

Обратите внимание, что HashSet намного быстрее TreeSet: постоянное время по сравнению с временем регистрации для большинства операций он не гарантирует упорядочения. 
Если вам нужно использовать операции из интерфейса SortedSet или требуется итерация с упорядочением значений, используйте TreeSet, в противном случае лучшим выбором 
будет HashSet.

3) LinkedHashSet

Класс LinkedHashSet представляет набор со связанными элементами. Он отличается от HashSet тем, что гарантирует, что порядок элементов совпадает с порядком, в котором 
они были вставлены в набор. Повторная вставка элемента, который уже находится в наборе LinkedhashSet, не изменяет этот порядок.

В некотором смысле LinkedHashSet является чем-то промежуточным между HashSet и TreeSet. Реализованный в виде хэш-таблицы со связанным списком, проходящим через нее, 
этот набор обеспечивает insertion-ordered  итерацию и выполняется почти так же быстро, как HashSet.

The following example demonstrates this.

Set<Character> characters = new LinkedHashSet<>();

for (char c = 'a'; c <= 'k'; c++) {
    characters.add(c);
}
        
System.out.println(characters); // [a, b, c, d, e, f, g, h, i, j, k]

В этом коде порядок символов всегда одинаков и соответствует порядку, в котором они вставляются в набор.

Реализация LinkedHashSet избавляет своих клиентов от хаотичного упорядочения, предоставляемого HashSet, без увеличения временных затрат на операции, связанные с 
TreeSet. Но LinkedHashSet требует больше памяти для хранения элементов.

Вы уже видели некоторые операции над наборами. Теперь давайте рассмотрим операции, которые обычно называются set theoretic operations, исходящими из математики. 
Забавно, что в Java они являются общими для всех коллекций, а не только для наборов.

Вот пример таких операций. Прежде всего, мы создаем изменяемый набор. Затем мы применяем к нему операции, изменяя элементы.

// getting a mutable set from an immutable one
Set<String> countries = new HashSet<>(List.of("India", "Japan", "Switzerland"));

countries.addAll(List.of("India", "Germany", "Algeria"));
System.out.println(countries ); // [Japan, Algeria, Switzerland, Germany, India]

countries.retainAll(List.of("Italy", "Japan", "India", "Germany"));
System.out.println(countries ); // [Japan, Germany, India]

countries.removeAll(List.of("Japan", "Germany", "USA"));
System.out.println(countries ); // [India]

После выполнения addAll set countries не содержит повторяющихся стран. Операции retainAll и removeAll влияют только на те элементы, которые указаны в переданных 
наборах. Также можно использовать любой класс, реализующий интерфейс Collection для этих методов (например, ArrayList).

In math and other programming languages, the demonstrated set operations are known as union (addAll), intersection (retainAll) and difference (removeAll).

Существует также метод, который позволяет нам проверить, является ли set подмножеством (т. Е. Содержится в) другом set.

Set<String> countries = new HashSet<>(List.of("India", "Japan", "Algeria"));

System.out.println(countries.containsAll(Set.of())); // true
System.out.println(countries.containsAll(Set.of("India", "Japan")));   // true
System.out.println(countries.containsAll(Set.of("India", "Germany"))); // false
System.out.println(countries.containsAll(Set.of("Algeria", "India", "Japan"))); // true

И последнее, но не менее важное-это то, как сравниваются наборы. Два набора равны, когда они содержат одни и те же элементы. Равенство не зависит от типов самих множеств.

Objects.equals(Set.of(1, 2, 3), Set.of(1, 3));    // false
Objects.equals(Set.of(1, 2, 3), Set.of(1, 2, 3)); // true
Objects.equals(Set.of(1, 2, 3), Set.of(1, 3, 2)); // true

Set<Integer> numbers = new HashSet<>();

numbers.add(1);
numbers.add(2);
numbers.add(3);

Objects.equals(numbers, Set.of(1, 2, 3)); // true


=================================================================The Map interface====================================================================================
В некоторых ситуациях вам необходимо хранить пары связанных объектов. Например, при подсчете количества слов в тексте первым является слово, а вторым-количество его 
вхождений в тексте. Существует особый тип коллекций, называемый map, для эффективного хранения таких пар объектов.

Map-это набор пар ключ-значение. Ключи всегда уникальны, в то время как значения могут повторяться.

Хорошим примером map из реального мира является телефонная книга, где ключи-это имена ваших друзей, а значения - это телефоны, связанные с ними.

Maps имеют некоторое сходство с наборами и массивами;

- ключи map образуют set, но каждый ключ имеет связанное значение;
- ключи map похожи на индексы массива, но ключи могут иметь любой тип, включая целые числа, строки и так далее.

The Collections Framework предоставляет интерфейс Map<K,V> для представления map в виде абстрактного типа данных. Здесь K-это тип ключей, а V-тип связанных значений. 
Интерфейс Map не является подтипом интерфейса Collection, но map часто рассматриваются как коллекции, поскольку они являются частью структуры.

Интерфейс объявляет множество методов для работы с map. Некоторые из методов похожи на методы Collection, в то время как другие уникальны для map.

1) Collection-like methods:

int size() returns the number of elements in the map;
boolean isEmpty() returns true if the map does not contain elements and false otherwise;
void clear() removes all elements from the map.

2) Keys and values processing:

V put(K key, V value) - связывает указанное значение с указанным ключом и возвращает ранее связанное значение с этим ключом или null
V get(Object key) - возвращает значение, связанное с ключом, или null в противном случае
V remove(Object key) - удаляет значение и ключ;
boolean containsKey(Object key) - возвращает значение true, если map содержит указанный ключ
boolean containsValue(Object value) - возвращает значение true, если map содержит указанное значение.

3) Advanced methods:

V putIfAbsent(K key, V value) - помещает пару, если указанный ключ еще не связан со значением (или сопоставлен со значением null), и возвращает значение null, 
в противном случае возвращает текущее значение;
V getOrDefault(Object key, V defaultValue) - возвращает значение, к которому сопоставлен указанный ключ, или значение по умолчанию, если map не содержит сопоставления 
для ключа.

4) Methods which return other collections:

Set<K> keySet() Returns a Set view of the keys contained in this map;
Collection<V> values() returns a Collection view of the values contained in this map;
Set<Map.Entry<K, V>> entrySet() returns a Set view of the entries (associations) contained in this map.

map.entrySet().removeIf(key -> key.getKey().length() >7);
map.entrySet().removeIf(value -> value.getValue().length() >7);
map.entrySet().removeIf(entry -> entry.getKey().length() > 7 || entry.getValue().length() > 7);

Чтобы начать использовать map, вам необходимо создать экземпляр одной из ее реализаций: HashMap, TreeMap и LinkedHashMap. Они используют разные правила для 
упорядочения элементов и имеют некоторые дополнительные методы.

The simplest way to create a map is to invoke the of method of the Map interface. The method takes zero or any even number of arguments in the format key1, value1, 
key2, value2, ... and return an immutable map.

Map<String, String> emptyMap = Map.of();

Map<String, String> friendPhones = Map.of(
        "Bob", "+1-202-555-0118",
        "James", "+1-202-555-0220",
        "Katy", "+1-202-555-0175"
);

Now let's consider some operations that can be applied to immutable maps using our example with friendPhones.

The size of a map equals to the number of pairs contained in it.

System.out.println(emptyMap.size());     // 0
System.out.println(friendPhones.size()); // 3

It is possible to get a value from a map by its key:

String bobPhone = friendPhones.get("Bob"); // +1-202-555-0118
String alicePhone = friendPhones.get("Alice"); // null
String phone = friendPhones.getOrDefault("Alex", "Unknown phone"); // Unknown phone

Note that the getOrDefault method provides a simple way to prevent NPE since it avoids null's.

Также можно проверить, содержит ли map определенный ключ или значение, используя методы containsKey и containsValue.

Мы можем напрямую получить доступ к set ключей и коллекции значений из map:

System.out.println(friendPhones.keySet()); // [James, Bob, Katy]
System.out.println(friendPhones.values()); // [+1-202-555-0220, +1-202-555-0118, +1-202-555-0175]

Since it is immutable, only methods that do not change the elements of this map will work. Others will throw an exception UnsupportedOperationException. 
If you'd like to put or to remove elements, use one of HashMap, TreeMap or LinkedHashMap.

1) HashMap

Класс HashMap представляет map, поддерживаемый хэш-таблицей. Эта реализация обеспечивает постоянную производительность методов get и put при условии, что хэш-функция 
правильно распределяет элементы между сегментами.

The following example demonstrates a map of products where key is the product code and value is the name.

Map<Integer, String> products = new HashMap<>();

products.put(1000, "Notebook");
products.put(2000, "Phone");
products.put(3000, "Keyboard");

System.out.println(products); // {2000=Phone, 1000=Notebook, 3000=Keyboard}

System.out.println(products.get(1000)); // Notebook

products.remove(1000);

System.out.println(products.get(1000)); // null

products.putIfAbsent(3000, "Mouse"); // it does not change the current element

System.out.println(products.get(3000)); // Keyboard

Эта реализация часто используется на практике, так как она высоко оптимизирована для размещения и получения пар.

2) LinkedHashMap

В LinkedHashMap хранится порядок, в котором были вставлены элементы.

Let's see a part of the previous example again:

Map<Integer, String> products = new LinkedHashMap<>(); // ordered map of products

products.put(1000, "Notebook");
products.put(2000, "Phone");
products.put(3000, "Keyboard");

System.out.println(products); // it's always ordered {1000=Notebook, 2000=Phone, 3000=Keyboard}

В этом коде порядок пар всегда одинаков и соответствует порядку, в котором они вставлены в map.

3) Класс TreeMap представляет map, которая дает нам гарантии порядка элементов. Это соответствует порядку сортировки ключей, определяемому либо их естественным 
порядком (если они реализуют интерфейс Comparable), либо конкретной реализацией Comparator.

Этот класс реализует интерфейс SortedMap, который расширяет интерфейс map. В нем представлены некоторые новые методы, связанные со сравнением ключей:

Comparator<? super K> comparator() - возвращает компаратор, используемый для упорядочения элементов map, или значение null, если map использует естественный порядок 
своих ключей;
E firstKey() returns the first (lowest) key in the map;
E lastKey() returns the last (highest) key in the map;
SortedMap<K, V> headMap(K toKey) returns a submap containing elements whose keys are strictly less than toKey;
SortedMap<K, V> tailMap(K fromKey) returns a submap containing elements whose keys are greater than or equal to fromKey;
SortedMap<K, V> subMap(K fromKey, E toKey) returns a submap containing elements whose keys are in range fromKey (inclusive) toKey (exclusive);

В приведенном ниже примере показано, как создать и использовать объект TreeMap. Эта карта заполнена событиями, каждое из которых имеет дату (ключ) и название (значение).

LocalDate-это класс, представляющий дату. Вызов метода LocalDate.of(год, месяц, день) создает указанный объект даты с заданными годом, месяцем и днем.

SortedMap<LocalDate, String> events = new TreeMap<>();

events.put(LocalDate.of(2017, 6, 6), "The Java Conference");
events.put(LocalDate.of(2017, 6, 7), "Another Java Conference");
events.put(LocalDate.of(2017, 6, 8), "Discussion: career or education?");
events.put(LocalDate.of(2017, 6, 9), "The modern art");
events.put(LocalDate.of(2017, 6, 10), "Coffee master class");

LocalDate fromInclusive = LocalDate.of(2017, 6, 8);
LocalDate toExclusive = LocalDate.of(2017, 6, 10);

System.out.println(events.subMap(fromInclusive, toExclusive));
The code outputs the resulting submap:

{2017-06-08=Discussion: career or education?, 2017-06-09=The modern art}

Используйте TreeMap только тогда, когда вам действительно нужен порядок сортировки элементов, так как эта реализация менее эффективна, чем HashMap.

Невозможно выполнить прямую итерацию map, так как она не реализует интерфейс Iterable. К счастью, некоторые методы map возвращают другие коллекции, которые можно 
использовать в цикле. Порядок элементов при итерации зависит от конкретной реализации интерфейса Map.

The following code shows how to get keys and values in a for-each loop:

Map<String, String> friendPhones = Map.of(
        "Bob", "+1-202-555-0118",
        "James", "+1-202-555-0220",
        "Katy", "+1-202-555-0175"
);

// printing names
for (String name : friendPhones.keySet()) {
    System.out.println(name);
}

// printing phones
for (String phone : friendPhones.values()) {
    System.out.println(phone);
}

Если вы хотите напечатать ключ и связанное с ним значение на одной и той же итерации, вы можете использовать entrySet().

for (var entry : friendPhones.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
This code prints all pairs as we expect:

Bob: +1-202-555-0118
James: +1-202-555-0220
Katy: +1-202-555-0175

We use var released in Java 10 to declare the loop's variable entry, but it is not necessary. If you have an older version of Java or just don't want to use var, 
you can write the data type explicitly like Map.Entry<String, String>.

The same behavior can be achieved by using a lambda expression with two arguments if you prefer this way:

friendPhones.forEach((name, phone) -> System.out.println(name + ": " + phone));

It is possible to store other collections as values in maps since collections are objects as well.

Here is an example with a map of synonyms:

Map<String, Set<String>> synonyms = new HashMap<>();

synonyms.put("Do", Set.of("Execute"));
synonyms.put("Make", Set.of("Set", "Attach", "Assign"));
synonyms.put("Keep", Set.of("Hold", "Retain"));

// {Keep=[Hold, Retain], Make=[Attach, Assign, Set], Do=[Execute]}
System.out.println(synonyms);

С другой стороны, хранение коллекций в качестве ключей карты не является обычным случаем и имеет некоторые ограничения. Такие ключи должны быть представлены 
неизменяемыми коллекциями.

Maps считаются равными, если они содержат одинаковые ключи и значения. Типы map не важны.

Таким образом, следующие map полностью равны:

Map<String, Integer> namesToAges1 = Map.of("John", 30, "Alice", 28);
Map<String, Integer> namesToAges2 = new HashMap<>();

namesToAges2.put("Alice", 28);
namesToAges2.put("John", 30);

System.out.println(Objects.equals(namesToAges1, namesToAges2)); // true

But the following two maps are different since the second map does not include "Alice":

Map<String, Integer> namesToAges1 = Map.of("John", 30, "Alice", 28);
Map<String, Integer> namesToAges2 = Map.of("John", 28);

System.out.println(Objects.equals(namesToAges1, namesToAges2)); // false


===========================================================================HashMap========================================================================================
Как вы уже знаете, существуют различные способы создания Map, заполненной парами ключ-значение. Сегодня пришло время внимательно взглянуть на HashMap: эффективный 
инструмент, который, вероятно, является самой популярной реализацией интерфейса Map. Он обеспечивает очень быстрый доступ к своим элементам и входит в десятку лучших 
вопросов на собеседованиях при приеме на работу в Java.

Класс HashMap представляет map, поддерживаемый хэш-таблицей. Чтобы понять, что это такое, давайте начнем с внутренней организации HashMap.

Если вы заглянете внутрь HashMap, вы увидите, что это массив с сегментами в качестве элементов. Размер такого массива по умолчанию равен 16.

Что означает "bucket(сегмент)" на языке программирования? На самом деле, каждый сегмент представляет собой LinkedList, то есть существует 16 LinkedList для хранения пар 
ключ-значение. И каждая пара ключ-значение является элементом LinkedList.

Теперь нам нужна специальная структура для хранения пар ключ-значение. Эта структура представляет собой класс Node<K, V>. В нем четыре поля: 
первое-hash, K key и V value, а последнее содержит ссылку на следующую пару Node<K, V> next.

Вот что происходит при добавлении пары ключ, значение: во-первых, генерируется хэш-код вашего ключа. Затем генерируется индекс корзины, который зависит от вычисленного 
хэша.
В этой формуле ниже n-количество корзин: index = hash & (n - 1)

Теперь, когда HashMap решил, в каком LinkedList будет храниться ваша пара, он проверит, пуст ли этот LinkedList. Если это так, ваша пара будет начальным элементом этого 
LinkedList. В противном случае ваша пара добавляется в конец.

Благодаря хэш-функции эта реализация обеспечивает постоянную производительность методов get и put! Постоянное время означает сложность O(1).

Map<Integer, String> characters = new HashMap<>();

characters.put(1000, "Cinderella");

Здесь мы создали HashMap под названием characters и добавили в нее "Cinderella". Там ровно 16 корзин. Класс рассчитал, что индекс новой корзины будет равен 8.

На рисунке вы можете видеть, что "Cinderella" является первым Node 8-го LinkedList. Как мы уже говорили ранее, Node имеет четыре поля.

В нашем примере хэш-код и ключ совпадают. Для класса Integer хэш-код совпадает с его значением.

Обратите внимание, что каждый класс имеет разную логику вычисления хэш-кода. Вы также можете переопределить метод hashCode.

Кроме того, полезно знать, что можно создать пару, в которой ключ будет равен null. Хэш-код null ключа всегда равен нулю.

Теперь давайте добавим больше персонажей и посмотрим, что произойдет:

characters.put(2000, "Prince");
characters.put(3000, "Evil stepmother");

// {2000=Prince, 1000=Cinderella, 3000=Evil stepmother}
System.out.println(characters); 

Character "Prince" decided to be in the bucket with index 0. He is also the first Node in his linked list.

But a stepmother can't be far away from poor Cinderella! "Evil stepmother"is also staying in the bucket with the number 8.

As you can see, the field next in Cinderella's Node has changed. Now the field has a link to the next character, "Evil stepmother".

Because the "Evil stepmother" became the last one in this linked list, her field next has value null.

Let's try to remove an element from HashMap characters:

characters.remove(3000); // get rid of Evil stepmother

System.out.println(characters.get(3000)); // null

An element "Evil stepmother" was deleted. "Cinderella" became the first and the last element of the eighth linked list again.

To see the structure of your HashMap, as in the pictures, you can use Debug mode in IntelliJ IDEA.

В классе HashMap существует множество различных методов. Мы рассмотрим только некоторые из них.

Получение элемента с помощью ключа:

System.out.println(characters.get(1000)); // Cinderella

Method putIfAbsent:

characters.putIfAbsent(2000,"Another Prince"); // nothing happens, because there is already a Prince

System.out.println(characters.get(2000)); // Prince

Check, if there are a concrete key or a value inside of HashMap:

System.out.println(characters.containsKey(1000)); // true
System.out.println(characters.containsValue("Fairy Godmother")); // false

Давайте рассмотрим несколько интересных моментов. Во-первых, вы, как инженер-программист, можете выбрать, какое количество сегментов будет в HashMap. 
Помните, что начальная capacity по умолчанию должна быть равной двум:

Map<String, String> map = new HashMap<>(32);

Еще один важный момент-collisions. Всегда существует вероятность ситуации, когда два разных ключа будут генерировать один и тот же хэш-код. Эта ситуация называется 
collision.

map.put("AaAaAa","First");
map.put("BBBBBB","Second");

Если два ключа имеют одинаковый хэш-код, но ключи разные, второй элемент будет помещен сразу после первого.

In this example keys "AaAaAa" and "BBBBBB" have the same hash code, and Node with the value "First" will have a link to the Node with the value "Second".

Метод equals используется для проверки того, отличаются ли два ключа. Если они одинаковы, то вторая пара заменит первую.

Если в HashMap много коллизий, сложность методов get и put становится O(n).

Because of that, class HashMap was upgraded. Since Java 8, it provides the collision resolution mechanism. If linked lists are too long then HashMap changes their 
structure: all linked lists become balanced trees. The new complexity is O(log(n)).

Наконец, важно отметить, что HashMap может изменять количество сегментов. Если в ваших корзинах слишком много пар, HashMap изменит свой размер на больший. Он перенесет 
все ваши предыдущие элементы в новую версию самого себя. Это, к сожалению, займет некоторое время. И чем больше элементов, тем больше времени займет перенос.

Класс HashMap часто используется на практике, так как он высоко оптимизирован для доступа к элементам. Кроме того, итерация по HashMap очень эффективна.

А как насчет недостатков? Ну, никто не идеален. Нет никакого способа избежать коллизий. Размер HashMap может увеличиться настолько, что для переноса всех элементов 
потребуется некоторое время.

Наконец, помните, что класс HashMap не дает никаких гарантий относительно порядка пар. Это также не гарантирует, что порядок будет оставаться постоянным с течением времени.


===================================================================Choosing the right collection===========================================================================
Как вы уже знаете, Java Collections включает в себя множество реализаций коллекций, таких как ArrayList, LinkedList, HashSet, TreeSet, HashMap и другие. В зависимости от 
выбранной реализации ваша программа будет иметь разную производительность по времени и памяти. В связи с этим крайне важно выбрать правильную коллекцию для конкретной 
проблемы, которую вы собираетесь решить.

Вы должны принять во внимание свойства различных коллекций, чтобы выбрать ту, которая будет работать лучше всего. Давайте вкратце вспомним их:

1) Тип элементов: различные реализации интерфейса List, Queue and Set хранят отдельные элементы, в то время как реализации интерфейса Map всегда хранят пары ключ-значение.
2) Дубликаты или уникальность элементов: реализации интерфейса Set хранят только уникальные элементы, в то время как List могут хранить дубликаты.
3) Тип доступа: ArrayList предоставляет доступ к своим элементам по индексу, но ArrayDeque предоставляет ограниченный доступ к первому и последнему элементу.
4) Производительность: обычно, чем более специфичной коллекцией вы пользуетесь, тем хуже производительность. Например, производительность LinkedHashSet хуже, чем у 
обычного HashSet.

1) Если вы не можете выбрать реализацию с использованием этой диаграммы в конкретном случае, мы рекомендуем вам предпочесть реализацию общего назначения: ArrayList, 
HashSet и HashMap. Их общая производительность выше, и в большинстве случаев их должно быть достаточно. Используйте их, если вам не нужна специальная функция, 
предоставляемая другой реализацией (например, упорядочение или сортировка).
2) Используйте наиболее абстрактный интерфейс, соответствующий вашему случаю, чтобы в будущем было легче изменить тип коллекции. Например, если вам нужна конкретная 
операция с List, используйте интерфейс List вместо ArrayList во всех методах, полях и локальных переменных. Если вам нужно использовать только такие методы, как 
add, remove, clear, а информация о порядке и дубликатах не важна, то предпочитайте использовать интерфейс Collection.
3) Если ни одна из реализаций не предоставляет необходимую вам функцию, вам может потребоваться использовать несколько коллекций одновременно, или использовать внешнюю 
библиотеку коллекций вместо стандартной, или создать новую.
4) Поскольку LinkedList реализует как интерфейсы List, так и интерфейсы Queue, иногда не совсем очевидно, что выбрать между ArrayList и LinkedList или LinkedList и 
ArrayDeque. В современных версиях Java коллекции на основе массивов считаются более производительными и должны использоваться в большинстве стандартных случаев. LinkedList 
можно выбрать, когда у вас огромное количество элементов и множество операций добавления/удаления, особенно в начале и в конце списка. Однако по-прежнему нет гарантии, 
что LinkedList будет действовать лучше других.


====================================================================Iterator and Iterable================================================================================
Как вы знаете, существует цикл for Each и метод forEach для перебора элементов коллекции. Оба они обеспечивают простой и унифицированный способ обработки различных типов 
коллекций. В этом разделе вы узнаете больше о том, почему они работают и как их использовать.

Стандартная библиотека Java имеет специальный интерфейс, называемый Iterable. Реализация этого интерфейса позволяет объектам класса быть целями цикла "for each". 
Collection интерфейс расширяет данный интерфейс.

public interface Collection<E> extends Iterable<E> { /* methods */ } 

The Collection interface extends Iterable, but Map does not.

Due to this, any collection class (List, Queue, Set) can be considered as Iterable.

Iterable<String> iterable = List.of("first", "second", "third");

Порядок элементов при итерации зависит от выбранной коллекции. Для List порядок такой же, как и порядок его элементов.

List<String> strings = List.of("first", "second", "third");

// the loop prints "first", "second", and then "third"
for (String elem : strings) {
    System.out.println(elem);
}

То же самое верно для метода forEach, который может принимать ссылку на метод:

// the loop prints "first", "second", and then "third"
strings.forEach(System.out::println);

Для Set ситуация иная, поскольку обычные Set не упорядочены. В качестве эксперимента вы можете заменить List следующим Set:

Set<String> strings = Set.of("first", "second", "third");

Результат может отличаться при каждом запуске программы.

интерфейс Iterable предоставляет три generic метода. В этой теме мы рассмотрим два из них:

1) Iterator<T> iterator() возвращает специальный объект, который может выполнять итерацию по коллекции;
2) void forEach(Consumer<T> action) выполняет действие и выполняет его для каждого элемента коллекции, его можно использовать вместе с лямбда-выражениями и 
method references.

Все коллекции, которые наследуют интерфейс Collection, имеют эти методы.

Iterator<T> - это универсальный механизм для перебора коллекций независимо от их структуры. Он принимает элементы в порядке, предусмотренном коллекцией. В некотором 
смысле это похоже на "указатель" на элемент коллекции.

Итератор позволяет удалять элементы из базовой коллекции, но вы не можете сделать это с помощью цикла for each.

Some methods of the Iterator<E> interface:

boolean hasNext() returns true if the iteration has more elements, and false otherwise;
E next() returns the next element in the iteration;
void remove() removes the last element returned by this iterator from the collection.

The for-each loop uses the first two methods under the hood.

Также можно напрямую получить доступ к итератору коллекции и использовать его. Типичное использование включает в себя три этапа:

1) Проверьте, есть ли в коллекции следующий элемент.
2) Получите следующий элемент.
3) Обработайте полученный элемент.

For example, let's remove all elements less than 10 from a sorted set.

Set<Long> set = new TreeSet<>(); // sorted set
set.add(10L);
set.add(5L);
set.add(18L);
set.add(14L);
set.add(9L);

System.out.println(set); // [5, 9, 10, 14, 18]

Iterator<Long> iter = set.iterator();
while (iter.hasNext()) {
    Long current = iter.next();
    if (current < 10L) {
        iter.remove();
    }
}

System.out.println(set); // [10, 14, 18]

Существует специальный итератор для List, называемый ListIterator, который расширяет общий интерфейс Iterator. Это позволяет программисту перемещаться по списку в любом 
направлении, изменять список во время итерации и получать текущую позицию в списке.

В дополнение к стандартным методам итератора, этот итератор предоставляет следующие методы:

int nextIndex() возвращает индекс элемента, который будет возвращен при вызове next;
boolean hasPrevious() возвращает значение true, если в списке есть предыдущий элемент;
E previous() возвращает предыдущий элемент в списке и перемещает положение курсора назад;
int previousIndex() возвращает индекс элемента, который был бы возвращен при вызове previous();
void set(E element) заменяет последний элемент, возвращенный next() или previous(), указанным элементом;
void add(E element) вставляет указанный элемент в список непосредственно перед элементом, который будет возвращен next(), и после элемента, который будет возвращен 
previous().

Here is an example of how it works:

List<Integer> list = List.of(1, 2, 3, 4);
ListIterator<Integer> iterator = list.listIterator(); // only for lists!

// go to the last element
while (iterator.hasNext()) { iterator.next(); }

// print elements in the backward order with their indexes
while (iterator.hasPrevious()) {
    int previousIndex = iterator.previousIndex();
    int element = iterator.previous();
    System.out.println(element + " on " + previousIndex);
}
This code prints numbers in the backward order with their indexes.

4 on 3
3 on 2
2 on 1
1 on 0

If you invoke previous before previousIndex the result will differ since previous changes the state of the iterator: the current position.



================================================Lambda expressions=============================================================
Как вы уже знаете, Java-это в первую очередь объектно-ориентированный язык программирования. Он поддерживает классы, методы, 
поля и другие концепции из этой парадигмы. Здесь методы являются основным способом представления поведения объектов, классов и 
целых программ. Вы можете написать абсолютно любой код внутри их тел, а затем вызвать этот код из других частей вашей программы, 
используя имена методов. Этот подход позволяет разработчикам создавать очень структурированные и хорошо читаемые программы, но 
иногда этого недостаточно, и мы должны использовать другие способы представления поведения, а не методы.

В этом разделе начинается объяснение другой парадигмы программирования, называемой функциональным программированием (FP), которая 
использует функции в качестве основной концепции, чтобы обеспечить альтернативный способ решения многих задач программирования. 
Как и методы, функции используются для разделения кода на небольшие фрагменты. Иногда эти понятия даже взаимозаменяемы. Однако, 
в отличие от методов, функции также могут вести себя как обычные объекты Java (например, передаваться/возвращаться в/из метода).

Конечно, невозможно объяснить всю парадигму сразу, поэтому будет много интересных тем. Первая концепция, которую мы изучим, - это 
лямбда-выражения, наиболее близкие к стандартным методам Java. Давайте посмотрим, что это такое и почему мы их используем.

Под лямбда-выражением (или просто "лямбда") мы подразумеваем функцию, которая не привязана к своему имени (анонимная функция), 
но может быть назначена переменной.

Наиболее общая форма лямбда-выражения выглядит следующим образом: (параметры) -> {тело};. Здесь часть до -> - это список 
параметров (как в методах), а часть после-это тело, которое может возвращать значение. Скобки { } требуются только для многострочных 
лямбда-выражений.

Иногда лямбды не имеют параметров или возвращаемых значений или даже того и другого. Даже если у лямбды нет возвращаемого значения, 
у нее есть тело, которое выполняет некоторые полезные действия (например, печатает или сохраняет что-то). Вы столкнетесь с практическими 
примерами таких лямбд в следующих разделах.

Еще одна важная вещь — как и обычный объект Java, лямбда-выражение всегда имеет специальный тип. В стандартной библиотеке Java представлено 
множество типов. В этой теме мы упомянем только два из них: Function and BiFunction. Оба класса, среди прочего, находятся в пакете java.util.function.

Давайте рассмотрим однострочное лямбда-выражение, которое просто умножает свои два параметра.

BiFunction<Integer, Integer, Integer> mult = (x, y) -> x * y;

Выражение имеет тип BiFunction<Integer, Integer, Integer>, что означает, что оно принимает два Integer и возвращает Integer.

// if it has only one argument "()" are optional
Function<Integer, Integer> adder1 = x -> x + 1;

// without type inference
Function<Integer, Integer> mult2 = (Integer x) -> x * 2;

// with multiple statements
Function<Integer, Integer> adder5 = (x) -> {
    x += 2;
    x += 3;
    return x;
};

После создания лямбда-выражения его можно использовать в других местах вашей программы, как обычный объект Java. 
Вы можете вызывать тело выражения с помощью специальных методов, таких как apply, столько раз, сколько вам нужно. 
Имя метода зависит от типа лямбда-выражения.

int result2x5 = mult.apply(2, 5); // 10
int result3x1 = mult.apply(3, 1); // 3

Один из самых популярных случаев-передать лямбда-выражение в метод, а затем вызвать его там.

Посмотрите на метод ниже. Он принимает объект стандартного generic типа Function.

private static void printResultOfLambda(Function<String, Integer> function) {
    System.out.println(function.apply("HAPPY NEW YEAR 3000!"));
}

Эта функция может принимать String и возвращать Integer.

Чтобы проверить метод, давайте создадим объект и передадим его в метод:

// it returns the length of a string
Function<String, Integer> f = s -> s.length();
printResultOfLambda(f); // it prints 20

Вы также можете передать лямбда-выражение методу напрямую без промежуточной ссылки:

// passing without a reference
printResultOfLambda(s -> s.length()); // the result is the same: 20

Как вы можете видеть, мы можем передать нашу функцию, представленную объектом, методу 
в качестве его аргумента, если метод принимает объект подходящего типа. Затем внутри метода будет вызвана данная функция.

Но зачем нам это нужно? Во-первых, давайте рассмотрим другой пример, в котором используется более сложное лямбда-выражение 
и вычисляется количество цифр в строке.

// It prints the number of digits: 4
printResultOfLambda(s -> {
    int count = 0;
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            count++;
        }
    }
    return count;
});

Что здесь важно? Мы передаем в printResultOfLambda не данные, а какой-то фрагмент кода в качестве данных. 
Таким образом, мы можем параметризовать один и тот же метод с другим поведением во время выполнения. 
Вот как выглядит типичное использование лямбда-выражений. Многие стандартные методы могут принимать лямбда-выражения.

Давайте введем важный термин в соответствии с примерами. В теории функционального программирования функция, которая 
принимает или возвращает другую функцию, называется функцией более высокого порядка. С точки зрения Java, мы говорим о 
методах или функциях, которые принимают/возвращают Function<T, R>, BiFunction<T, U, R> или другие типы.

Еще одним важным трюком с лямбда-выражениями является возможность захвата значений из контекста, в котором определена лямбда, 
и использования значений в теле. Эта техника называется closure.

Захват возможен только в том случае, если контекстная переменная имеет ключевое слово final или фактически является окончательной, 
т. Е. Переменная не изменяется в дальнейшем коде. В противном случае произойдет ошибка.

final String hello = "Hello, ";
Function<String, String> helloFunction = (name) -> hello + name;

System.out.println(helloFunction.apply("John"));
System.out.println(helloFunction.apply("Anastasia"));

Лямбда-выражение захватило final переменную hello.

The result of this code.

Hello, John
Hello, Anastasia

Давайте рассмотрим пример с фактически, но не физически final переменной.

int constant = 100;
Function<Integer, Integer> adder100 = x -> x + constant;

System.out.println(adder100.apply(200));
System.out.println(adder100.apply(300));

Переменная constant фактически является final и захватывается лямбда-выражением.

================================================Reflection basics==============================================================
Reflection - одна из самых мощных функций в Java. Reflection - это процесс доступа и изменения приложения во время выполнения. 
Это означает, что вы можете получать и изменять классы и их члены, такие как конструкторы, поля и методы во время выполнения.

Reflection Java реализуется пакетом java.lang.reflect. Хотя пакет Java.lang.reflect включает в себя множество интерфейсов, 
классов и исключений, на этом уровне вам нужно знать только четыре класса. Эти классы:

Field: вы можете использовать его для получения и изменения имени, значения, типа данных и модификатора доступа переменной.
Method: вы можете использовать его для получения и изменения имени, типа возвращаемого значения, типов параметров, модификатора 
доступа и типа исключения метода.
Constructor: вы можете использовать его для получения и изменения имени, типов параметров и модификатора доступа конструктора.
Modifier: вы можете использовать его для получения информации о конкретном модификаторе доступа.

Есть еще один важный момент. Вы не можете просто достичь отражения только с помощью пакета Reflect, о котором мы упоминали выше. 
Пакет Reflect может предоставить вам информацию о поле, методе или конструкторе класса, но сначала вы должны взять список полей, 
список методов и список конструкторов.

Это возможно с java.lang.Class и его статический метод forName(). Когда вы передаете имя любого класса методу forName(), он 
возвращает объект класса, содержащий информацию об этом классе.

java.lang.Class также имеет несколько методов, которые можно использовать для получения атрибутов (полей, методов, конструкторов) 
конкретного класса, переданного методу forName(). Вот некоторые из этих методов:

forName(String ClassName)
getSuperclass()
getConstructors()
getDeclaredConstructors()
getFields()
getDeclaredFields()
getMethods()
getDeclaredMethods()

Во-первых, каждый из этих методов, за исключением forName(), который мы уже обсуждали, возвращает массив объектов из классов 
java.lang.reflect. Например, GetFields() возвращает массив объектов из java.lang.reflect.Field класс. После этого вы можете 
использовать методы из пакета java.lang.reflect для получения дополнительной информации о конструкторах, полях и методах.

Во-вторых, getConstructors(), GetFields() и GetMethods() возвращают только public конструкторы, поля и методы из класса, 
представленного объектом класса. Эти методы также возвращают унаследованные общедоступные поля и методы из суперклассов.

Аналогично, getDeclaredConstructors(), getDeclaredFields(), getDeclaredMethods() возвращают все конструкторы, поля и методы из 
класса, представленного объектом класса Class. Эти методы не возвращают унаследованные поля и методы из суперклассов.

Предположим, что у вас есть класс под названием Student. Он имеет три public поля, одно protected поле и private поле. Он также 
имеет default конструктор и public конструктор. Класс Student также имеет private метод и public метод.

public class Student {
    public String firstName;
    public String lastName;
    public int age;
    protected String phoneNumber;
    private String accountNumber;
    
    Student(){
        System.out.println("This is default Constructor");
    }
    
    public Student(String firstName, String lastName){
        this.firstName= firstName;
        this.lastName= lastName;
        System.out.println("This is public Constructor");
    }
    
    private String sanitizeAccountNumber(String accountNumber){
        System.out.println("This is a private method to sanitize account number");
        //code to sanitize accountNumber goes here. 
        return accountNumber;
    }
    
    public void setAccountNumber(String accountNumber){
        accountNumber = sanitizeAccountNumber(accountNumber);
        this.accountNumber = accountNumber;
    }
}

Процесс reflection обычно состоит из трех этапов:

1. Получите java.lang.Class объект класса, используя метод forName(). В этом случае класс, который мы хотим отразить, - это Student.

Class student = Class.forName("Student");

2. Получите атрибуты класса в виде массива. В данном случае нас интересуют поля, конструкторы и методы.

Constructor[] declaredConstructors = student.getDeclaredConstructors();
Constructor[] constructors = student.getConstructors();
Field[] declaredFields = student.getDeclaredFields();
Field[] fields = student.getFields();
Method[] declaredMethods = student.getDeclaredMethods();
Method[] methods = student.getMethods();

3. Получите информацию об атрибутах класса и используйте ее. В этом случае мы собираемся получить имена 
конструкторов, полей и методов и распечатать их.

for(Constructor dc : declaredConstructors) {
    System.out.println("Declared Constructor " + dc.getName());
}
for (Constructor c : constructors) {
    System.out.println("Constructor " + c.getName());
}
for (Field df : declaredFields) {
    System.out.println("Declared Field " + df.getName());
}
for (Field f : fields) {
    System.out.println("Field " + f.getName());
}
for (Method dm : declaredMethods) {
    System.out.println("Declared Method " + dm.getName());
}
for (Method m : methods) {
    System.out.println("Method " + m.getName());
}

Когда вы запустите приведенный выше код, вы получите список конструкторов, полей и методов:

Declared Constructor Student
Declared Constructor Student
Constructor Student
Declared Field firstName
Declared Field lastName
Declared Field age
Declared Field phoneNumber
Declared Field accountNumber
Field firstName
Field lastName
Field age
Declared Method sanitizeAccountNumber
Declared Method setAccountNumber
Method setAccountNumber
Method wait
Method wait
Method wait
Method equals
Method toString
Method hashCode
Method getClass
Method notify
Method notifyAll

Вы можете видеть, что getDeclaredConstructor() вернул оба конструктора класса Student, в то время как getConstructors() вернул 
только public конструктор. Аналогично, getDeclaredFields() вернул все поля класса Student, в то время как GetFields() вернул 
только public поля.

Наконец, мы печатаем методы класса Student. Как и ожидалось, getDeclaredMethods() вернул оба метода. Теперь самое интересное, 
что GetMethods() вернул некоторые методы, отличные от setAccountNumber(), которые мы ожидали. Если вы помните, в одной из наших 
предыдущих тем мы упоминали, что java.lang.Object - это суперкласс всех классов, которые мы создаем. Класс Object имеет девять 
public методов, и все классы, которые мы создаем, наследуют эти методы. Вот почему вы можете увидеть девять дополнительных 
методов в выходных данных.


=======================================================Runtime type checking=======================================================
Переменная базового класса всегда может ссылаться на объект подкласса. Мы можем определить фактический тип указанного объекта 
во время выполнения.

Java предоставляет несколько способов сделать это:

- оператор instanceof, который можно использовать для тестирования, если объект имеет указанный тип;
- java reflection, которое можно использовать для получения объекта, представляющего класс.

Давайте рассмотрим эти способы проверки типов объектов во время выполнения.

Вот иерархия классов, которую мы будем использовать в примерах:

class Shape {...}

class Circle extends Shape {...}

class Rectangle extends Shape {...}

Иерархия очень проста, поля и методы классов скрыты для ясности. Однако эта иерархия довольно хорошо демонстрирует отношение "IS-А".

Двоичный оператор instanceof возвращает true, если объект является экземпляром определенного класса или его подкласса.

Базовый синтаксис выглядит следующим образом:

obj instanceof Class

Мы создали несколько экземпляров классов выше:

Shape circle = new Circle();  // the reference is Shape, the object is Circle
Shape rect = new Rectangle(); // the reference is Shape, the object is Rectangle

Давайте определим их типы:

boolean circleIsCircle = circle instanceof Circle; // true
boolean circleIsRectangle = circle instanceof Rectangle; // false
boolean circleIsShape = circle instanceof Shape; // true

boolean rectIsRectangle = rect instanceof Rectangle; // true
boolean rectIsCircle = rect instanceof Circle; // false
boolean rectIsShape = rect instanceof Shape; // true

Таким образом, оператор instanceof позволяет определить фактический тип объекта, даже если на него ссылается его суперкласс.

Как вы можете видеть, этот оператор рассматривает объект подкласса как экземпляр суперкласса:

boolean circleIsShape = circle instanceof Shape; // true

Обратите внимание, что тип рассматриваемого объекта должен быть подтипом (или типом) указанного класса. В противном случае 
возникнет ошибка компиляции.

Here is a non-compiled example:

Circle c = new Circle();
boolean circleIsRect = c instanceof Rectangle; // Inconvertible types

Каждый объект имеет метод getClass, который можно использовать для получения объекта, представляющего класс. Мы можем напрямую 
сравнивать классы, представленные объектами во время выполнения, используя java reflection.

Давайте рассмотрим пример. Вот пример Circle:

Shape circle = new Circle();

Давайте проверим это с помощью reflection:

boolean equalsCircle = circle.getClass() == Circle.class; // true
boolean equalsShape = circle.getClass() == Shape.class;   // false
boolean rectangle = circle.getClass() == Rectangle.class; // false

В отличие от оператора instanceof, этот подход выполняет строгое тестирование типов и не рассматривает объекты 
подкласса как экземпляры суперкласса.

Существует также другой способ проверки типов. Объект, представляющий класс, имеет метод isInstance, аналогичный ключевому слову 
instanceof.

boolean isInstanceOfCircle = Circle.class.isInstance(circle); // true
boolean isInstanceOfShape = Shape.class.isInstance(circle); // true
boolean isInstanceOfRectangle = Rectangle.class.isInstance(circle); // false 

Подобно оператору instanceof, этот метод рассматривает объект подкласса как экземпляр своего суперкласса. Однако, в отличие от 
оператора, следующий пример успешно скомпилирован:

Circle c = new Circle();
boolean circleIsRect = Rectangle.class.isInstance(c); // false

Если вы приведете объект суперкласса к его подклассу, вы можете получить исключение ClassCastException, если объект имеет другой тип. 
Перед приведением вы можете проверить фактический тип, используя один из подходов, которые мы рассмотрели в этом разделе.

Shape shape = new Circle();

if (shape.getClass() == Circle.class) {
    Circle circle = (Circle) shape;

    // now we can process it as a circle
}


==========================================================Hash table====================================================================
Давайте представим себе следующий сценарий: у вас много друзей и большая полка, полная книг. Некоторые из ваших друзей хотят одолжить 
ваши книги, некоторые хотят вернуть их, а некоторые хотят знать, есть ли у вас определенная книга. Итак, вы хотите написать программу, 
которая позволит вам добавлять книги, удалять книги и проверять, доступна ли книга. Для этого сценария, какую структуру данных лучше 
всего использовать?

Хэш-таблицы-это структуры, которые позволяют нам вставлять и удалять значения, а также проверять, присутствует ли значение во времени O(1) 
для каждой из этих операций. Только хэш-таблицы не могут гарантировать это время. Однако в сочетании с хорошей хэш-функцией все работает 
хорошо, что делает ее одной из лучших структур данных для этой цели.

Хэш-таблицы-это массивы, в которых каждая запись представляет собой ячейку. Ячейки могут содержать 0 или более значений типа. Они 
идентифицируются по их индексу в массиве. Если мы хотим вставить значение в хэш-таблицу, мы вычисляем его хэш-значение и вставляем его в 
ячейку с индексом, равным хэш-значению (по модулю размера массива, если хэш-значение слишком велико). Вы можете сделать то же самое, 
чтобы удалить объект или выполнить его поиск.

Давайте теперь рассмотрим пример. Допустим, у нас есть хэш-таблица с 5 ячейками, и мы вставляем целые числа {1, 3, 5, 6} с помощью хэш-функции 
идентификатора. Таблица выглядит следующим образом:

Index	0	1	2	3	4
Values	{5}	{1, 6}	{}	{3}	{}

Теперь давайте разберемся, как это работает. Поскольку мы используем функцию идентификации, хэш-значение равно самому значению. Из-за этого вы 
можете видеть, что 1 и 3 находятся в ячейках с индексами 1 и 3 соответственно. Теперь 5 и 6 имеют хэш-значения 5 и 6, но их слишком мало! Чтобы 
найти для них ячейку, мы берем модуль хэш-значения по общему количеству ведер, в данном случае 5. Таким образом, 5 по модулю 5 равно 0, а 6 по 
модулю 5 равно 1, и вы можете видеть в таблице, что значения помещены в правильные ячейки.

Существует два типа хэш-таблиц. Тот, что выше, называется hash set. Они могут использоваться в сценариях, где нам нужно только проверить, 
присутствует ли значение, например, сценарий книги во введении. Мы все еще можем добавлять или удалять элементы, но в большинстве случаев мы не 
заинтересованы в получении значения из hash setа, так как у нас уже есть равное значение, которое нам нужно для поиска в хэш-таблице. Реализации 
hash set являются unordered_set в C++ и HashSet в Java.

Другой тип хэш-таблицы-это hash map. Представьте, что вы хотите вести телефонную книгу с именами и номерами друзей и хотите искать телефонные 
номера, используя имя друга. Если бы вы сохранили hash set пар имя-номер, вам нужно было бы знать номер, чтобы иметь возможность искать. Здесь 
вам могут помочь hash map. Они очень похожи на hash set, но в них хранятся пары. Первая запись в паре называется ключом, а вторая-значением. 
Используется только хэш ключа, и при поиске мы ищем значение, связанное с ключом. В приведенном выше примере ключами будут имена, а значениями - 
номера телефонов. Реализации hash map являются unordered_map в C++ и HashMap в Java.

Иметь огромные ячейки - это всегда плохо! Представьте себе хэш - таблицу с одной ячейкой и огромным количеством элементов. Затем каждый раз, когда 
мы хотим что-то сделать, мы должны искать по всей ячейке, чтобы найти нужные нам элементы. Это то же самое, что поместить все элементы в массив 
без какого-либо порядка! Если бы мы позволили этому случиться, какой смысл использовать хэш-таблицу?

Теперь подумайте о более распространенном примере: хэш-таблица со 100 ячейками и 200 значениями в ней. Идеальная хэш - функция распределила бы 
значения равномерно, и у нас было бы по 2 значения в каждой ячейке. Затем, всякий раз, когда мы проверяем значение, мы должны проверить равенство 
с обоими значениями в соответствующей ячейке. Это неплохо, но в идеале ячейки должны иметь 1 или 0 элементов. Мы не всегда можем гарантировать это, 
но мы можем улучшить среднее число, если, например, у нас больше ячеек, чем элементов. Для этого мы должны ввести коэффициент нагрузки.

Коэффициент загрузки хэш-таблицы-это действительное число l между 0 и 1, которое говорит нам, насколько заполнена хэш-таблица. Мы можем вычислить 
его в любое время с помощью этой формулы:

	#elements
l = -----------------
	#buckets

Большинство хэш-таблиц имеют максимальный коэффициент загрузки α, постоянное число от 0 до 1, которое является верхним пределом для коэффициента 
загрузки. После того, как мы вставим новое значение в хэш-таблицу, мы рассчитаем новый коэффициент загрузки l. Если l > α. Затем мы увеличиваем 
количество сегментов в хэш-таблице, обычно создавая новый массив из вдвое большего количества сегментов и вставляя в него все значения из старого. 
Обратите внимание, что мы должны пересчитать индексы всех элементов, так как их индексы основаны как на значениях хэша, так и на общем количестве 
сегментов.

На этом рисунке показано, что чем меньше элементов в ячейке, тем лучше для производительности хэш-таблицы. Коэффициент загрузки помогает нам держать ячейки как 
можно ближе к пустым, насколько это возможно. Однако слишком низкий коэффициент загрузки также может быть плохим знаком, поскольку это означает, 
что мы используем много ненужной памяти для хранения пустых ячеек.

Помните, мы упоминали, что хэш-таблицы принимают O(1) для вставки или удаления значений или для поиска значения, если они используют хорошую 
хэш-функцию? Давайте посмотрим, почему это так!

Для всех этих операций хэш-таблица должна делать ровно 2 вещи: вычислять хэш-значение и искать начальное значение только в одной ячейке. Хорошая 
хэш-функция эффективна, поэтому для вычисления значения хэша требуется O(1), и она детерминирована, поэтому значение хэша будет одинаковым для 
любых равных значений, что означает, что мы будем искать правильную ячейку. Далее, хорошая хэш-функция однородна, поэтому не будет очень больших 
ячеек, в то время как другие пусты или почти пусты. Это, вместе с коэффициентом нагрузки, который мы объяснили выше, гарантирует, что в среднем 
в ячейке меньше одного элемента. Таким образом, поиск ячейки занимает время O(1). Наконец, мы можем реализовать ячейки так, чтобы вставка и удаление 
из них также занимали O(1), например, с помощью связанных списков. Таким образом, если мы используем хорошую хэш-функцию, все операции над 
хэш-таблицей будут принимать O(1).

- Хэш-таблицы-это структуры данных, которые поддерживают быструю вставку и удаление значений, а также проверку наличия значения.
- Хэш-таблицы состоят из блоков, содержащих одно, несколько или нулевое количество значений.
- Хэш-функции используются для определения ячейки для значения.
- hash set хранят объекты на основе их хэш-значений; hash map хранят пары ключ-значение на основе хэш-значений ключей.
- Коэффициент загрузки обычно используется для определения того, когда следует изменить размер хэш-таблицы.


================================================================Algorithms in Java===================================================================
Как вы знаете, алгоритмы не зависят от языка, то есть один и тот же алгоритм может быть реализован на разных языках, включая Kotlin, Python, C++ и так 
далее. Поскольку мы изучаем Java, мы будем реализовывать алгоритмы, использующие этот язык и его функции.

Стандартная библиотека Java включает в себя множество классических алгоритмов для решения типичных проблем, возникающих при написании программ. Эти 
алгоритмы написаны профессионалами, оптимизированы, хорошо протестированы и используются миллионами программистов по всему миру. Тем не менее, хорошо 
понять, как они работают внутри. Это помогает анализировать аналогичные алгоритмы из разных библиотек или разрабатывать новый алгоритм, настраивая 
хорошо известный для решения конкретной проблемы. Наконец, это хороший момент для практики Java!

Алгоритмы часто представлены в виде статических методов. Но это не единственный способ реализовать их в Java. Вот несколько примеров:

- в классе Arrays есть алгоритмы для манипулирования массивами, такие как сортировка и поиск;
- в классе Math есть математический алгоритм вычисления квадратного корня из числа.

Очень удобно разбивать алгоритмы на отдельные методы, а затем вызывать методы из внешнего кода, передавая входные значения (аргументы) и получая 
результат (результат).

Примечание: алгоритм, написанный на Java, может принимать входные значения не только из аргументов, но и из файла, базы данных, Интернета, а также 
выводить результат на консоль, файл и так далее.

Давайте рассмотрим простой алгоритм, написанный на Java, а затем типичную проблему, возникающую при реализации алгоритмов.

Следующий алгоритм находит индекс максимального числа в массиве int.

public static int findIndexOfMax(int[] numbers) {
    int index = 0;
    for (int i = 1; i < numbers.length; i++) {
        if (numbers[i] > numbers[index]) {
            index = i;
        }
    }
    return index;
}

Этот алгоритм реализован в виде статического метода с именем findIndexOfMax. Он принимает массив int и возвращает индекс max. 
Входной массив может быть как упорядоченным, так и неупорядоченным.

Давайте опишем алгоритм словами, чтобы лучше его понять:

1) Предположим, что число с индексом 0 (первый элемент) является кандидатом на максимальное значение.
2) В цикле мы берем следующий номер массива (от второго до последнего), пока конец массива не достигнут, и делаем (3), в противном случае переходим к (5).
3) Если взятое число больше, чем кандидат, сохраните его индекс (найден новый кандидат).
4) Перейдите к следующей итерации (2).
5) Возвращает индекс найденного кандидата.

Corner case-это ситуация, которая возникает, когда входные значения алгоритма могут привести к неправильному или неоднозначному поведению. Рассмотрение 
Corner case является важной частью разработки алгоритмов.

Давайте вернемся к нашему примеру алгоритма. Может показаться, что это хорошо работает. Но что делать, если массив содержит несколько чисел, которые 
равны максимуму? Кроме того, что делать, если массив пуст?

Actually, the presented algorithm finds the first maximum in the array.

findIndexOfMax(new int[] {3, 2, 8, 8, 1}); // 2

Иногда нам может понадобиться первый, а иногда и последний. Это зависит от проблемы, которую вы решаете.

If a passed array is empty, the method returns 0 as the index of the maximum number.

findIndexOfMax(new int[] {}); // 0

It may be better to return the special value -1 to mean that no maximum was found in the array. Let's add the special condition in the method:

if (numbers.length == 0) {
    return -1;
}


==================================================================Linear search===============================================================
Linear search (or sequential search) это простой алгоритм поиска элемента с определенным значением в массиве. Алгоритм проверяет каждый элемент 
массива до тех пор, пока не найдет целевое значение или не достигнет конца массива.

В худшем случае он выполняет именно n-сравнения, где n - длина входного массива. Временная сложность равна O(n).

Возможными модификациями алгоритма линейного поиска являются:

- проверьте, содержит ли массив элемент, верните true или false;
- поиск первого или последнего вхождения элемента в массиве;
- подсчитайте все вхождения элемента в массиве;
- поиск всех вхождений элемента в массиве;
- поиск элемента в подмассиве массива с заданными индексами.

Кроме того, алгоритм линейного поиска может использоваться в качестве подпрограммы в более сложных алгоритмах. Например, для подсчета всех 
вхождений всех элементов массива в другом массиве.

Если мы знаем, что наш массив отсортирован (например, в порядке возрастания), мы можем изменить алгоритм линейного поиска. Если следующий 
проверяемый элемент больше целевого значения, это означает, что мы не найдем значение в остальной части массива, и алгоритм должен остановиться.


================================================================Binary search===================================================================
Бинарный поиск - это быстрый алгоритм поиска элемента в отсортированном массиве. Алгоритм работает в логарифмическом времени, где затраченное
время O(log n), где n-длина входного массива.

Алгоритм начинается с сравнения среднего элемента массива с целевым значением. Если есть совпадение, он возвращает индекс элемента. В противном 
случае поиск продолжается в левом или правом подмассиве, в зависимости от того, меньше или больше целевое значение, чем средний элемент. Это 
продолжается до тех пор, пока не будет найдено целевое значение или новый интервал поиска не будет пуст.

================================================================Jump search=====================================================================
Jump search (also known as block search) представляет собой алгоритм для нахождения положения элемента в отсортированном массиве. В отличие от 
линейного поиска, он не сравнивает каждый элемент массива с целевым значением. Вместо этого, чтобы найти целевое значение, мы можем представить 
массив в виде последовательности блоков:

Оптимальный размер блока - sqrt(n) (квадратный корень), где n - размер массива. В этом случае алгоритм выполняет sqrt(n) + sqrt(n) сравнения в 
худшем случае, поэтому временная сложность равна O(sqrt(n)). Этот алгоритм более эффективен, чем алгоритм линейного поиска.

Рассмотрим основные принципы этого алгоритма поиска в отсортированных по возрастанию массивах. Обратите внимание, что он также может выполнять 
поиск в отсортированных по убыванию массивах.

Принцип 1. Для отсортированных по возрастанию массивов любое значение из блока меньше или равно любому значению из следующего блока.
Принцип 2. Если целевой элемент отсутствует в начале первого блока, а его правая граница превышает целевой элемент, он вообще не присутствует в 
массиве.

Алгоритм перепрыгивает через блоки, чтобы найти блок, который может содержать целевой элемент. Таким образом, алгоритм сравнивает правые границы 
блоков с целевым элементом.

Если правая граница блока равна целевому элементу, мы его нашли. Иногда нам нужно искать цель с минимальным индексом.

Если правая граница блока больше целевого элемента, мы нашли блок, который может содержать целевое значение. Когда мы находим такой блок, алгоритм 
выполняет обратный линейный поиск в этом блоке. Если он нашел целевое значение, он возвращает свой индекс; в противном случае массив не содержит 
целевого значения.

Иногда блоки не включают первый элемент массива, и тогда алгоритм работает так же, как описано выше. Сложность алгоритма не меняется.

Пожалуйста, имейте в виду следующее:

- Если sqrt(n) не является целочисленным значением, мы берем только целочисленную часть;
- Если индекс следующего элемента, к которому нужно перейти, больше индекса последнего элемента, мы переходим к последнему элементу.

Предположим, у нас есть отсортированный по возрастанию массив из девяти целых чисел: 10, 13, 19, 20, 24, 26, 30, 34, 35

Входной массив содержит девять элементов с индексами от 0 до 8. Мы хотим найти индекс значения 26 с помощью Jump search.

Нашим первым шагом будет поиск блока, который может содержать целевое значение. Длина прыжка sqrt(9) = 3

1) Первый элемент (10) меньше целевого значения (26), поэтому мы переходим к следующему элементу с индексом 0 + 3 = 3.
2) Элемент с индексом 3 (20) меньше целевого значения (26); мы переходим к следующему элементу с индексом 3 + 3 = 6.
3) Элемент с индексом 6 (30) больше целевого значения (26).
4) На этом этапе мы сохраняем индексы текущего и ранее рассмотренного элемента, чтобы использовать их на следующем этапе.
5) мы выполняем обратный линейный поиск. У нас есть левый и правый индексы блока, которые могут содержать целевое значение. Теперь мы рассмотрим 
только элементы, относящиеся к этому блоку.

В этом алгоритме, как только мы находим блок, который может содержать значение, мы выполняем обратный линейный поиск. Однако то, что мы также могли 
бы сделать, - выполнить еще один поиск перехода в блоке (назад или вперед), а затем рекурсивно выполнить поиск перехода, пока у нас не останется 
только один элемент.

Эта версия будет выполнять sqrt(n) + sqrt(sqrt(n)) + sqrt(sqrt(sqrt(n)) + ... + 1 сравнение в худшем случае. Это быстрее, чем базовая реализация, но 
все равно скорость равна O(sqrt(n)).


=================================================================Linear search in Java===============================================================
Linear (sequential) search это простой алгоритм поиска значения в массивах или аналогичных коллекциях. Алгоритм проверяет каждый элемент массива, пока 
не найдет тот, который соответствует целевому значению. Если алгоритм достигает конца массива, он завершается неудачно. В худшем случае он выполняет 
именно сравнения n, где n-длина входного массива, содержащего данные.

Этот алгоритм также может быть изменен для проверки того, содержит ли массив целевой элемент, для поиска первого/последнего вхождения элемента, для 
поиска значения в определенном диапазоне индексов или для подсчета всех вхождений целевого элемента.

Давайте рассмотрим реализацию алгоритма в Java как обычный статический метод. Метод принимает массив int и число для поиска в массиве. Он возвращает 
индекс найденного элемента или, если ничего не найдено, -1.

public static int search(int[] array, int value) {
    int index = -1;
    for (int i = 0; i < array.length; i++) {
        if (array[i] == value) {
            index = i;
            break;
        }
    }
    return index;
}

Реализация сравнивает каждый элемент входного массива с переданным значением в цикле. Если элемент равен значению, цикл останавливается, и метод 
возвращает найденный индекс. Если в массиве не найдено никакого значения, метод возвращает значение -1.

Обратите внимание, что этот алгоритм работает как для отсортированных, так и для несортированных массивов. Мы можем сделать алгоритм более эффективным 
при поиске элемента в отсортированном массиве; вот модифицированная версия алгоритма:

public static int searchInSortedArray(int[] array, int value) {
    int index = -1;
    for (int i = 0; i < array.length; i++) {
        if (array[i] == value) {
            index = i;
            break;
        } else if (array[i] > value) {
           break;
        }
    }
    return index;
}

Если следующий проверенный элемент больше переданного значения, это означает, что мы не найдем значение в массиве и можем остановиться.

Алгоритм выполняет только два сравнения, чтобы подтвердить, что элемент не содержится в массиве. Таким образом, мы проверяем меньшее количество элементов, 
когда передаваемое значение не содержится в массиве и меньше, чем максимальный элемент. В противном случае алгоритм по-прежнему выполняет n-сравнения, а 
временная сложность составляет O(n)


===============================================================Binary search in Java==========================================================================
Бинарный поиск-это быстрый алгоритм поиска положения элемента в отсортированном массиве. Для массива размера n время выполнения алгоритма равно O(log n) в 
худшем случае.

Алгоритм начинается с сравнения среднего элемента массива с целевым значением. Если целевое значение соответствует среднему элементу, возвращается его позиция 
в массиве. Если целевое значение меньше или больше среднего элемента, поиск продолжается в левом или правом подмассиве соответственно, исключая из рассмотрения 
другой подмассив. Он повторяется до тех пор, пока значение не будет найдено или новый интервал поиска не будет пустым.

Хотя основная идея двоичного поиска выглядит очень простой, реализация требует некоторой осторожности с индексами и условиями массива.

Итеративная реализация использует цикл для итерации по массиву. Если рассматриваемый интервал пуст, цикл останавливается, и метод возвращает -1, что указывает 
на то, что элемент не найден.

public static int binarySearch(int[] array, int elem, int left, int right) {
    while (left <= right) {
        int mid = left + (right - left) / 2; // the index of the middle element
            
        if (elem == array[mid]) {
            return mid; // the element is found, return its index
        } else if (elem < array[mid]) {
            right = mid - 1; // go to the left subarray
        } else {
            left = mid + 1;  // go to the right subarray
        }
    }
    return -1; // the element is not found
}

Метод принимает массив int, искомый элемент и две границы подмассива, в котором мы ищем элемент. Последние два параметра не являются обязательными, 
но они полезны, если мы также хотим иметь возможность искать не во всем массиве.

Рекурсивная реализация выполняет рекурсивный вызов вместо использования цикла. Он не вызывает StackOverflowError, потому что он не делает много 
рекурсивных вызовов даже для больших массивов.

public static int binarySearch(int[] array, int elem, int left, int right) {
    if (left > right) {
        return -1; // search interval is empty, the element is not found
    }
        
    int mid = left + (right - left) / 2; // the index of the middle element
        
    if (elem == array[mid]) {
        return mid; // the element is found, return its index
    } else if (elem < array[mid]) {
        return binarySearch(array, elem, left, mid - 1); // go to the left subarray
    } else {
        return binarySearch(array, elem, mid + 1, right); // go to the right subarray    
    }
}

Существуют различные способы вычисления индекса среднего элемента:

Самый простой-суммировать обе границы и делить их на две:

int mid = (left + right) / 2;

Но у этой простой формулы есть один недостаток: она не работает при больших значениях left и right, когда сумма больше максимального положительного значения int. 
Сумма перетекает в отрицательное значение, и индекс будет отрицательным при делении на два.

Более длинная формула защищает нас от переполнения int. Мы использовали его в наших реализациях бинарного поиска.

int mid = left + (right - left) / 2;

На самом деле, это то же самое, что и предыдущая формула, но защищает нас от переполнения int.

left + (right - left) / 2 = (2 * left + right - left) / 2 = (left + right) / 2

Using a bitshift operator:

int mid = (left + right) >>> 1;

Обратите внимание, что итеративные и рекурсивные реализации эквивалентны. Используйте любой из них в образовательных целях. Но помните, что двоичный поиск 
реализован в стандартной библиотеке Java, см. java.util.Arrays.BinarySearch(...) для получения подробной информации. Он работает для различных типов данных, 
включая целые числа, символы, строки и так далее.


=================================================================Jump search in Java==========================================================================
Jump search (также известный как block search) - это алгоритм поиска положения элемента в отсортированном массиве. В отличие от линейного поиска, он не 
сравнивает каждый элемент массива с целевым значением. Он разбивает данный массив на последовательность блоков, а затем перепрыгивает через них, чтобы найти блок, 
который может содержать целевой элемент. Для этого алгоритм сравнивает правые границы блоков с целевым элементом.

Если nn-размер блока, алгоритм выполняет sqrt(n) + sqrt(n) сравнения в худшем случае. Это означает, что временная сложность равна O(sqrt(n)) это более эффективно, 
чем линейный поиск.

Давайте рассмотрим, как алгоритм может быть реализован в Java. Метод jumpSearch находит блок, в котором может быть представлен целевой элемент, а затем вызывает 
backwardSearch для поиска элемента в этом блоке.

public static int jumpSearch(int[] array, int target) {
    int currentRight = 0; // right border of the current block
    int prevRight = 0; // right border of the previous block

    /* If array is empty, the element is not found */
    if (array.length == 0) {
        return -1;
    }

    /* Check the first element */
    if (array[currentRight] == target) {
        return 0;
    }

    /* Calculating the jump length over array elements */
    int jumpLength = (int) Math.sqrt(array.length);

    /* Finding a block where the element may be present */
    while (currentRight < array.length - 1) {

        /* Calculating the right border of the following block */
        currentRight = Math.min(array.length - 1, currentRight + jumpLength);

        if (array[currentRight] >= target) {
            break; // Found a block that may contain the target element
        }

        prevRight = currentRight; // update the previous right block border
    }

    /* If the last block is reached and it cannot contain the target value => not found */
    if ((currentRight == array.length - 1) && target > array[currentRight]) {
        return -1;
    }

    /* Doing linear search in the found block */
    return backwardSearch(array, target, prevRight, currentRight);
}

public static int backwardSearch(int[] array, int target, int leftExcl, int rightIncl) {
    for (int i = rightIncl; i > leftExcl; i--) {
        if (array[i] == target) {
            return i;
        }
    }
    return -1;
}

Эта реализация может показаться немного громоздкой, но у нее есть свои преимущества:

- если массив пуст, он немедленно возвращает результат (не найден);
- если первый элемент соответствует цели, он немедленно возвращает результат (найдено);
- если цель не найдена в блоке, в котором она могла бы присутствовать, алгоритм не выполняет поиск в оставшихся блоках, которые не могут содержать цель 
(он полагается на то, что входной массив отсортирован).


==========================================================================The sorting problem============================================================================
Визуальное отображение работы сортировок https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

Проблема сортировки часто возникает в практике программирования, когда нам приходится упорядочивать последовательность элементов. Требуемый порядок может быть восходящим 
или нисходящим. Часто порядок по возрастанию считается по умолчанию.

Для представления последовательностей элементов многие языки поддерживают массивы или/и списки.

Многие языки программирования предоставляют встроенные алгоритмы сортировки списков и массивов. В информатике существует множество различных алгоритмов сортировки, и в 
этой теме мы изучим некоторые из них.

Можно сортировать данные разных типов:

- числа в соответствии с арифметическим порядком;
- Символы Юникода в соответствии с их порядком в таблице символов Юникода;
- строки (лексикографически или по размеру);
- даты и время в соответствии с хронологическим порядком.

Кроме того, часто можно сортировать данные более сложных типов, если мы знаем, как сравнивать элементы. Как правило, такие данные имеют одно или несколько полей, 
называемых ключами сортировки, по которым выполняется сортировка.

Ключевые особенности алгоритмов сортировки:

1) Эффективность затраченного времени. Размер массива для сортировки очень важен для эффективности. Если мы хотим отсортировать массив, состоящий из нескольких десятков 
элементов, мы можем использовать любой алгоритм сортировки. Но что, если массив содержит много данных? В этом случае мы должны использовать только эффективные алгоритмы 
сортировки, иначе результаты могут занять слишком много времени.

2) Стабильность. Массив для сортировки может содержать несколько одинаковых элементов. Алгоритмы стабильной сортировки всегда сортируют идентичные элементы в том же 
порядке, в каком они отображаются во входных данных. В противном случае алгоритм сортировки нестабилен. Стабильность важна, когда мы сортируем сложные структуры, такие как 
объекты, кортежи или что-то еще.

3) In-place/out-of-place sorting. Алгоритм выполняет сортировку In-place, если для этого требуется только постоянное количество дополнительного пространства, в противном 
случае алгоритм выполняет сортировку out-of-place. Чем больше размер массива, тем больше дополнительной памяти требуется для алгоритмов out-of-place.

4) Internal or external sorting. Алгоритм выполняет внутреннюю сортировку, если данные сортировки хранятся полностью в основной памяти компьютера. Внешняя сортировка 
требуется, когда данные не помещаются в основную память вычислительного устройства и вместо этого они должны храниться в более медленной внешней памяти (обычно на жестком 
диске).

Многие алгоритмы сортировки сравнивают элементы массива во время сортировки, но некоторые алгоритмы используют для сортировки другие методы. Такие алгоритмы также известны 
как non-comparison sorting algorithms.


============================================================================Insertion sort=================================================================================
Insertion sort - это простой алгоритм сортировки, который выполняет In-place сортировку. Он делит массив на отсортированную и несортированную части. На каждой итерации 
алгоритм перемещает элемент из несортированной части в отсортированную до тех пор, пока все элементы массива не будут отсортированы. Текущий элемент вставляется в 
подходящее положение в отсортированной части.

Алгоритм работает следующим образом:

1) Предположим, что первый элемент принадлежит отсортированной части массива, а все остальные элементы находятся в несортированной части;
2) Выберите первый элемент из несортированной части и вставьте этот элемент в отсортированном списке в подходящей позиции;
3) Повторяйте шаги 1-2, пока все элементы не будут отсортированы.

Основная операция-вставка значения в отсортированную часть. Операция не должна нарушать отсортированную часть, то есть она всегда остается отсортированной. Предположим, мы 
сортируем массив в порядке возрастания. Подходящей позицией для текущего элемента является последний индекс в отсортированной части, где предыдущий элемент меньше или 
равен текущему.

Алгоритм не подходит для больших массивов, так как его средняя и наихудшая временная сложность составляет Ο(n^2), где n - длина массива.

Алгоритм стабилен: он не изменяет относительный порядок одинаковых элементов.

Предположим, у нас есть несортированный массив целых чисел. Наша задача-отсортировать его в порядке возрастания.

21 23 19 30 11 28

Массив состоит из шести элементов, первый элемент имеет индекс 0, последний-индекс 5.

1) Отсортированная часть включает только один элемент с индексом 0. Это первый элемент в массиве. Давайте рассмотрим второе (23). Он больше, чем последний элемент в 
отсортированной части, поэтому мы его не перемещаем.
2) Отсортированная часть включает элементы с индексами 0-1. Рассмотрим элемент с индексом 2 (19). Это меньше, чем последний элемент в отсортированной части, поэтому мы 
перемещаем его влево, пока он не станет меньше предыдущего элемента. После перемещения он имеет индекс 0.
3) Отсортированная часть включает элементы с индексами 0-2. Рассмотрим элемент с индексом 3 (30). Он больше, чем последний элемент в отсортированной части, поэтому мы его 
не перемещаем.
4) Отсортированная часть включает элементы с индексами 0-3. Рассмотрим элемент с индексом 4 (11). Это меньше, чем последний элемент в отсортированной части, поэтому мы 
перемещаем его влево, пока он не станет меньше предыдущего элемента. После перемещения он имеет индекс 0.
5) Отсортированная часть включает элементы с индексами 0-4. Рассмотрим элемент с индексом 5 (28). Это меньше, чем последний элемент в отсортированной части, и мы 
перемещаем его влево, пока он не станет меньше предыдущего элемента. После перемещения он имеет индекс 4.
6) Весь массив отсортирован.


============================================================================Insertion sort in Java=========================================================================
Insertion sort - это простой алгоритм сортировки, который выполняет in-place сортировку. Он делит массив на отсортированную и несортированную части. На каждой итерации 
алгоритм перемещает элемент из несортированной части в отсортированную до тех пор, пока все элементы в массиве не будут отсортированы. Подвижный элемент вставляется в 
подходящее положение в отсортированной части. Для массива размером n алгоритм выполняет O(n^2) операции в худшем случае.

Алгоритм стабилен, т. е. он не изменяет относительный порядок одинаковых элементов.

В следующем коде алгоритм Insertion sort реализован как статический метод. Он имеет два цикла. Во внешнем цикле он принимает следующий элемент, а во вложенном цикле 
перемещает элемент в отсортированную часть, сохраняя порядок.

public static int[] insertionSort(int[] array) {
    /* iterating over elements in the unsorted part */    
    for (int i = 1; i < array.length; i++) {        
        int elem = array[i]; // take the next element
        int j = i - 1;
            
        /* find a suitable position to insert and shift elements to the right */
        while (j >= 0 && array[j] > elem) {
            array[j + 1] = array[j]; // shifting
            j--;
        }
        array[j + 1] = elem; // insert the element in the found position in the sorted part
    }
        
    return array;
}

=================================================================================Merge sort================================================================================
Merge sort является эффективным алгоритмом сортировки на основе сравнения. Алгоритм основан на методе "разделяй и властвуй". Он делит данный несортированный массив 
размером n на n одноэлементных подмассивов, которые уже отсортированы, а затем повторно объединяет подмассивы для создания вновь отсортированных подмассивов, пока не 
останется только один подмассив.

В алгоритме слияние является основной операцией. Он создает новый отсортированный массив из двух входных отсортированных массивов.

Алгоритм Merge sort и его модификации лучше, чем примитивные алгоритмы сортировки, такие как сортировка пузырьком, insertion sort и selection sort. Merge sort может 
использоваться для сортировки даже больших массивов.

Алгоритм может быть реализован двумя способами:

1) top-down это рекурсивная реализация, которая рекурсивно делит данный массив на два подмассива до тех пор, пока не останется только одноэлементный подмассив; затем она 
объединяет результаты вместе, чтобы получить сортированный подмассив большего размера;

2) bottom-up это итеративная реализация, которая сначала объединяет пары смежных одноэлементных массивов и создает сортированные подмассивы из 2 элементов, затем 
объединяет пары смежных массивов из 2 элементов, создавая сортированные подмассивы из 4 элементов, затем объединяет пары из 4 элементов и так далее, пока весь массив не 
будет объединен (отсортирован).

Рассмотрим следующие свойства Merge sort:

- независимо от реализации, алгоритм имеет временную сложность O(n log n) в худшем и среднем случаях;
- сортировка слиянием стабильна;
- в типичной реализации это не алгоритм in-place.

Предположим, у нас есть несортированный семиэлементный массив целых чисел:

30 21 23 19 28 11 23

Мы должны отсортировать массив в порядке возрастания, используя top-down merge sort. На следующем рисунке показано, как это работает:

Сначала мы вычисляем индекс среднего элемента (3) в массиве, а затем разделяем массив на два подмассива. Первый подмассив { 30, 21, 23 } содержит элементы слева 
направо (не включая индекс middle элемента), второй подмассив { 19, 28, 11, 23 } содержит элементы справа от середины. Подмассивы имеют разные размеры, но это не проблема 
для алгоритма.

Мы рекурсивно разделяем первый подмассив, чтобы создать новые подмассивы, используя то же правило, а затем делаем то же самое для второго подмассива. Первое подмножество 
{ 30 }, второе подмножество { 21, 23 }. Мы не разделяем подмассив { 30 }, потому что он содержит только один элемент. Затем мы разделяем подмассив { 21, 23 } на новые 
подмассивы { 21 } и { 23 }, которые уже отсортированы. Затем мы объединяем их, чтобы сохранить порядок возрастания, результат { 21, 23 }. Затем мы объединяем его с 
массивом { 30 }, в результате получаем сортированный подмассив { 21, 23, 30 }. После этого мы выполняем те же операции для подмассива { 19, 28, 11, 23 }. В результате 
получается { 11, 19, 23, 28 }.

Последняя операция (20) объединяет два отсортированных подмассива { 21, 23, 30 } и { 11, 19, 23, 28 } для создания отсортированного массива { 11, 19, 21, 23, 23, 28, 30 }.

При таком разделении массива иногда второй подмассив длиннее первого. Если мы включим средний элемент в первый подмассив и исключим его из второго, ситуация будет 
обратной. К счастью, оба случая работают хорошо.

Мы также можем отсортировать массив с помощью bottom-up merge sort. Это иллюстрирует следующее изображение:

Мы предполагаем, что входной массив разделен на последовательность одноэлементных подмассивов: { 30 }, { 21 }, { 23 }, { 19 }, { 28 }, { 11 }, { 23 }. Мы начинаем 
объединять пары смежных массивов для создания отсортированных двухэлементных массивов и одноэлементного подмассива. В результате получается 
{ 21, 30 }, { 19, 23 }, { 11, 28 }, { 23 }. Результатом после следующего слияния является { 19, 21, 23 , 30 }, { 11, 23, 28 }. Затем мы объединяем два подмассива, чтобы 
создать упорядоченный входной массив: { 11, 19, 21, 23, 23, 28, 30 }.

Алгоритм сортировки слиянием имеет множество различных модификаций.

- In-place merge sort, которая представляет собой более сложный алгоритм;
- Timsort представляет собой гибридный стабильный алгоритм сортировки, полученный из merge sort и insertion sort. Он делит входные массивы на блоки фиксированного размера, 
а затем сортирует блок с помощью insertion sort.


============================================================================Merge sort in Java=============================================================================
Merge sort - это эффективный алгоритм сортировки на основе сравнения. Он делит несортированный массив размером n на n одноэлементных подмассивов, которые уже отсортированы, 
а затем повторно объединяет эти подмассивы для создания новых отсортированных подмассивов, пока не останется только 1 отсортированных подмассивов. Merge является 
основной операцией. Он создает новый отсортированный массив из двух входных отсортированных массивов.

Для массива размером n Merge sort работает в O(nlogn), что лучше по сравнению с такими алгоритмами сортировки, как сортировка пузырьком, сортировка вставкой и сортировка 
выборок. Таким образом, сортировка слиянием может использоваться на практике для сортировки даже больших массивов.

The top-down implementation in Java

Given below is an implementation of the top-down version of merge sort in Java. The mergeSort method takes an array and a range of elements (left is inclusive, right is 
exclusive):

public static void mergeSort(int[] array, int leftIncl, int rightExcl) {
    // the base case: if subarray contains <= 1 items, stop dividing because it's sorted
    if (rightExcl <= leftIncl + 1) {
        return;
    }

    /* divide: calculate the index of the middle element */
    int middle = leftIncl + (rightExcl - leftIncl) / 2;

    mergeSort(array, leftIncl, middle);  // conquer: sort the left subarray
    mergeSort(array, middle, rightExcl); // conquer: sort the right subarray

    /* combine: merge both sorted subarrays into sorted one */
    merge(array, leftIncl, middle, rightExcl);
}

The merge method performs merging of two subarrays using a temporary array:

private static void merge(int[] array, int left, int middle, int right) {
    int i = left;   // index for the left subarray
    int j = middle; // index for the right subarray
    int k = 0;      // index for the temp subarray
        
    int[] temp = new int[right - left]; // temporary array for merging

    /* get the next lesser element from one of two subarrays 
       and then insert it in the array until one of the subarrays is empty */
    while (i < middle && j < right) {
        if (array[i] <= array[j]) {
            temp[k] = array[i];
            i++;
        } else {
            temp[k] = array[j];
            j++;
        }
        k++;
    }

    /* insert all the remaining elements of the left subarray in the array */
    for (;i < middle; i++, k++) {
        temp[k] = array[i];
    }

    /* insert all the remaining elements of the right subarray in the array */
    for (;j < right; j++, k++) {
        temp[k] = array[j];
    }

    /* effective copying elements from temp to array */
    System.arraycopy(temp, 0, array, left, temp.length);
}

int[] array1 = { 30, 21, 23, 19, 28, 11, 23 };

mergeSort(array1, 0, array1.length); // { 11, 19, 21, 23, 23, 28, 30 }

int[] array2 = { 30, 20, 10, 10, 20, 10 };
mergeSort(array2, 0, array2.length); // { 10, 10, 10, 20, 20, 30 }



================================================================================Bubble sort================================================================================
Пузырьковая сортировка-один из самых простых алгоритмов сортировки. Он многократно просматривает сортируемый массив, сравнивает каждую пару соседних элементов и меняет их 
местами, если они расположены в неправильном порядке.

Неправильные и правильные порядки зависят от требуемого порядка сортировки. Если массив должен быть отсортирован в порядке возрастания, неправильный порядок-это когда 
предыдущий элемент больше следующего. Если массив должен быть отсортирован в порядке убывания, неправильный порядок-это случай, когда предыдущий элемент меньше следующего.

Алгоритм не подходит для больших массивов, так как его средняя и наихудшая временная сложность составляет Ο(n^2), где n - длина массива.

Алгоритм стабилен: он не изменяет относительный порядок одинаковых элементов.

Предположим, у нас есть несортированный массив целых чисел, и мы хотим отсортировать его в порядке возрастания.

21 23 19 30 11 28

В цикле алгоритм сравнивает каждую пару соседних элементов массива и меняет их местами, если они расположены в неправильном порядке. Если порядок правильный, он ничего не 
делает.

Как вы можете видеть, максимальные элементы постепенно перемещаются в конец массива, что оправдывает название алгоритма. Алгоритм не меняет местами элементы в правильно 
отсортированной части.


==========================================================================Bubble sort in Java==============================================================================
Пузырьковая сортировка-один из простейших алгоритмов сортировки. Он многократно просматривает сортируемый массив, сравнивает каждую пару соседних элементов массива и меняет 
их местами, если они расположены в неправильном порядке.

Неправильные и правильные порядки зависят от требуемого порядка сортировки. Если массив должен быть отсортирован в порядке возрастания, неправильный порядок-это случай, 
когда предыдущий элемент больше следующего. И если массив должен быть отсортирован в порядке убывания, неправильный порядок-это тот случай, когда предыдущий элемент 
меньше следующего.

Алгоритм не подходит для больших массивов, так как его средняя и наихудшая временная сложность составляет O(n^2), где n - длина массива.

Алгоритм стабилен, т. е. он не изменяет относительный порядок одинаковых элементов.

В следующем коде сортировка пузырьком реализована как статический метод, который принимает массив int и возвращает отсортированный.

public static int[] bubbleSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
        for (int j = 0; j < array.length - i - 1; j++) {
            /* if a pair of adjacent elements has the wrong order it swaps them */
            if (array[j] > array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }

    return array;
}


==============================================================================Quick sort===================================================================================
Быстрая сортировка-это эффективный алгоритм сортировки на месте, который на практике часто работает быстрее по сравнению с другими алгоритмами сортировки. Алгоритм основан 
на парадигме "разделяй и властвуй".

Вот шаги быстрой сортировки:
1) Выберите какой - нибудь элемент из массива. Мы будем называть этот элемент pivot.
2) Измените порядок массива таким образом, чтобы все значения, меньшие, чем pivot, располагались перед ним, а все большие значения следовали за ним; значения, равные pivot, 
могут идти в любом направлении.
3) Рекурсивно сортируйте подмножества меньших и больших элементов.

Базовым случаем рекурсии являются массивы размером ноль или единица, которые по определению упорядочены, поэтому их никогда не нужно сортировать.

Быстрая сортировка может быть реализована в виде рекурсивного или итеративного алгоритма. Здесь мы рассмотрим только рекурсивную версию.

Временная сложность составляет O(n log n) в среднем случае и O(n^2) в худшем случае, но, к счастью, обычно это средний показатель. Мы рассмотрим некоторые плохие случаи 
позже.

Обратите внимание, что существует множество модификаций, которые делают алгоритм более эффективным. Этапы выбора и разбиения на разделы могут быть реализованы различными 
способами. Выбор конкретной стратегии реализации сильно влияет на производительность алгоритма.

Ваш выбор точки поворота сильно влияет на время сортировки. Довольно сложно определить хороший разворот для всех массивов.

Лучший pivot разделил бы массив на две равные части, что уменьшило бы размер проблемы вдвое. Однако это означает, что pivot является медианой элементов, и для того, чтобы 
найти медиану, нам потребуется либо использовать уже отсортированный массив, либо более сложный подход для поиска медианы.

Вот несколько возможных методов выбора точки pivot:

- Выберите самый левый или самый правый элемент;
- Выберите средний элемент;
- Выберите случайный элемент;
- Возьмите первое, среднее и последнее значение массива и выберите медиану из этих трех чисел в качестве pivot.

В этой теме мы всегда будем выбирать самый правый элемент. Этот подход называется Lomuto partition scheme.

Предположим, нам нужно отсортировать массив int с помощью алгоритма быстрой сортировки. В качестве стержня он всегда будет выбирать самый правый элемент.

17 25 11 16 10 13 22 14

1) Давайте выберем самый правый элемент 14 в качестве pivot в исходном массиве, а затем переупорядочим его так, чтобы все значения, меньшие, чем pivot – 11, 10, 13, стояли 
перед ним, а все значения, большие, чем pivot – 17, 25, 16, 22, следовали за ним. После перестановки pivot имеет индекс 3.
2) Разделите массив на два подмассива: левый { 11, 10, 13 } и правый { 17, 25, 16, 22 }. Pivot исключается из обоих подмассивов.
3) Рассмотрим левый подмассив. Pivot равeн 13. После перестановки мы получаем тот же порядок элементов в массиве { 11, 10, 13 }.
4) Разделите подмассив { 11, 10, 13 } на два меньших подмассива: левый { 11, 10 } и пустой подмассив.
5) Рассмотрим подмножество { 11, 10 }. Pivot равeн 10. После перестановки мы получаем порядок { 10, 11 }.
6) Разделите подмассив { 10, 11 } на два меньших подмассива: пустой массив и { 11 }. Оба новых массива уже отсортированы. Pivot 10 исключен.
7) Мы выполняем те же действия для правого подмассива { 17, 25, 16, 22 } исходного массива, пока все подмассивы не станут пустыми или не будут состоять из одного элемента.

Когда мы выбрали pivot и переставили массив, pivot находится в своем конечном положении. Все левые элементы меньше pivot, а все правые элементы больше pivot. Но они могут 
быть не упорядочены относительно друг друга на текущем шаге.

Проблемы и возможные изменения
1) К сожалению, схема разбиения Ломуто приводит к наихудшему поведению O(n^2) в уже отсортированных массивах. Проблему можно решить, выбрав другую стратегию выбора 
pivot: выбрав случайный индекс для pivot, выбрав средний индекс раздела или (особенно для более длинных разделов) выбрав медиану первого, среднего и последнего элемента 
раздела для pivot (как рекомендует Седжвик).

Опция "Медиана из трех" учитывает случай отсортированного (или обратно отсортированного) ввода и дает лучшую оценку оптимального pivot (истинной медианы), чем выбор 
случайного элемента, когда ничего не известно о порядке ввода.

2) Когда все входные элементы равны, один подмассив всегда пуст, в то время как другой уменьшился только на один элемент (pivot удален). Это приводит к наихудшему 
поведению.

Чтобы избежать этой проблемы, мы можем разделить значения на три группы: значения, меньшие, чем pivot, значения, равные pivot, и значения, большие, чем pivot. Значения, 
равные pivot, уже отсортированы, поэтому рекурсивно нужно сортировать только разделы меньше и больше, чем.


===========================================================================Quicksort in Java===============================================================================
Быстрая сортировка-это эффективный алгоритм in-place сортировки, который на практике часто работает быстрее по сравнению с другими алгоритмами сортировки. Его временная 
сложность составляет O(n log n) в среднем случае и O(n^2) в худшем случае, но для реальных наборов данных это часто работает как в среднем.

Быстрая сортировка может быть реализована в виде рекурсивного или итеративного алгоритма. Здесь мы рассмотрим только рекурсивную версию.

Ниже приведена рекурсивная версия quicksort, реализованная на Java:

public static void quickSort(int[] array, int left, int right) {
    if (left < right) {
        int pivotIndex = partition(array, left, right); // the pivot is already on its place
        quickSort(array, left, pivotIndex - 1);  // sort the left subarray
        quickSort(array, pivotIndex + 1, right); // sort the right subarray 
    }
}

Метод quickSort использует массив и диапазон индексов (left, right) для сортировки массива между ними (включительно).

Метод partition изменяет порядок массива и возвращает индекс pivot, чтобы разделить массив на две части. Метод, называемый swap, переставляет два элемента в массиве. Вот 
реализация этих методов:

private static int partition(int[] array, int left, int right) {
    int pivot = array[right];  // choose the rightmost element as the pivot
    int partitionIndex = left; // the first element greater than the pivot

    /* move large values into the right side of the array */
    for (int i = left; i < right; i++) {
        if (array[i] <= pivot) { // may be used '<' as well
            swap(array, i, partitionIndex);
            partitionIndex++;
        }
    }

    swap(array, partitionIndex, right); // put the pivot on a suitable position

    return partitionIndex;
}

private static void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}

This implementation of the partition method is known as Lomuto partition scheme. It chooses the rightmost element as a pivot.




=============================================================================Selection sort================================================================================
Сортировка выбора-это простой алгоритм сортировки, который выполняет сортировку на месте.

Давайте посмотрим, как работает алгоритм сортировки массива в порядке возрастания. Сначала он находит наименьший элемент во всем массиве и меняет его местами с элементом в 
первой позиции; затем он находит второй наименьший элемент и меняет его местами с элементом во второй позиции. Это продолжается до тех пор, пока весь массив не будет 
отсортирован.

Если n-длина входного массива, алгоритм имеет асимптотическую временную сложность Ο(n^2) в худшем и среднем случаях с точки зрения количества сравнений. Это делает 
алгоритм неэффективным для сортировки больших массивов. Алгоритм находит минимальный/максимальный элемент n-1 раз.

Базовая реализация алгоритма нестабильна, но ее можно изменить, чтобы она была стабильной.

Предположим, у нас есть несортированный массив целых чисел, и мы должны отсортировать его в порядке возрастания.

21 23 19 30 11 28

Вот некоторые объяснения:

1) Мы находим минимальное число во всем массиве (11) и меняем его местами с первым элементом (21). Теперь первый элемент принадлежит отсортированному подмассиву.

2) Мы находим минимальное число в несортированном подмассиве (19) и меняем номер на второй элемент. Теперь первый и второй элементы принадлежат отсортированному подмассиву.

3) Мы находим минимальное число в несортированном подмассиве (21) и меняем его местами с третьим элементом (23). Теперь первые три элемента принадлежат отсортированному 
подмассиву.

4-6) Мы повторяем тот же процесс до тех пор, пока весь массив не будет отсортирован.

Как видите, алгоритм довольно прост. Он никогда не изменяет уже отсортированный подмассив.

Двунаправленный вариант сортировки выбора находит как минимальные, так и максимальные значения в массиве при каждом проходе. Это уменьшает количество сканирований массива. 
Алгоритм делит массив на три подмассива: 1) отсортированных минимумов; 2) несортированных; 3) отсортированных максимумов. Алгоритм имеет ту же временную сложность, что и 
базовый алгоритм: Ο(n^2).


=====================================================================Standard functional interfaces========================================================================
Вы уже научились создавать и использовать функциональные интерфейсы. Однако вам не нужно каждый раз создавать свой собственный функциональный интерфейс, когда он вам нужен 
для общего случая использования. Вместо этого вы можете использовать встроенные функциональные интерфейсы, которые были представлены в Java 8 и которые можно найти в 
пакете java.util.function. В этом разделе вы узнаете о встроенных функциональных интерфейсах, их типах и соглашениях об именах, а также о том, как их использовать.

Все функциональные интерфейсы, представленные в пакете java.util.function, можно разделить на пять групп:

- functions которые принимают аргументы и дают результаты;
- operators которые выдают результаты того же типа, что и их аргументы (особый случай функции);
- predicates которые принимают аргументы и возвращают логические значения (boolean-valued function);
- suppliers которые ничего не принимают и возвращают значения;
- consumers которые принимают аргументы и не возвращают результата.

Функциональные интерфейсы из одной и той же группы могут отличаться количеством аргументов и быть как generic, так и не generic.

Благодаря соглашениям об именовании функциональных интерфейсов в пакете java.util.function вы можете легко понять характеристику интерфейса, просто взглянув на его префикс 
имени, который может указывать на следующее:

- количество параметров, которые принимаются операцией. Префикс Bi указывает, что функция, predicate или consumer принимают два параметра. Подобно префиксу Bi, Unary и 
Binary префиксы указывают, что оператор принимает один или два параметра соответственно.
- тип входных параметров. Префиксы Double, Long, Int и Obj указывают тип входного значения. Например, интерфейс IntPredicate представляет predicate, который принимает 
значение типа Integer.
- тип возвращаемого параметра. Префиксы ToDouble, toLong и toInt указывают тип возвращаемого значения. Например, интерфейс ToIntFunction<T> представляет функцию, которая 
возвращает значение типа Integer.

Обратите внимание, что некоторые функциональные интерфейсы имеют комбинированные префиксы. Это просто означает, что вам нужно применять перечисленные правила с учетом 
каждого префикса. Например, глядя на префиксы интерфейса DoubleToIntFunction, мы видим, что он принимает значение типа Double и возвращает значение типа Integertype.

Давайте рассмотрим примеры для каждой из пяти групп стандартных функциональных интерфейсов.

1) Functions

Каждая функция принимает значение в качестве параметра и возвращает одно значение. Например, Function<T, R> является универсальным интерфейсом, представляющим функцию, 
которая принимает значение типа T и возвращает результат типа R.

// String to Integer function
Function<String, Integer> converter = Integer::parseInt;
converter.apply("1000"); // the result is 1000 (Integer)

// String to int function
ToIntFunction<String> anotherConverter = Integer::parseInt;
anotherConverter.applyAsInt("2000"); // the result is 2000 (int)

// (Integer, Integer) to Integer function
BiFunction<Integer, Integer, Integer> sumFunction = (a, b) -> a + b;
sumFunction.apply(2, 3); // it returns 5 (Integer)

2) Operators

Каждый оператор принимает и возвращает значения одного и того же типа. Например, UnaryOperator<T> представляет оператор, который принимает значение типа T и возвращает 
результат того же типа T.

// Long to Long multiplier
UnaryOperator<Long> longMultiplier = val -> 100_000 * val;
longMultiplier.apply(2L); // the result is 200_000L (Long)

// int to int operator
IntUnaryOperator intMultiplier = val -> 100 * val;
intMultiplier.applyAsInt(10); // the result is 1000 (int)

// (String, String) to String operator
BinaryOperator<String> appender = (str1, str2) -> str1 + str2;
appender.apply("str1", "str2"); // the result is "str1str2"

3) Predicates

Каждый предикат принимает значение в качестве параметра и возвращает значение true или false. Например, Predicate<T> является универсальным интерфейсом, представляющим 
предикат, который принимает значение типа T и выдает результат с boolean значением.

// Character to boolean predicate
Predicate<Character> isDigit = Character::isDigit;
isDigit.test('h'); // the result is false (boolean)

// int to boolean predicate
IntPredicate isEven = val -> val % 2 == 0;
isEven.test(10); // the result is true (boolean)

4) Suppliers

Каждый Supplier не принимает никаких параметров и возвращает одно значение. Например, Supplier<T> представляет Supplier, который не принимает аргументов и возвращает 
значение типа T.

Supplier<String> stringSupplier = () -> "Hello";
stringSupplier.get(); // the result is "Hello" (String)

BooleanSupplier booleanSupplier = () -> true;
booleanSupplier.getAsBoolean(); // the result is true (boolean)

IntSupplier intSupplier = () -> 33;
intSupplier.getAsInt(); // the result is 33 (int)

5) Consumers

Каждый Consumer принимает значение в качестве параметра и не возвращает данных. Например, Consumer<T> - это интерфейс, представляющий Consumer, который принимает значение 
типа T и не возвращает результата.

// it prints a given string
Consumer<String> printer = System.out::println;
printer.accept("!!!"); // It prints "!!!"


======================================================================Function composition=================================================================================
In this topic, you will learn a new technique for working with functions called function composition. It is a mechanism for combining functions to obtain more complicated 
functions that originally comes from math. In a sense, it can be considered as a design pattern in functional programming. You can use this pattern to compose standard 
functions, operators, predicates and consumers (but not suppliers). Let's take a look at examples.

1) Functions	g(f(h))

Функциональный интерфейс Function<T, R> имеет два cтандартных метода compose и andThen для создания новых функций. Основное различие между этими методами заключается в 
порядке выполнения.

Generally, f.compose(g).apply(x) is the same as f(g(x)), and f.andThen(g).apply(x) is the same as g(f(x)).

Here is an example with two functions: adder and multiplier.

Function<Integer, Integer> adder = x -> x + 10;
Function<Integer, Integer> multiplier = x -> x * 5;

// compose: adder(multiplier(5))
System.out.println("result: " + adder.compose(multiplier).apply(5));

// andThen: multiplier(adder(5))
System.out.println("result: " + adder.andThen(multiplier).apply(5));

Here is the output:
result: 35
result: 75

В этом случае метод compose возвращает функцию, которая сначала применяет multiplier к своим входным данным, а затем применяет adder к результату. Метод andThen возвращает 
функцию, которая сначала применяет adder к своим входным данным, а затем применяет multiplier к результату.

Операторы могут использоваться так же, как и функции.

Методы составляют и затем не изменяют функции, которые объединяются. Вместо этого они возвращают новые функции. Это справедливо для всех следующих примеров.

Пример:

Function<String, String> operator1 = s -> s + s;
Function<String, String> operator2 = s -> String.valueOf(s.length());
Function<String, String> resultOperator = operator1.compose(operator2);

resultOperator.apply("test");

result : сначала выполняется operator2 и возвращает длину text т.е. 4, затем выполняется operator1 и возвращает "4" + "4" т.е. "44"

Пример 2:

IntUnaryOperator mult2 = num -> num * 2;
IntUnaryOperator add3 = num -> num + 3;

IntUnaryOperator combinedOperator = add3.compose(mult2.andThen(add3)).andThen(mult2);
int result = combinedOperator.applyAsInt(5);

Результат: mult2(add3(add3(mult2(x)))) т.е. 32

Пример 3:

Function<Double, Double> composed = f.andThen(g).compose(h);

Результат: g(f(h(x)))

2) Predicates

Все функциональные интерфейсы, представляющие предикаты (Predicate<T>, IntPredicate и другие), имеют три метода для создания новых предикатов: and, or и negate.

В приведенном ниже примере есть два предиката: isOdd и lessThan11.

IntPredicate isOdd = n -> n % 2 != 0; // it's true for 1, 3, 5, 7, 9, 11 and so on

System.out.println(isOdd.test(10)); // prints "false"
System.out.println(isOdd.test(11)); // prints "true"
        
IntPredicate lessThan11 = n -> n < 11; // it's true for all numbers < 11

System.out.println(lessThan11.test(10)); // prints "true"
System.out.println(lessThan11.test(11)); // prints "false"

Let's negate the first predicate:

IntPredicate isEven = isOdd.negate(); // it's true for 0, 2, 4, 6, 8, 10 and so on
System.out.println(isEven.test(10)); // prints "true"
System.out.println(isEven.test(11)); // prints "false"

Здесь у нас есть новый предикат, который проверяет, является ли значение четным, а не нечетным.

Now let's combine both isOdd and lessThan11 predicates together by using or and and methods:

IntPredicate isOddOrLessThan11 = isOdd.or(lessThan11);

System.out.println(isOddOrLessThan11.test(10)); // prints "true"
System.out.println(isOddOrLessThan11.test(11)); // prints "true"
System.out.println(isOddOrLessThan11.test(12)); // prints "false"
System.out.println(isOddOrLessThan11.test(13)); // prints "true"

IntPredicate isOddAndLessThan11 = isOdd.and(lessThan11);

System.out.println(isOddAndLessThan11.test(8));  // prints "false"
System.out.println(isOddAndLessThan11.test(9));  // prints "true"
System.out.println(isOddAndLessThan11.test(10)); // prints "false"
System.out.println(isOddAndLessThan11.test(11)); // prints "false"

Как вы можете видеть, эти методы эквивалентны логическим операторам && и ||, но они работают с функциями, а не с их значениями.

3) Consumers

Это может быть немного удивительно, но также возможно объединить Consumers с помощью метода andThen. Он просто возвращает нового Consumer, который потребляет заданное 
значение несколько раз в цепочке.

В следующем примере мы используем andThen, чтобы напечатать значение два раза, но можно сделать это еще несколько раз.

Consumer<String> consumer = System.out::println;
Consumer<String> doubleConsumer = consumer.andThen(System.out::println);
doubleConsumer.accept("Hi!");

Here is the output:
Hi!
Hi!


==============================================================================Optional=====================================================================================
Как и многие языки программирования, Java использует значение null для представления отсутствия значения. Иногда этот подход приводит к исключениям, таким как NPE, в то 
время как ненулевые проверки делают код менее читаемым. Британский ученый—компьютерщик Тони Хоар—изобретатель концепции null-даже описывает введение null как "ошибку 
стоимостью в миллиард долларов", поскольку это привело к бесчисленным ошибкам, уязвимостям и сбоям в системе. Чтобы избежать проблем, связанных с null, Java предоставляет 
класс Optional, который является более безопасной альтернативой стандартным ссылкам на null.

класс Optional<T> представляет наличие или отсутствие значения указанного типа T. Объект этого класса может быть как пустым, так и непустым.

Давайте рассмотрим пример. В следующем коде мы создаем два Optional объекта, называемых absent и present. Первый объект представляет пустое значение (например, null), а 
второй сохраняет реальное строковое значение.

Optional<String> absent = Optional.empty();
Optional<String> present = Optional.of("Hello");

Метод isPresent проверяет, является ли объект пустым или нет:

System.out.println(absent.isPresent()); // false
System.out.println(present.isPresent()); // true

Начиная с Java 11, мы также можем вызвать противоположный метод isEmpty.

Если вы передадите null методу of, это вызовет NPE.

В ситуации, когда вы не знаете, является ли переменная null или нет, вы должны передать ее методу ofNullable вместо метода of. Он создает пустое Optional значение, если 
переданное значение равно null.

В следующем примере метод getRandomMessage может возвращать значение null или некоторое строковое сообщение. В зависимости от того, что будет возвращено, результат будет 
разным.

String message = getRandomMessage(); // it may be null

Optional<String> optMessage = Optional.ofNullable(message);

System.out.println(optMessage.isPresent()); // true or false

Если message != null (например, "Hello") , код вернёт значение true. В противном случае будет возвращено значение false, поскольку объект Optional пуст.

Важно, что присвоение значения null переменной Optional типа возможно, но это считается плохой практикой программирования.

Самое очевидное, что нужно сделать с объектом Optional, - это получить его значение. На данный момент мы собираемся обсудить три метода с такой целью:

1) get возвращает значение, если оно присутствует, в противном случае выбрасывает исключение;
2) OrElse возвращает значение, если оно присутствует, в противном случае возвращает other;
3) orElseGet возвращает значение, если оно присутствует, в противном случае вызывает other и возвращает его результат.

Давайте посмотрим, как они работают. Во - первых, мы используем метод get для получения существующего значения:

Optional<String> optName = Optional.of("John");
String name = optName.get(); // "John"

Этот код работает хорошо и возвращает имя "Джон" из Optional. Но если объект Optional пуст, программа выбрасывает исключение NoSuchElementException.

Optional<String> optName = Optional.ofNullable(null);
String name = optName.get(); // throws NoSuchElementException

Это не совсем то, чего мы ожидали бы от класса, предназначенного для уменьшения числа исключений.

Начиная с Java 10, предпочтительной альтернативой методу get является метод orElseThrow, поведение которого такое же, но название описывает его лучше.

Метод OrElse используется для извлечения значения, заключенного в объект Optional, или для возврата некоторого значения по умолчанию, когда объект Optional пуст. Значение 
по умолчанию передается методу в качестве его аргумента:

String nullableName = null;
String name = Optional.ofNullable(nullableName).orElse("unknown");
        
System.out.println(name); // unknown

В отличие от предыдущего примера, этот не создает исключения, а вместо этого возвращает значение по умолчанию.

Метод orElseGet очень похож, но для получения результата требуется функция supplier, а не значениe по умолчанию:

String name = Optional
        .ofNullable(nullableName)
        .orElseGet(SomeClass::getDefaultResult);

В этом примере мы используем метод getDefaultResult для получения результата по умолчанию.

Существуют также удобные методы, которые принимают функции в качестве аргументов и выполняют некоторые действия со значениями, заключенными в Optional:

1) ifPresent выполняет данное действие со значением, в противном случае ничего не делает;
2) ifPresentOrElse выполняет данное действие со значением, в противном случае выполняет данное действие на основе пустого значения.

Метод ifPresent позволяет нам выполнить некоторый код для значения, если объект Optional не пуст. Метод использует функцию consumer, которая может обрабатывать значение.

В следующем примере выводится длина названия компании с помощью ifPresent.

Optional<String> companyName = Optional.of("Google");
companyName.ifPresent((name) -> System.out.println(name.length())); // 6

Однако следующий код ничего не печатает, потому что объект Optional пуст.

Optional<String> noName = Optional.empty();
noName.ifPresent((name) -> System.out.println(name.length()));

Он не выбрасывает исключения из-за выполнения внутренней проверки на null.

"Классический" эквивалент этих двух фрагментов кода выглядит следующим образом:

String companyName = ...;
if (companyName != null) {
    System.out.println(companyName.length());
}

Этот код более подвержен ошибкам, потому что можно забыть явно выполнить проверку на нуль, а затем получить NPE.

Метод ifPresentOrElse является более безопасной альтернативой всему оператору if-else. Он выполняет одну из двух функций в зависимости от того, присутствует ли значение в 
объекте Optional.

Optional<String> optName = Optional.ofNullable(/* some value goes here */);

optName.ifPresentOrElse(
        (name) -> System.out.println(name.length()), 
        () -> System.out.println(0)
);

Если optName содержит какое-либо значение (например, "Google"), вызывается лямбда-выражение, которое выводит длину имени. Если параметр optName пуст, вторая функция 
выводит 0 в качестве значения по умолчанию. Иногда разработчики называют второе лямбда-выражение резервным вариантом, который является альтернативным планом, если что-то 
пошло не так (без значения).


================================================================Functional data processing with streams====================================================================
В некотором смысле stream напоминает коллекцию. Но на самом деле он не хранит элементы. Вместо этого он передает элементы из источника(source), такого как коллекция, 
функция, файл, канал ввода-вывода, другой stream или что-то еще, а затем обрабатывает элементы с помощью последовательности предопределенных операций, объединенных в один 
pipeline.   source -> intermediate operation -> intermediate operation -> terminal operation -> result

Существует три этапа работы с потоком:

1) Получение потока из источника.
2) Выполнение промежуточных операций с потоком для обработки данных.
3) Выполнение терминальной операции для получения результата.

Важно, чтобы поток всегда имел только одну терминальную операцию и произвольное количество промежуточных операций.

Все классы, связанные с потоками, находятся в пакете java.util.stream. Существует несколько общих классов потоков: Stream<T>, IntStream, LongStream и DoubleStream. В то 
время как generic stream работает со ссылочными типами, другие работают с соответствующими примитивными типами. В этом разделе мы рассмотрим только generic stream.

Давайте рассмотрим простой пример. Предположим, у нас есть список чисел, и мы хотели бы посчитать числа, которые больше 5:

List<Integer> numbers = List.of(1, 4, 7, 6, 2, 9, 7, 8);

A "traditional" way to do it is to write a loop like the following:

long count = 0;
for (int number : numbers) {
    if (number > 5) {
        count++;
    }
}
System.out.println(count); // 5

Цикл с условием фильтрации является широко используемой конструкцией в программировании. Этот код можно упростить, переписав его с помощью потока:

long count = numbers.stream()
        .filter(number -> number > 5)
        .count(); // 5

Видите, как это просто! Мы просто вызываем другую операцию в потоке, чтобы заставить ее работать. Выполнить ту же модификацию при использовании цикла будет сложнее.

Обработка потока выполняется в виде цепочки вызовов методов, разделенных точками, с помощью одной терминальной операции. Для улучшения удобочитаемости рекомендуется 
помещать каждый вызов в новую строку, если поток содержит более одной операции.

Существует множество способов создания потока, включая использование list, set, String, массива и так Далее в качестве источника.

1) Наиболее распространенный способ создания потока - это взять его из коллекции. Для этой цели в любой коллекции есть метод stream().

List<Integer> famousNumbers = List.of(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55);
Stream<Integer> numbersStream = famousNumbers.stream();

Set<String> usefulConcepts = Set.of("functions", "lazy", "immutability");
Stream<String> conceptsStream = usefulConcepts.stream();

2) Также возможно получить поток из массива:

Stream<Double> doubleStream = Arrays.stream(new Double[]{ 1.01, 1d, 0.99, 1.02, 1d, 0.99 });

3) или непосредственно из некоторых значений:

Stream<String> persons = Stream.of("John", "Demetra", "Cleopatra");

4) или объединить другие потоки вместе:

Stream<String> stream1 = Stream.of(/* some values */);
Stream<String> stream2 = Stream.of(/* some values */);
Stream<String> resultStream = Stream.concat(stream1, stream2);

5) Есть некоторые возможности для создания пустых потоков (которые можно использовать в качестве возвращаемых значений из методов):

Stream<Integer> empty1 = Stream.of();
Stream<Integer> empty2 = Stream.empty();

There are also other methods to create streams from different sources: from a file, from I/O stream, and so on.

Все потоковые операции делятся на две группы: intermediate и terminal операции.

- Intermediate operations не вычисляются сразу при вызове. Они просто возвращают новые потоки для вызова следующих операций над ними. Такие операции известны как lazy, 
потому что на самом деле они не делают ничего полезного.
- Terminal operations начинает вычисления потока, чтобы получить результат или создать побочный эффект. Как мы уже упоминали ранее, поток всегда имеет только одну 
терминальную операцию.

После выполнения терминальной операции повторное использование потока невозможно. Если вы попытаетесь это сделать, программа выдаст исключение IllegalStateException.

Intermediate operations:

filter - возвращает новый поток, включающий элементы, соответствующие Predicate;
limit - возвращает новый поток, состоящий из первых n элементов этого потока;
skip - возвращает новый поток без первых n элементов этого потока;
distinct - возвращает новый поток, состоящий только из уникальных элементов в соответствии с результатами equals;
sorted - возвращает новый поток, включающий элементы, отсортированные в соответствии с естественным порядком или заданным Comaparator;
peek - возвращает тот же поток элементов, но позволяет наблюдать за текущими элементами потока для отладки;
map - возвращает новый поток, состоящий из элементов, полученных путем применения функции (т. е. Преобразования каждого элемента).
rangeClosed(int startInclusive, int endInclusive) - Возвращает последовательный упорядоченный входной поток от начального (включительно) до конечного (включительно) с 
шагом 1. Работает с IntStream
concat(IntStream a, IntStream b) - возвращает результирующий поток из двух переданных
boxed - Возвращает поток, состоящий из элементов этого потока, каждый из которых заключен в Integer.
takeWhile - извлекает элементы из потока пока predicate возвращает true
dpopWhile - удаляет элементы из потока пока predicate возвращает true(если на первом элементе predicate вернёт false, то не будет удалено ничего)

Terminal operations:

count - возвращает количество элементов в потоке в виде long значения;
max/min - возвращает Optional максимальный / минимальный элемент потока в соответствии с данным Comparator;
reduce - объединяет значения из потока в одно значение (совокупное значение);
findFirst/findAny - возвращает первый / любой элемент потока в качестве Optional объекта;
anyMatch - returns true if at least one element matches a predicate (see also: allMatch, noneMatch);
forEach - берет Consumer и применяет его к каждому элементу потока (например, печатает его).;
collect - возвращает коллекцию значений в потоке;
toArray - возвращает массив значений в потоке.

Такие операции (методы), как filter, map, reduce, forEach, anyMatch и некоторые другие, называются функциями высокого порядка, поскольку они принимают другие функции в 
качестве аргументов.

В качестве примера давайте использовать потоковые операции для печати всех названий компаний без дубликатов в верхнем регистре.

List<String> companies = List.of(
        "Google", "Amazon", "Samsung",
        "GOOGLE", "amazon", "Oracle"
);

companies.stream()
        .map(String::toUpperCase) // transform each name to the upper case
        .distinct() // intermediate operation: keep only unique words
        .forEach(System.out::println); // print every company

Здесь мы используем две промежуточные операции (map и distinct) и одну терминальную операцию forEach.


==========================================================================Stream filtering=================================================================================
Для элементов элементов потоки предоставляют метод filter. Он возвращает новый поток, состоящий только из тех элементов, которые соответствуют данному Predicate.

В качестве примера приведем список простых чисел (простое число-это целое число, большее 1, единственными коэффициентами которого являются 1 и оно само).:

List<Integer> primeNumbers = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);

Мы хотели бы создать новый список, состоящий из простых чисел, которые относятся к диапазону от 11 до 23 (включительно).

List<Integer> filteredPrimeNumbers = primeNumbers.stream() // create a stream from the list
        .filter(n -> n >= 11 && n <= 23) // filter elements
        .collect(Collectors.toList());   // collect elements in a new list

So, the filteredPrimeNumbers list is:

[11, 13, 17, 19, 23]

Поскольку метод filter принимает Predicate, можно создать экземпляр объекта напрямую и передать его методу.

Predicate<Integer> between11and23 = n -> n >= 11 && n <= 23; // instantiate the predicate

List<Integer> filteredPrimeNumbers = primeNumbers.stream() // create a stream from the list
        .filter(between11and23)        // pass the predicate to the filter method
        .collect(Collectors.toList()); // collect elements in a new list

Иногда два или более фильтра используются вместе. Например:

- чтобы отделить сложную логику от одного фильтра;
- чтобы отфильтровать поток, затем обработайте его другими методами, а затем снова отфильтруйте.

Let's consider an example. Given a list of programming languages with empty strings.

List<String> programmingLanguages = Arrays.asList("Java", "", "scala", "Kotlin", "", "clojure");

Мы хотели бы подсчитать, сколько языков программирования начинаются с заглавной буквы, игнорируя все пустые строки.

long count = programmingLanguages.stream()
        .filter(lang -> lang.length() > 0) // consider only non-empty strings
        .filter(lang -> Character.isUpperCase(lang.charAt(0)))
        .count(); // count suitable languages

The count is 2 ("Java", "Kotlin").


============================================================================Map and flatMap================================================================================
map-это метод класса Stream, который принимает функцию с одним аргументом в качестве параметра. Основная цель map состоит в том, чтобы применить эту функцию к каждому 
элементу потока и вернуть результирующий поток, c тем же количеством элементов.

1) Одним из распространенных применений операции map является применение заданной функции к каждому элементу потока значений. Рассмотрим следующий список значений:

List<Double> numbers = List.of(6.28, 5.42, 84.0, 26.0);

Давайте разделим каждое число на 2. Для этого мы можем сопоставить каждый элемент потока с элементом, разделенным на 2, и собрать его в новый список:

List<Double> famousNumbers = numbers.stream()
        .map(number -> number / 2) // divide each number in the stream by 2
        .collect(Collectors.toList()); // collect transformed numbers to a new list

The resulting list is:

[3.14, 2.71, 42.0, 13.0]

Обратите внимание, что метод map не изменяет исходный список. Каждое число, разделенное на 2, будет добавлено в новый список famousNumbers после вызова 
collect(Collectors.toList()).

2) map часто используется для получения потока свойств из а потока объектов:

public class Job {
    private String title;
    private String description;
    private double salary;

    // getters and setters
}

Мы можем получить список названий должностей из заданного списка должностей с помощью метода map:

List<String> titles = jobs.stream()
        .map(Job::getTitle) // get title of each job
        .collect(Collectors.toList()); // collect titles to a new list

Приведенный выше код вызовет метод getTitle для каждого объекта Job и собирает полученный список должностей в новый список.

3) Другим распространенным вариантом использования является получение списка некоторых объектов из списка других объектов. Давайте предположим, что у нас есть следующие 
классы:

class User {
    private long id;
    private String firstName;
    private String lastName;
}

class Account {
    private long id;
    private boolean isLocked;
    private User owner;
}

class AccountInfo {
    private long id;
    private String ownerFullName;
}

И мы хотели бы получить список объектов AccountInfo из списка объектов Account. Мы можем сделать это с помощью метода map:

List<AccountInfo> infoList = accounts.stream()
        .map(acc -> {
                AccountInfo info = new AccountInfo();
                info.setId(acc.getId());
                String ownerFirstName = acc.getOwner().getFirstName();
                String ownerLastName = acc.getOwner().getLastName();
                info.setOwnerFullName(ownerFirstName + " " + ownerLastName);
                return info;
        }).collect(Collectors.toList());


Потоки с примитивными типами данных, такие как IntStream, LongStream или DoubleStream, также имеют метод map, который сопоставляет значение примитива другому примитиву 
того же типа. Однако полезно иметь способ сопоставить примитивное значение с объектом. Для этого такие потоки имеют метод mapToObj.

class Planet {
    private String name;
    private int orderFromSun;

    public Planet(int orderFromSun) {
        this.orderFromSun = orderFromSun;
    }
}

Now we can map int elements of the IntStream to the stream of objects using mapToObj method and collect the resulting stream to the list of Planet objects:

List<Planet> planets = IntStream.of(1, 2, 3, 4, 5, 6, 7, 8)
        .mapToObj(Planet::new)
        .collect(Collectors.toList());



Операция map отлично подходит для потоков примитивов и объектов, но входными данными также могут быть потоки коллекций. Например, метод stream() для List<List<String>> 
возвращает Stream<List<String>>. В этом случае нам часто приходится сглаживать(flatten) поток коллекций до потока элементов из этих коллекций.

Сглаживание(flattening) относится к объединению элементов списка списков в один список. Например, если мы сгладим список списков [["a", "b"], ["c"], ["d", "e"]], мы 
получим список ["a", "b", "c", "d", "e"].

В таких случаях может быть полезен метод flatMap. Он принимает и применяет функцию с одним аргументом для преобразования каждого элемента потока в новый поток и объединяет 
эти потоки вместе.

Давайте рассмотрим пример с java-книгами. Каждая книга имеет название, год издания и список авторов:

List<Book> javaBooks = List.of(
        new Book("Java EE 7 Essentials", 2013, List.of("Arun Gupta")),
        new Book("Algorithms", 2011, List.of("Robert Sedgewick", "Kevin Wayne")),
        new Book("Clean code", 2014, List.of("Robert Martin"))
);

Теперь мы можем получить список всех авторов из списка книг на java с помощью метода flatMap:

List<String> authors = javaBooks.stream()
        .flatMap(book -> book.getAuthors().stream())
        .collect(Collectors.toList());

The resulting list is:

["Arun Gupta", "Robert Sedgewick", "Kevin Wayne", "Robert Martin"]


Пример:

List<List<Integer>> list = Arrays.asList(
                Arrays.asList(1, 2, 3),
                Arrays.asList(4, 5, 1),
                Arrays.asList(8, 3, 2)
);

List<Integer> numbers = list.stream()
        .flatMap(Collection::stream)
        .collect(Collectors.toList());

The resulting list is: 1, 2, 3, 4, 5, 1, 8, 3, 2

Пример:

List<String> countries = Arrays.asList("Costa Rica", "Greece", "Malaysia", "Peru");

List<Integer> numbers = countries.stream()
        .map(country -> country.split("\\s+"))
        .flatMap(Arrays::stream)
        .map(String::length)
        .collect(Collectors.toList());

The resulting list is: 5 4 6 8 4

Пример 1:

public static int[] sortedAbsNumbers(String[] numbers) {
        return Arrays.stream(numbers)
                .mapToInt(Integer::parseInt) // конвертирует из String в Integer, а затем в int
                .map(Math::abs)
                .sorted()
                .toArray();
    }

Пример 2:

List<Integer> numbers = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList());
List<Integer> generated = numbers.stream()
        .flatMap(n -> Stream.generate(() -> n).limit(n))
        .collect(Collectors.toList());
-> [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]

Пример 3:

List<Integer> numbers = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList());
List<Integer> generated = numbers.stream()
        .flatMapToInt(n -> IntStream.rangeClosed(1, n))
        .boxed()
        .collect(Collectors.toList());
-> [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]

Пример 4:

List<Integer> numbers = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList());
List<Integer> generated = numbers.stream()
        .flatMapToInt(n -> IntStream.iterate(n, val -> val + 1).limit(n))
        .boxed()
        .collect(Collectors.toList());
-> [1, 2, 3, 3, 4, 5, 4, 5, 6, 7, 5, 6, 7, 8, 9]

Пример 5:

List<Integer> numbers = Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList());
List<Integer> generated = numbers.stream()
        .flatMap(Stream::of)
        .collect(Collectors.toList());
-> [1, 2, 3, 4, 5]

======================================================================Reduction methods====================================================================================
Работая с коллекциями в Java, вы часто можете столкнуться с проблемой сведения всех элементов коллекции к одному результату. Примером такой проблемы является нахождение 
банковского счета с максимальной суммой денег среди множества счетов или уменьшение значений транзакций по счету до общей суммы переведенных денег. Java Stream API 
предоставляет несколько терминальных операций, которые позволяют нам функционально решить эту проблему. Эти операции объединяют элементы потока и возвращают одно значение.

reduce-это метод класса Stream, который объединяет элементы потока в одно значение. Результатом может быть значение примитивного типа или сложный объект.

Обратите внимание, что reduce-это терминальная операция.

Давайте рассмотрим два наиболее распространенных способа использования Java Stream API для reduce операций:

1) В простейшем случае метод reduce принимает функцию accumulator с двумя аргументами. Первый аргумент аккумулятора является частичным результатом reduce, в то время как 
второй является следующим элементом потока. accumulator должен возвращать значение уменьшения, которое будет присвоено частичному результату. Давайте рассмотрим следующий 
список транзакционных значений:

List<Integer> transactions = List.of(20, 40, -60, 5);

Теперь мы суммируем все значения транзакций, чтобы получить общую сумму переведенных денег с помощью операции reduce:

transactions.stream().reduce((sum, transaction) -> sum + transaction);

На первой итерации reduce аргумент sum равен первому элементу потока, значение которого равно 20. Аргумент transaction представляет следующий элемент потока, значение 
которого равно 40. После первой итерации sum прибавляет текущее значение аргумента transaction и будет равна 20 + 40 = 60.

itearation	sum		transaction
0		20		40
1		20+40=60	-60
2		60+(-60)=0	5
return		0+5=5

Операция reduce, которая принимает функцию аккумулятора, возвращает Optional тип. В приведенном выше примере метод reduce возвращает Optional<Integer>, содержащий целое 
значение 5.

2) Другая реализация reduce имеет один дополнительный параметр: значение идентификатора или начальное значение. Значение идентификатора представляет собой начальное 
значение для операции reduce. Давайте перепишем наш предыдущий пример, используя аргумент identity:

transactions.stream().reduce(0, (sum, transaction) -> sum + transaction);

Теперь начальное значение sum равно 0, а начальное значение элемента transaction равно 20.

Обратите внимание, что если метод reduce принимает как значение идентификатора, так и функцию накопителя, он вернет примитивный тип или объект, но не Optional контейнер. 
Если поток пуст, операция reduce вернет значение идентификатора.

3) Другие операции reduce

В то время как reduce является общепринятой операцией, Stream API предоставляет множество конкретных операций сокращения, таких как sum, min, max и т.д. Подобно операции 
reduce, они являются терминальными операциями, которые создают одно значение. Давайте рассмотрим пример с общим потоком, предполагая, что нам нужно найти максимальное 
значение из списка заданных балансов. Мы можем сделать это с помощью операции reduce:

transactions.stream().reduce((t1, t2) -> t2 > t1 ? t2 : t1)

Приведенный выше код сравнивает t1 со следующим элементом потока t2 и присваивает значение t2 to t1, если t2 больше t1. Мы можем получить тот же результат более элегантным 
способом, используя метод max:

transactions.stream().max(Integer::compareTo);

Как вы можете заметить, метод max класса Stream<T> принимает функцию сравнения, чтобы найти максимальный элемент среди элементов потока, поскольку нам нужно указать, как 
именно сравнивать универсальный тип. В отличие от универсальных потоков, специализированные потоки примитивов, такие как IntStream или LongStream, уже "знают" тип своих 
элементов. Вот почему их функции max и min не требуют никакой функции сравнения:

IntStream.of(20, 40, -60, 5).max();

Из-за осведомленности о типе примитивно-специализированные потоки имеют численно специализированные функции, такие как average значение и sum, которые не могут быть 
предоставлены универсальным потокам.


===================================================================================Collectors==============================================================================
До сих пор мы знали, как получить одно значение из потока элементов с помощью операции reduce. Однако сбор элементов потока в коллекцию, такую как list или Set, является 
гораздо более популярным сценарием, чем сведение их к одному значению. Для этого Java Stream API предоставляет терминальную операцию под названием collect. В сочетании с 
утилитами Класса stream.Collectors, содержащий множество полезных операций, collect позволяет нам легко создавать коллекции из потоков, а также отдельных значений, как это 
делают операции reduce.

Collect - это terminal операция, которая может принимать объект типа Collector. Но вместо того, чтобы сосредотачиваться на Collector, давайте более внимательно рассмотрим 
класс Collectors. Важно, чтобы класс Collectors содержал статические методы, возвращающие Collector и реализующие функциональные возможности для накопления элементов 
потока в коллекцию, их суммирования, переупаковки в одну строку и т.д.

Чтобы быть более конкретным, давайте рассмотрим пример, в котором задан класс Account:

public class Account {
    private long balance;
    private String number;

    // getters and setters
}

Мы хотим создать список учетных записей из потока учетных записей Stream<Account> accountStream. Для этого мы можем накапливать элементы потока в список с помощью 
Collectors.toList:

List<Account> accounts = accountStream.collect(Collectors.toList());

As you can see, the Collectors.toList method did all the work for us. Similarly to producing a List from a stream, we can produce a Set. Again, we can delegate that 
responsibility to the Collectors class and use Collectors.toSet method:

Set<Account> accounts = accountStream.collect(Collectors.toSet());

Если вам нужен больший контроль над созданием коллекций и вы хотите накапливать элементы потока в конкретную коллекцию, которая не является List или Set, может пригодиться 
метод Collectors.toCollection:

LinkedList<Account> accounts = accountStream.collect(Collectors.toCollection(LinkedList::new));

Аналогично операции reduce, collect способен накапливать элементы потока в одно значение. Здесь вы можете увидеть некоторые методы Collectors, которые создают одно 
значение:

summingInt, summingLong, summingDouble;
averagingInt, averagingLong, averagingDouble;
maxBy, minBy;
counting.

Названия методов вполне понятны в отношении их назначения. Мы будем использовать один из них в приведенном ниже примере.

Теперь давайте подведем итоги остатков на счетах. Для этого мы можем использовать метод summingLong:

long summary = accounts.stream()
        .collect(summingLong(Account::getBalance));

Also, we can calculate the mean value:

double average = accounts.stream()
        .collect(averagingLong(Account::getBalance));

Обратите внимание, что все Collectors усреднения (averagingLong, averagingInt, averagingDouble) возвращают Double значение.

Если вам нужно выполнить более конкретные вычисления, вы можете использовать метод Collectors.reducing. Аналогично операции reduce, реализации метода Collectors.reducing 
могут принимать функцию аккумулятора или значение идентификатора вместе с аккумулятором. Однако существует одна дополнительная реализация, которая принимает идентификатор, 
сопоставитель и функцию накопления.

Let's consider an example:

String meganumber = accountStream.collect(Collectors.reducing("",
        account -> account.getNumber(),
        (numbers, number) -> numbers.concat(number)
));
The code above maps each account to its number and concatenates all account numbers into one single number using a reducing collector

Пример:

int result = Stream.of(-1, 2, -3, 4)
                   .collect(Collectors.reducing(0, x -> x > 0 ? x : -x, (x, y) -> x + y));

1) 0;  1; (0, 1) -> 0 + 1
2) 0;  2; (1, 2) -> 1 + 2
3) 0;  3; (3, 3) -> 3 + 3
4) 0;  4; (6, 4) -> 6 + 4


Пример:

numbers.collect(Collectors.toSet()).stream().collect(Collectors.averagingInt(Integer::intValue)); // Можно использовать метод stream() на объект Collector

long val = numbers.stream().collect(Collectors.reducing(1, (acc, el) -> el * el * acc)); // перемножаем квадраты всех элементов потока

symbols.stream().collect(Collectors.joining("", "(", ")")); // позволяет объединить подстроки в одну(1 аргумент - разделитель в будущей строке, 2 аргумент - префикс, 
3 аргумент - суффикс


========================================================================Grouping collectors================================================================================
Мы узнали, как собирать элементы потока в коллекцию или одно значение с помощью операции collect и класса Collectors. Однако, помимо этого, сбор может предлагать другие 
полезные операции, такие как разделение элементов потока на две или более групп или применение сборщика к результату другого сборщика. В этом разделе мы рассмотрим, как 
сортировать элементы потока с помощью методов Collectors.partitioningBy и Collectors.groupingBy. Мы также узнаем, что такое нисходящий collector и как его использовать.

Представьте, что мы хотим разделить коллекцию счетов на две группы: счета, баланс которых больше или равен 10000, и счета с балансом меньше 10000. Другими словами, нам 
нужно разделить учетные записи на две группы в зависимости от определенного условия. Это становится возможным с помощью операции разделения.

Операция разбиения на разделы представлена методом Collectors.partitioningBy, который принимает предикат. Он разбивает входные элементы на Map из двух списков: один список 
содержит элементы, для которых предикат является истинным, а другой содержит элементы, для которых он является ложным. Ключи Map имеют boolean тип.

To illustrate the idea, let's create the following list of accounts:

List<Account> accounts = List.of(
        new Account(3333, "530012"),
        new Account(15000, "771843"),
        new Account(0, "681891")
);

And partition them into two lists by a balance >= 10000 predicate:

Map<Boolean, List<Account>> accountsByBalance = accounts.stream()
        .collect(Collectors.partitioningBy(account -> account.getBalance() >= 10000));

The accountsByBalance map contains the following entries:

{
    false=[Account{balance=3333, number='530012'}, Account{balance=0, number='681891'}], 
    true=[Account{balance=15000, number='771843'}]
}

Map<Boolean, Long> map = Stream.of(5, 1, 9, -2, -5, 1)
        .collect(Collectors.partitioningBy(n -> n > 0, Collectors.summingLong(x -> x)));

Операция группировки аналогична разделению. Однако вместо разделения данных на две группы на основе предиката операция группировки может создавать любое количество групп 
на основе функции классификации, которая сопоставляет элементы с некоторым ключом.

Операция группировки представлена методом Collectors.groupingBy, который принимает функцию классификации. groupingBy также создает Map. Ключи это значения, полученные путем 
применения функции классификации к входным элементам. Соответствующие значения представляют собой списки, содержащие элементы, отображенные функцией классификации.

Let's create the Status enum and add field status to the Account class:

enum Status {
    ACTIVE,
    BLOCKED,
    REMOVED
}

public class Account {
    private long balance;
    private String number;
    private Status status;
    
    // constructors
    // getters and setters
}

Also, let's update the list of accounts:

List<Account> accounts = List.of(
        new Account(3333L, "530012", Status.REMOVED),
        new Account(15000L, "771843", Status.ACTIVE),
        new Account(0L, "681891", Status.BLOCKED)
);

Now, we can divide all account into groups by its status:

Map<Status, List<Account>> accountsByStatus = accounts.stream()
        .collect(Collectors.groupingBy(Account::getStatus));

The accountsByStatus map contains the following entries:

{
    BLOCKED=[Account{balance=0, number='681891'}], 
    REMOVED=[Account{balance=3333, number='530012'}], 
    ACTIVE=[Account{balance=15000, number='771843'}]
}

Операция группировки создает записи, когда это необходимо, что означает, что результирующий Map может содержать любое количество записей. Например, если входные данные 
представляют собой пустой поток, результирующий Map не будет содержать записей.

В дополнение к предикату или функции классификации коллекторы partitioningBy и groupingBy могут принимать downstream коллектор. Такой collector применяется к результатам 
другого collector. Например, collector groupingBy, который принимает функцию классификации и downstream коллектор, группирует элементы в соответствии с функцией 
классификации, а затем применяет указанный downstream коллектор к значениям, связанным с данным ключом.

To illustrate how it works, let's create the following list of accounts:

List<Account> accounts = List.of(
        new Account(3333L, "530012", Status.ACTIVE),
        new Account(15000L, "771843", Status.BLOCKED),
        new Account(15000L, "234465", Status.ACTIVE),
        new Account(8800L, "110011", Status.ACTIVE),
        new Account(45000L, "462181", Status.BLOCKED),
        new Account(0L, "681891", Status.REMOVED)
);

And calculate the total balances of blocked, active, and removed accounts using a downstream collector:

Map<Status, Long> sumByStatuses = accounts.stream()
        .collect(Collectors.groupingBy(Account::getStatus, Collectors.summingLong(Account::getBalance)));

The code above groups accounts by the status field and applies a downstream summingLong collector to the List values created by the groupingBy operator. The resulting map 
contains the following entries:

{ REMOVED=0, ACTIVE=24133, BLOCKED=60000 }


Teeing collector
В Java 12 представлен collector teeing, который принимает два downstream коллектора и функцию слияния в качестве аргументов и объединяет результаты downstream коллекторов 
в конечный результат, используя предоставленную функцию слияния. Давайте посмотрим, как это работает на примере, используя тот же список учетных записей, что и в 
предыдущем абзаце.

Предположим, мы хотим извлечь из коллекции счетов следующую информацию: количество заблокированных счетов и общую сумму остатков на заблокированных счетах.

Вот как мы можем использовать коллектор teeing для решения нашей задачи:

long[] countAndSum = accounts
        .stream()
        .filter(account -> account.getStatus() == Status.BLOCKED)
        .collect(Collectors.teeing(
                Collectors.counting(),
                Collectors.summingLong(Account::getBalance),
                (count, sum) -> new long[]{count, sum})
        );

First, we filter the stream to get accounts with the BLOCKED status. Then we use the teeing collector and pass the counting collector and the summingLong collector to it 
to get the count of the filtered items and the sum of their balances. After that, we put the results of the downstream collectors to an array, which after the stream is 
processed will contain the following values: [2, 60000].

Аналогичным образом мы можем использовать сборщик teeing для возврата любых двух значений из одного потока.


public class Worker{
    private String name;
    private int age;
    private int salary;
    private String position;

    public Worker(String name, int age, int salary, String position) {
        this.name = name;
        this.age = age;
        this.salary = salary;
        this.position = position;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public int getSalary() {
        return salary;
    }

    public String getPosition() {
        return position;
    }
}

1. Группировка списка рабочих по их должности (деление на списки)

 Map<String, List<Worker>> map1 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition));

2. Группировка списка рабочих по их должности (деление на множества)

Map<String, Set<Worker>> map2 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition, Collectors.toSet()));

3. Подсчет количества рабочих, занимаемых конкретную должность

Map<String, Long> map3 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition, Collectors.counting()));

4. Группировка списка рабочих по их должности, при этом нас интересуют только имена

Map<String, Set<String>> map4 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition, 
              Collectors.mapping(Worker::getName, Collectors.toSet())));

5. Расчет средней зарплаты для данной должности

Map<String, Double> map5 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition,
              Collectors.averagingInt(Worker::getSalary)));

6. Группировка списка рабочих по их должности, рабочие представлены только именами единой строкой

Map<String, String> map6 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition,
              Collectors.mapping(Worker::getName, 
                     Collectors.joining(", ", "{","}")))
       );

7. Группировка списка рабочих по их должности и по возрасту.

Map<String, Map<Integer, List<Worker>>> collect = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition, 
              Collectors.groupingBy(Worker::getAge)));

8. Группировка списка строк в TreeMap по количеству повторов строк

На вход: a b b c d a b

Arrays.stream(strings).collect(Collectors.groupingBy(
                        String::valueOf,
                        TreeMap::new,
                        Collectors.reducing(0, x -> 1, Integer::sum)));

На выходе:
a : 2
b : 3
c : 1
d : 1

=====================================================================Streams of primitives=================================================================================
Generic класс Stream<T> используется для обработки объектов, которые всегда представлены ссылочными типами. Например, для работы с целыми числами можно создать 
Stream<Integer>, который оборачивает примитивные значения int в класс Integer. Но это не эффективный способ работы с целыми числами, так как для этого требуются 
дополнительные объекты-оболочки. К счастью, существуют три специализированных типа примитивов, называемых IntStream, LongStream и DoubleStream, которые могут эффективно 
обрабатывать примитивные значения без дополнительной упаковки.

There is no CharStream, ByteStream, ShortStream, FloatStream and BooleanStream.

Существует множество способов создания потоков примитивного типа. Некоторые из способов подходят для всех потоков, в то время как другие-нет.

1) Передача элементов в методе of:

IntStream ints = IntStream.of(1, 2, 3);
LongStream longs = LongStream.of(1, 2, 3);
DoubleStream doubles = DoubleStream.of(12.2, 18.1);

Это выглядит очень похоже на коллекции. Также можно создать пустой поток c помощью IntStream.of() или IntStream.empty().

2) Из массива примитивов:

IntStream numbers = Arrays.stream(new int[]{1, 2, 3});

Этот способ работает для всех типов примитивных специализированных потоков. Также можно указать начальную (включающую) и конечную (исключающую) 
позиции, чтобы создать поток только из подмассива.

3) Для IntStream и LongStream можно вызвать range() и rangeClosed() для создания потоков из диапазонов.

IntStream numbers = IntStream.range(10, 15); // from 10 (incl) to 15 (excl)
LongStream longs = LongStream.rangeClosed(1_000_000, 2_000_000); // it includes both borders

Разница в том, что метод rangeClosed включает его верхнюю границу, а range-нет.

4) Получение IntStream из строки:

IntStream stream = "aibohphobia".chars(); // It returns IntStream!

Это работает только для IntStream, так как символы могут быть представлены как int.

Другие способы создания потоков примитивного типа такие же, как и для общих потоков: generate, iterate, concat и так далее. Вот пример генерации двойного потока из 
десяти случайных чисел и их печати:

DoubleStream.generate(Math::random)
        .limit(10)
        .forEach(System.out::println);

Примитивные потоки имеют все те же методы, что и generic потоки, но их методы принимают примитивные специализированные функции в качестве аргументов. Например, метод 
forEach IntStream принимает IntConsumer, но не Consumer<Integer>. К счастью, это не влияет на возможности потоков.

Существует несколько дополнительных операций агрегирования, таких как min, max, avg и sum. Первые три возвращают Optional объект, который представляет результат или ничего, 
так как начальный поток может быть пустым.

Обратите внимание, что на самом деле Stream<T> также предоставляет min и max, но его методы нуждаются в компараторе в качестве аргумента.

The following code demonstrates the methods:

int[] numbers = { 10, 11, 25, 14, 22, 21, 18 };

int max = IntStream.of(numbers).max().getAsInt();
System.out.println(max); // 25

int min = IntStream.of(numbers).min().getAsInt();
System.out.println(min); // 10

double avg = IntStream.of(numbers).average().orElse(0.0);
System.out.println(avg); // 17.2857...

int sum = IntStream.of(numbers).sum();
System.out.println(sum); // 121

Также можно рассчитать эти агрегаты сразу, используя один вызов метода SummaryStatistics.

IntSummaryStatistics stat = IntStream.rangeClosed(1, 55_555).summaryStatistics();

System.out.println(String.format("Count: %d, Min: %d, Max: %d, Avg: %.1f",
        stat.getCount(), stat.getMin(), stat.getMax(), stat.getAverage()));

Here are the results:

Count: 55555, Min: 1, Max: 55555, Avg: 27778.0

Вы можете выполнять различные преобразования потоков примитивного типа.

1) Transforming a primitive type stream to another one using asDoubleStream() for IntStream and LongStream, or asLongStream for IntStream only.

IntStream.of(1, 2, 3, 4)
        .asDoubleStream()
        .forEach(System.out::println); // it prints doubles 1.0, 2.0, ...

2) Transforming a primitive type stream into the generalized stream using the boxed() method (i.e., IntStream → Stream<Integer>). All the primitive type streams have this.

Stream<Integer> streamOfNumbers = IntStream.range(1, 10).boxed();

3) Transforming a generalized stream into a stream of primitives can be done invoking one of mapToInt(), mapToLong() or mapToDouble() methods with the i -> i lambda 
expression as the argument:

List<Integer> numbers = List.of(1, 5, 9);
int sum = numbers.stream().mapToInt(i -> i).sum(); // 15


=========================================================================Taking elements===================================================================================
Если вы хотите взять только определенное количество элементов из потока или пропустить некоторые из них, вы можете вызвать методы limit(n) или skip(m). Но что, если вам 
нужно взять или пропустить некоторые элементы, пока не будет выполнено какое-то условие? Начиная с Java 9, у потоков есть два удобных метода для этого. Они могут брать или 
отбрасывать самую длинную непрерывную подпоследовательность элементов из потока на основе данного предиката.

Метод takeWhile извлекает элементы из потока до тех пор, пока не будет обнаружен первый неподходящий элемент. Этот элемент и все остальные отбрасываются. Какой элемент не 
подходит, определяется предикатом, переданным этому методу. Если все элементы будут соответствовать предикату, результат будет содержать те же элементы, что и исходный 
поток.

В следующем примере мы создаем поток чисел и берем элементы, пока они больше нуля.

List<Integer> numbers =
        Stream.of(3, 5, 1, 2, 0, 4, 5)
                .takeWhile(n -> n > 0)
                .collect(Collectors.toList());

System.out.println(numbers); // [3, 5, 1, 2]

Метод takeWhile останавливается после взятия элемента 0, так как условие становится ложным.

Существует также противоположный метод, называемый dropWhile. Он отбрасывает элементы, соответствующие данному предикату, до тех пор, пока первый элемент не будет ему 
соответствовать. Это и все остальные элементы включены в результат. Если все элементы будут соответствовать предикату, результатом будет пустой поток.

Вот тот же пример, что и раньше, но с dropWhile вместо takeWhile.

List<Integer> numbers =
        Stream.of(3, 5, 1, 2, 0, 4, 5)
                .dropWhile(n -> n > 0)
                .collect(Collectors.toList());

System.out.println(numbers); // [0, 4, 5]

Метод dropWhile перестает сбрасываться сразу после взятия элемента 0, потому что условие становится ложным. Элементы 0, 4 и 5 остаются в потоке.

Оба метода takeWhile и dropWhile хорошо работают в случае упорядоченных потоков. Такие потоки создаются из упорядоченных коллекций (например, списков) или получаются во 
время операций (например, сортировки). Но что, если мы имеем дело с неупорядоченной коллекцией, такой как set? Оказывается, что в этом случае поведение обеих операций 
недетерминировано.

В качестве примера предположим, что у нас есть набор конференций Java с одной конференцией Kotlin. Мы можем попытаться продолжать использовать названия конференций до тех 
пор, пока они начинаются с "J" и заканчиваются на первой неподходящей конференции.

Set<String> conferences = Set.of(
        "JokerConf", "JavaZone",
        "KotlinConf", "JFokus"
);

conferences.stream()
        .takeWhile(word -> word.startsWith("J"))
        .forEach(System.out::println);

Поскольку мы не знаем порядок имен в set, результат этого кода всегда может отличаться и содержать от 0 до 3 имен конференций. Это определенно не то, чего мы хотели здесь.

Использование Takewile и Dropwile с неупорядоченными потоками приводит к недетерминированному поведению и, как следствие, к ошибкам.


===========================================================================Infinite streams================================================================================
Коллекции в Java всегда содержат конечное число элементов, поскольку память компьютера ограничена. Однако Stream API позволяет нам работать с бесконечными потоками 
элементов. Это возможно из-за lazy природы потоков: создание бесконечного потока является промежуточной операцией, поэтому на самом деле он не создает элементы до тех пор, 
пока не будет выполнена терминальная операция. Предполагается, что поток в этот момент уже стал конечным.

В этом разделе мы узнаем, как создавать бесконечные потоки с помощью методов generate и iterate и как их можно использовать.

Первый метод, который мы рассматриваем, - это generate. Для этого требуется supplier функция, которая создает объект, который будет частью потока

Stream<T> generate(Supplier<T> supplier)

В приведенном ниже примере мы создаем бесконечный поток случайных чисел, используя ссылку на метод random класса Math.

Stream<Double> randomNumbers = Stream.generate(Math::random);

Supplier Функция также может быть конструктором класса:

Stream<User> userStream = Stream.generate(User::new);

Он генерирует поток объектов User, используя свой конструктор без аргументов.

В зависимости от того, как работает supplier функция, все элементы такого потока могут быть разными или одинаковыми.

Но почему бы нам не попробовать распечатать элементы бесконечного потока с помощью метода forEach? Ну, это не очень хорошая идея. У вашего компьютера просто недостаточно 
памяти для этого.

Независимо от того, как вы создали бесконечный поток, вы должны сделать его конечным с помощью limit перед вызовом терминальной операции или вызывать только специальные 
терминальные операции, такие как findFirst / findAny, которые не пытаются сгенерировать все элементы в бесконечном потоке.

In the following example, we create an infinite stream and take only the first five elements from it:

Stream.generate(Math::random)
        .limit(5) // don't miss it
        .forEach(System.out::println);

Давайте рассмотрим другой пример, в котором применяется метод findAny. Этот метод просто возвращает один элемент из потока.

double randomNumber = Stream.generate(Math::random).findAny().get();

Этот код работает идеально, потому что метод findAny вызывает создание только одного элемента. Он не пытается создать весь бесконечный поток.


Второй метод, который мы рассматриваем, - это iterate. Это полная альтернатива стандартным циклам.

Для создания следующего значения на основе предыдущего требуется начальное значение (seed) и функция оператора.

Stream<T> iterate(T seed, UnaryOperator<T> next)

As an example, here is an infinite stream of odd numbers:

Stream<Integer> oddNumbersStream = Stream.iterate(1, x -> x + 2); // 1, 3, 5, ...

Здесь начальное значение равно 1, а функция для получения следующих значений-x - > x + 2.

Аналогично методу generate, этот поток бесконечен. Если мы хотим получить значения, мы должны сделать этот поток конечным.

В следующем примере мы печатаем первые пять нечетных чисел, используя метод itearte.

Stream.iterate(1, x -> x + 2)
        .limit(5)
        .forEach(System.out::println); // 1 3 5 7 9

Interestingly, the following code will lead to an error. Try to guess why!

int min = Stream.iterate(1, x -> x + 1).min(Comparator.naturalOrder()).get();

Для нас очевидно, что наименьшим элементом здесь является 1. Но компьютер не знает свойств функции, которая используется для получения следующих значений, и не может 
понять, что функция не создаст другое минимальное значение. Та же ошибка произойдет, если мы попытаемся выполнить любую операцию, которая формально требует обработки всех 
элементов бесконечного потока.

Кроме того, метод iterate имеет перегруженную версию, которая генерирует конечный поток. Требуется предикат, чтобы определить, есть ли в потоке следующий элемент.

Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)

In the following example, we use this method to print the odd numbers that are less than 10:

Stream.iterate(1, x -> x < 10, x -> x + 2)
        .forEach(System.out::println); // 1 3 5 7 9

Look! It is a complete alternative to the classic for loop.

for (int i = 1; i < 10; i += 2) {
    System.out.println(i);
}


========================================================================Parallel streams===================================================================================
Одной из важнейших особенностей Stream API и функционального программирования в целом является возможность легко писать понятный код для параллельной обработки данных. Нет 
необходимости создавать потоки вручную, проверять, хорошо ли синхронизирован код, и вызывать методы wait/notify. Все эти действия выполняются внутри параллельных потоков 
автоматически.

Под капотом параллельные потоки используют ForkJoinPool, представленный в Java 7, для управления параллельными исполнениями.

Существует несколько простых способов создания параллельных потоков:

1) вызвать метод parallelStream() коллекции вместо stream():

List<String> languages = List.of("java", "scala", "kotlin", "C#");

List<String> jvmLanguages = languages.parallelStream()
        .filter(lang -> !Objects.equals(lang, "C#"))
        .collect(Collectors.toList());

System.out.print(jvmLanguages); // [java, scala, kotlin]

2) преобразованиe существующего потока в параллельный поток с помощью метода parallel() :

long sum = LongStream
        .rangeClosed(1, 1_000_000)
        .parallel()
        .sum();

System.out.println(sum); // 500000500000

Как видите, несмотря на то, что мы используем параллельные потоки, весь код для работы с ними остается таким же, как и раньше.

Существует два дополнительных метода работы с параллельными потоками:

isParallel() возвращает true, если поток параллелен, и false в противном случае;
функция sequential() возвращает эквивалентный последовательный поток.

Важно, чтобы любой поток был либо параллельным, либо последовательным. Смешанный режим невозможен. Если pipeline потока вызывает как parallel(), так и sequential() методы, 
то последний вызванный метод определяет вид потока.

Очень легко сделать поток параллельным. Но должны ли мы всегда так поступать? Не совсем.

Параллельный поток не всегда быстрее, чем эквивалентный последовательный поток.
Существует ряд факторов, которые существенно влияют на производительность параллельного потока.

1) Размер данных. Чем больше размер данных → тем выше скорость.
2) Boxing/Unboxing. Примитивные типы обрабатываются быстрей wraper классов
3) Количество ядер, доступных во время выполнения. Чем больше доступных ядер → тем выше скорость.
4) Стоимость обработки одного элемента. Чем дольше обрабатывается каждый элемент, тем эффективнее распараллеливание. Но не рекомендуется использовать параллельный поток 
для выполнения слишком длительных операций (например, сетевых подключений). Так что это своего рода компромисс.
5) Тип источника данных. Обычно исходным источником данных является коллекция. Чем проще её разделить на части → тем выше скорость. Например, обычные массивы, ArrayList и 
IntStream.range являются хорошими источниками для разделения данных, поскольку они поддерживают произвольный доступ. Другие, такие как LinkedList, Stream.iterate, являются 
плохими источниками для разделения данных.
6) Тип операций: без состояния или с сохранением состояния. Операции без сохранения состояния (например, filter и map) лучше подходят для параллельной обработки, чем 
операции с сохранением состояния (например, distinct, sorted, limit). Операции, основанные на порядке элементов, особенно сложны для распараллеливания. Но не всегда их 
можно избежать.

Предположим, вы хотите вычислить сумму чисел и добавить 100 к результату. При использовании последовательного потока вы можете просто установить 100 в качестве начального 
значения (начального значения) метода reduce() :

int result = numbers.stream().reduce(100, Integer::sum);

Этот код дает тот же результат, что и следующий:

int result = numbers.stream().reduce(0, Integer::sum) + 100;

Но при использовании параллельного потока первый код приведет к странному результату. Причина в том, что ваш набор данных будет разделен на несколько частей, и к каждой из 
них будет добавлено значение 100.

При использовании параллельного потока используйте только нейтральный элемент (0 для суммирования, 1 для умножения и т. Д.) в качестве начального значения в методе 
reduce(). Лучше сделать то же самое и с последовательными потоками.

Дан отсортированный список чисел 1, 2, ..., 10. Мы хотели бы обработать и распечатать каждое число из списка с помощью потоков.

Вот последовательный поток:

sortedNumbers.stream()
        .map(Function.identity()) // some processing
        .forEach(n -> System.out.print(n + " "));
The output is:

1 2 3 4 5 6 7 8 9 10 

Here is a parallel stream:

sortedNumbers.parallelStream()
        .map(Function.identity()) // some processing
        .forEach(n -> System.out.print(n + " "));

The output:

6 7 9 10 8 3 4 1 5 2 

При использовании параллельного потока используйте forEachOrdered, а не forEach, если для вас важен порядок элементов. Но, в то же время, это уменьшит скорость потока. 

Возможно, вы подумали, что больше нет проблем с порядком элементов. Но это неправда: порядок и распараллеливание не друзья.

Давайте предположим, что мы хотели бы получить первые три четных числа из параллельного потока из двух соединенных потоков.

// create a filled list of integers
List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// create an empty list
List<Integer> emptyList = List.of();

Here is a concatenation, and processing of two lists.

Stream.concat(numbers.stream(), emptyList.stream())
        .parallel()
        .filter(x -> x % 2 == 0)
        .limit(3)
        .forEachOrdered((n) -> System.out.print(n + " "));

The output:

2 4 6

Все в порядке.

Но если мы создадим пустой список с помощью Collections.emptyList(), то у нас всегда будет другой результат.

The output:

2 4 10

Причина в том, что Collections.emptyList() не сообщает о своем порядке, и поток не может правильно использовать метод forEachOrdered.

Просто общий, но важный совет: будьте осторожны с порядком элементов в параллельных потоках. Вы можете столкнуться с неприятностями в самых непредсказуемых местах.


===================================================================================Jackson====================================================================================
To work on our project with the Jackson library, you must add the jackson-databind dependency which contains two other necessary dependencies, namely jackson-annotations and 
jackson-core. Its latest version is currently 2.13.3.

<details>
    <summary>Maven</summary>
    <pre>
        <code>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.13.3</version>
            </dependency>
        </code>
    </pre>
</details>
<details>
    <summary>Gradle</summary>
    <pre>
        <code>
            implementation 'com.fasterxml.jackson.core:jackson-databind:2.13.3'
        </code>
    </pre>
</details>

Let's imagine that we are developing a Twitter-like app and one of the main entities is a post. We want to describe the main components of the post: id, creation date, 
content, number of likes, and a list of comments (this is a rather simplistic model, but it's enough for us now).

public class Post {
    private int id;
    private Date createdDate;
    private String content;
    private int likes;
    private List<String> comments;

//  contructor, getters, setters
}

Jackson provides us with ObjectMapper which you will use for serializing/deserializing. You can see how straightforward it is in the following example:

// Step 1
Post post = new Post(
        1,
        new Date(),
        "I learned how to use jackson!",
        10,
        Arrays.asList("Well done!", "Great job!")
);

// Step 2
ObjectMapper objectMapper = new ObjectMapper();

// Step 3
String postAsString = objectMapper.writeValueAsString(post);

System.out.println(postAsString);
In Step 1, you create a post with some data. In Step 2, you create an ObjectMapper which provides us with an easy way to convert Java objects to JSON and vice versa. 
In Step 3, you use the writeValueAsString method which generates JSON and returns it as a string.

After running the code in the console, you will get the following result:

{"id":1,"createdDate":1655112861424,"content":"I learned how to use jackson!","likes":10,"comments":["Well done!","Great job!"]}

It is important to note that we are using the Date from java.util because Jackson supports it by default, and Jackson will serialize the Date to the timestamp format 
(number of milliseconds since January 1st, 1970, UTC).

You have converted the object to JSON in a few lines of code, but reading it in such a form is quite inconvenient. Let's get a formatted JSON string: for this purpose, you 
will use the writerWithDefaultPrettyPrinter() method for constructing a writer that will serialize objects using prettyprinter for indentation.

String postAsString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(post);
Here is our JSON:

{
  "id" : 1,
  "createdDate" : 1654027200000,
  "content" : "I learned how to use jackson!",
  "likes" : 10,
  "comments" : [ "Well done!", "Great job!" ]
}

As you see above, Jackson uses field names (id, createdDate, etc) as a key in JSON. But what if you need to change the key or don't want to put any field in JSON at all? 
Do you need to completely change the entire class? Jackson developers took care of these situations and provided us with a set of annotations you can use for such cases. 
Let's look at the most basic of them in this and the next sections.

The first annotation you will talk about is @JsonProperty. You can use this annotation in different cases, two of which you'll discuss below.

Firstly, @JsonProperty allows you to change the name used in JSON as a key. Let's change the name from createdDate to postedAt:

public static class Post {
    private int id;

    @JsonProperty("postedAt")
    private Date createdDate;

    private String content;
    private int likes;
    private List<String> comments;
}
Here is our JSON:

{
  "id" : 1,
  "content" : "I learned how to use jackson!",
  "likes" : 10,
  "comments" : [ "Well done!", "Great job!" ],
  "postedAt" : 1654027200000 // here
}

The second case is to use @JsonProperty to denote a non-standard getter/setter that will be used on a JSON property.

For example, if you want to display createdDate in a readable format (like 01-01-2000), you need to put @JsonProperty above the method that will do this conversion:

public static class Post {
    private int id;
    private Date createdDate;
    private String content;
    private int likes;
    private List<String> comments;


    @JsonProperty("createdDate")
    public String getReadableCreatedDate() {
        return (new SimpleDateFormat("dd-MM-yyyy")).format(createdDate);
    }

// contructor, getters, setters
}
Here is our JSON with the formatted date:

{
  "createdDate" : "01-06-2022",
  "content" : "I learned how to use jackson!",
  "likes" : 10,
  "comments" : [ "Well done!", "Great job!" ]
}

@JsonIgnore helps us ignore some Java class fields.

For instance, the message ID (id) is sensitive information and you would not want anyone to know it, so it's best to ignore this field.

public static class Post {
    @JsonIgnore
    private int id;
    private Date createdDate;
    private String content;
    private int likes;
    private List<String> comments;
}
Now let's confirm that there is no id in JSON:

{
  "content" : "I learned how to use jackson!",
  "likes" : 10,
  "comments" : [ "Well done!", "Great job!" ],
  "createdDate" : 1654027200000
}

If you look closely at the example with the @JsonProperty annotation, you can see that after changing the name from createdDate to postedAt in JSON, this field is displayed last. Does it mean that the order of the fields is strictly regulated and you must follow it?

By default, the ordering of the fields in the serialized JSON depends on the JDK. They may come in the declaration order but it's not guaranteed.

@JsonPropertyOrder allows us to set a specific order when serializing a Java object.

@JsonPropertyOrder({
            "likes",
            "comments",
            "createdDate", // here you can also use 'postedAt'
            "content",
    })
public static class Post {
    @JsonIgnore
    private int id;

    @JsonProperty("postedAt")
    private Date createdDate;

    private String content;
    private int likes;
    private List<String> comments;
}
Let's check that the order has changed:

{
  "likes" : 10,
  "comments" : [ "Well done!", "Great job!" ],
  "postedAt" : 1654027200000,
  "content" : "I learned how to use jackson!"
}
[ALERT]As you can see, you used createdDate in @JsonPropertyOrder but there wouldn't be a problem if you also used postedAt.[/ALERT]

Finally, knowing how to convert Java objects to JSON, you also need to understand how to do the reverse conversion. For this, you use the readValue method from ObjectMapper.

String inputJson = "{\"id\":1,\"createdDate\":1654027200000,\"content\":\"I learned how to use jackson!\",\"likes\":10,\"comments\":[\"Well done!\",\"Great job!\"]}\n";

ObjectMapper objectMapper = new ObjectMapper();
Post post = objectMapper.readValue(inputJson, Post.class);

Let's dive deeper into it and talk about the restrictions for the class that you will create from the JSON string. For Jackson to be able to convert JSON into a Java object 
of some class, this class must satisfy several conditions:

The class must have an empty constructor, and the fields must not be final. In this case, Jackson will first create an instance of the class, and then put values into all 
fields through reflection. Setters are only needed if you want to change the value in the fields — Jackson doesn't use them.

public class Post {
    private int id;
    private Date createdDate;
    private String content;
    private int likes;
    private List<String> comments;

    public Post() {
    }

// getters, setters
}

The class must have a constructor with the @JsonCreator annotation, and all its parameters must have the @JsonProperty annotation, which must necessarily contain the name 
from JSON.

public class Post {
    private final int id;
    private final Date createdDate;
    private String content;
    private int likes;
    private List<String> comments;

    @JsonCreator
    public Post(
            @JsonProperty("id") int id,
            @JsonProperty("createdDate") Date createdDate,
            @JsonProperty("content") String content,
            @JsonProperty("likes") int likes,
            @JsonProperty("comments") List<String> comments) {
        this.id = id;
        this.createdDate = createdDate;
        this.content = content;
        this.likes = likes;
        this.comments = comments;
    }

// getters
}


==========================================================Processes and threads============================================================
Процесс — это автономная исполнительная единица, в которой есть все необходимое для выполнения задачи. Короче говоря, процесс является 
контейнером для своих потоков, всего необходимого для их работы и их общих ресурсов. Дешевле организовать доступ к общим ресурсам один раз, 
чем делать это каждый раз, когда вы создаете новый поток. Процесс должен иметь по крайней мере один поток, поскольку они выполняют всю 
работу.

Если мы посмотрим на пиццерию, то аналогией этого процесса может служить одна пиццерия. Здесь есть все условия и оборудование, необходимые 
работнику для выполнения работы. Оборудование стоит дорого, поэтому оно дешевле и эффективнее, когда работники делятся им. Каждому 
работнику нет необходимости приобретать личное оборудование. С другой стороны, магазин без рабочих ничего не может. Необходимо иметь хотя 
бы одного рабочего, потому что без него все оборудование будет бесполезным. В совокупности эти вещи составляют процесс изготовления и 
продажи пиццы.

В компьютерных науках Thread — это поток инструкций внутри процесса, который можно планировать и запускать независимо. У каждого потока 
есть свой исполнитель, и этот исполнитель может одновременно выполнять только один поток. Несколько потоков внутри одного процесса могут 
выполняться одновременно или параллельно. Чтобы понять, что означает термин Thread, подумайте о сотрудниках пиццерии. Они работают в 
соответствии со своими должностными инструкциями. Они выполняют различные задачи в соответствии с правилами, установленными магазином, 
используя общие ресурсы, предоставленные магазином. Работники в пиццерии играют роль исполнителей потоков. Задачи, которые выполняют 
рабочие, являются потоками в «процессе» пиццерии.

Рабочие могут играть разные роли в процессе продажи пиццы. Каждый из них может одновременно быть продавцом, кассиром или поваром на 
разных этапах процесса. Этот параллелизм происходит не между рабочими, а между ролями, которые играет каждый рабочий. Важной особенностью 
этих ролей является то, что их задачи обычно выполняются достаточно быстро и не требуют значительного количества времени и общих ресурсов.
Они lightweight (лёгкие).

Если задачи легкие и не требуют доступа к каким-либо общим ресурсам, кроме времени и внимания исполнителя, нет необходимости запускать их 
в разных потоках. Дешевле организовать их параллельное выполнение с разделением по времени внутри одного потока. Параллелизм такого рода 
называется внутренним по понятным причинам. Часто его также называют лёгким, потому что задачи внутри такого потока обычно небольшие и 
быстрые.

- Процессы — это своего рода контейнеры для рабочих потоков, общих ресурсов и параметров, объединенных общей целью. Каждый из них всегда 
имеет хотя бы один поток.
- Потоки — это независимые исполнительные единицы внутри процесса; они могут работать одновременно или параллельно друг другу.
- Параллельные задачи, которые конкурируют только за время исполнителя и не требуют много ресурсов для выполнения, могут выполняться 
одновременно внутри одного и того же потока. Эти задачи называются лёгкими, а такой тип параллелизма называется внутренним или облегченным. 
Выполнение внутри потоков может быть синхронным или асинхронным, но не параллельным.

===========================================================Threads as objects==============================================================
Изначально Java была разработана со встроенной поддержкой многопоточности. Потоки поддерживаются на уровне JVM, на уровне языка по 
специальным ключевым словам и на уровне стандартной библиотеки. Каждая программа Java имеет по крайней мере один поток, называемый main, 
который автоматически создается процессом JVM для выполнения инструкций внутри основного метода. В любой Java-программе есть и другие 
потоки по умолчанию (например, отдельный поток для сборщика мусора). На всех этапах развития языка Java подход к многопоточности менялся от 
использования низкоуровневых потоков к некоторым высокоуровневым абстракциям.

Каждый поток представлен объектом, который является экземпляром класса java.lang.Thread (или его подкласса). Этот класс имеет статический 
метод с именем currentThread для получения ссылки на текущий исполняемый объект потока:

Thread thread = Thread.currentThread(); // the current thread

У любого потока есть имя, идентификатор (long), приоритет и некоторые другие характеристики, которые можно получить через его методы.

В приведенном ниже примере показано, как получить характеристики main потока, ссылаясь на него через объект класса Thread.

public class MainThreadDemo {
    public static void main(String[] args) {
        Thread t = Thread.currentThread(); // main thread

        System.out.println("Name: " + t.getName());
        System.out.println("ID: " + t.getId());
        System.out.println("Alive: " + t.isAlive());
        System.out.println("Priority: " + t.getPriority());
        System.out.println("Daemon: " + t.isDaemon());

        t.setName("my-thread");
        System.out.println("New name: " + t.getName());
    }
}

Вызов t.isAlive() возвращает, был ли поток запущен и еще не умер. У каждого потока есть приоритет, и метод getPriority() возвращает 
приоритет данного потока. Потоки с более высоким приоритетом выполняются в первую очередь, чем потоки с более низким приоритетом. 
Вызов t.isDaemon() проверяет, является ли поток демоном. Поток демона (по терминологии UNIX) — это поток с низким приоритетом, который 
работает в фоновом режиме для выполнения таких задач, как сборка мусора и т. д. JVM не ожидает потоков демона перед выходом, пока он 
ожидает потоков, не являющихся демонами.

The output of the program will look like:

Name: main
ID: 1
Alive: true
Priority: 5
Daemon: false
New name: my-thread


==============================================================Custom threads===============================================================
Основной поток — это отправная точка, из которой вы можете создавать новые потоки для выполнения ваших задач. Для этого вам нужно написать 
код, который будет выполняться в отдельном потоке, а затем запустить его.

В Java есть два основных способа создания нового потока, выполняющего нужную вам задачу.

1) расширяя класс Thread и переопределяя его метод run();

class HelloThread extends Thread {

    @Override
    public void run() {
        String helloMsg = String.format("Hello, i'm %s", getName());
        System.out.println(helloMsg);
    }
}

2) реализуя интерфейс Runnable и передавая реализацию конструктору класса Thread.

class HelloRunnable implements Runnable {

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        String helloMsg = String.format("Hello, i'm %s", threadName);
        System.out.println(helloMsg);
    }
}

В обоих случаях следует переопределить метод run, который является обычным методом Java и содержит код для выполнения задачи. Какой 
подход выбрать, зависит от задачи и от ваших предпочтений. Если вы расширяете класс Thread, вы можете принимать поля и методы базового 
класса, но вы не можете расширять другие классы, поскольку в Java нет множественного наследования классов.

Вот два объекта, полученные описанными выше подходами соответственно:

Thread t1 = new HelloThread(); // a subclass of Thread

Thread t2 = new Thread(new HelloRunnable()); // passing runnable

А вот еще один способ указать имя вашего потока, передав его конструктору:

Thread myThread = new Thread(new HelloRunnable(), "my-thread");

Если вы уже знакомы с лямбда-выражениями, вы можете сделать это следующим образом:

Thread t3 = new Thread(() -> {
    System.out.println(String.format("Hello, i'm %s", Thread.currentThread().getName()));
});

Теперь вы создали объекты для потоков, но это еще не все. Чтобы выполнить нужные вам задачи, вам придется их запустить.

Класс Thread имеет метод start(), который используется для запуска потока. В какой-то момент после вызова этого метода автоматически будет 
запущен метод run, но не сразу.

Предположим, что внутри основного метода вы создаете объект HelloThread с именем t и запускаете его.

Thread t = new HelloThread(); // an object representing a thread
t.start();

Eventually, it prints something like:

Hello, i'm Thread-0y

By default, a new thread is running in non-daemon mode. Напоминание: разница между режимом daemon и режимом non-daemon заключается в том, 
что JVM не завершит работающую программу, пока еще остались non-daemon потоки, в то время как daemon потоки не предотвратят завершение 
работы JVM.

Не путайте методы run и start. Вы должны вызвать start, если хотите выполнить свой код внутри run в отдельном потоке. Если вы вызываете 
run напрямую, код будет выполняться в том же потоке.

Если вы попытаетесь запустить поток более одного раза, запуск вызовет исключение IllegalThreadStateException.

Несмотря на то, что внутри одного потока все операторы выполняются последовательно, определить относительный порядок операторов между 
несколькими потоками невозможно без дополнительных мер.

public class StartingMultipleThreads {

    public static void main(String[] args) {
        Thread t1 = new HelloThread();
        Thread t2 = new HelloThread();

        t1.start();
        t2.start();

        System.out.println("Finished");
    }
}

The order of displaying messages may be different. Here is one of them:

Hello, i'm Thread-1
Finished
Hello, i'm Thread-0

It is even possible that all threads may print their text after the main thread prints "Finished":

Finished
Hello, i'm Thread-0
Hello, i'm Thread-1

Это означает, что хотя мы вызываем метод start последовательно для каждого потока, мы не знаем, когда на самом деле будет вызван метод run.

Рассмотрим простую многопоточную программу с двумя потоками. Первый поток считывает числа из стандартного ввода и выводит их квадраты. 
В то же время основной поток время от времени выводит сообщения на стандартный вывод. Оба потока работают одновременно.

Вот поток, который считывает числа в цикле и возводит их в квадрат. У него есть оператор break для остановки цикла, если заданное число 
равно 0.

class SquareWorkerThread extends Thread {
    private final Scanner scanner = new Scanner(System.in);

    public SquareWorkerThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        while (true) {
            int number = scanner.nextInt();
            if (number == 0) {
                break;
            }
            System.out.println(number * number);
        }
        System.out.println(String.format("%s finished", getName()));
    }
}

Внутри основного метода программа запускает объект класса SquareWorkerThread, который пишет сообщения в стандартный вывод из 
основного потока.

public class SimpleMultithreadedProgram {

    public static void main(String[] args) {
        Thread worker = new SquareWorkerThread("square-worker");
        worker.start(); // start a worker (not run!)

        for (long i = 0; i < 5_555_555_543L; i++) {
            if (i % 1_000_000_000 == 0) {
                System.out.println("Hello from the main!");
            }
        }
    }
}

Here is an example of inputs and outputs with comments:

Hello from the main!   // the program outputs it
2                      // the program reads it
4                      // the program outputs it
Hello from the main!   // outputs it
3                      // reads it
9                      // outputs it
5                      // reads it
Hello from the main!   // outputs it
25                     // outputs it
0                      // reads it
square-worker finished // outputs it
Hello from the main!   // outputs it
Hello from the main!   // outputs it

Process finished with exit code 0

Как видите, эта программа выполняет две задачи «одновременно»: одну в основном потоке, а другую в рабочем потоке. Это может быть не 
«одно и то же время» в физическом смысле, однако обеим задачам дается некоторое время на выполнение.


===========================================================Thread management===============================================================
Мы уже научились запускать новый поток, просто вызывая метод start для соответствующего объекта. Однако иногда необходимо управлять 
жизненным циклом потока, пока он работает, а не просто запустить его и оставить в покое. 

В этом разделе мы рассмотрим два часто используемых метода в многопоточном программировании: sleep() и join(). Оба метода могут генерировать 
проверяемое исключение InterruptedException, которое здесь для краткости опущено.

Статический метод Thread.sleep() заставляет текущий исполняемый поток приостанавливать выполнение на указанное количество миллисекунд. 
Это эффективный способ сделать процессор доступным для других потоков приложения или других приложений, которые могут выполняться на компьютере.

System.out.println("Started");

Thread.sleep(2000L); // suspend current thread for 2000 millis
         
System.out.println("Finished");

Еще один способ заставить текущий поток спать — использовать специальный класс TimeUnit из пакета java.util.concurrent:

TimeUnit.MILLISECONDS.sleep(2000) performs Thread.sleep for 2000 milliseconds;
TimeUnit.SECONDS.sleep(2) performs Thread.sleep for 2 seconds;

There are more existing periods: NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS.

Метод join заставляет текущий поток ожидать завершения другого потока, в котором был вызван метод. В следующем примере строка 
«Do something else» не будет напечатана, пока поток не завершится.

Thread thread = ...
thread.start(); // start thread

System.out.println("Do something useful");

thread.join();  // waiting for thread to die

System.out.println("Do something else");

Перегруженная версия этого метода требует времени ожидания в миллисекундах. Это используется, чтобы избежать слишком долгого 
или даже бесконечного ожидания в случае зависания потока:

thread.join(2000L);

Рассмотрим другой пример. Класс Worker разработан для решения «сложной задачи», моделируемой сном:

class Worker extends Thread {
    
    @Override
    public void run() {
        try {
            System.out.println("Starting a task");
            Thread.sleep(2000L); // it solves a difficult task
            System.out.println("The task is finished");
        } catch (Exception ignored) {
        }
    }
}

Вот основной метод, в котором основной поток ожидает завершения Worker процесса.

public class JoiningExample {
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Worker();
        worker.start(); // start the worker
       
        Thread.sleep(100L);
        System.out.println("Do something useful");
        
        worker.join(3000L);  // waiting for the worker
        System.out.println("The program stopped");
    }
}

Основной поток ожидает worker и не может напечатать сообщение. Программа остановлена ​​до тех пор, пока worker не завершится или не будет 
превышено время ожидания. Мы точно знаем только то, что "Starting a task" предшествует "The task is finished" и "Do something useful" 
предшествует "The program stopped". Есть несколько возможных выходов. 

Первый возможный результат (задача завершается до истечения времени ожидания):

Starting a task
Do something useful
The task is finished
The program stopped

Второй возможный выход (задача завершается до истечения времени ожидания):

Do something useful
Starting a task
The task is finished
The program stopped

Third possible output:

Do something useful
Starting a task
The program stopped
The task is finished

Fourth possible output:

Starting a task
Do something useful
The program stopped
The task is finished


========================================================Exceptions in threads==============================================================
Если один из потоков вашей программы выдает исключение, которое не перехватывается ни одним из методов в стеке вызовов, поток будет завершен.
Если такое исключение возникает в однопоточной программе, вся программа останавливается, потому что JVM завершает работающую программу, как 
только не остается non-daemon потоков.

public class SingleThreadProgram {
    public static void main(String[] args) {
        System.out.println(2 / 0);
    }
}

Exception in thread "main" java.lang.ArithmeticException: / by zero
  at org.example.multithreading.exceptions.SingleThreadProgram.main(SingleThreadProgram.java:6)

Process finished with exit code 1

Код 1 означает, что процесс завершился с ошибкой.

Если внутри созданного нами нового потока произойдет ошибка, весь процесс не будет остановлен:

public class ExceptionInThreadExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new CustomThread();
        thread.start();
        thread.join(); // wait for thread with exception to terminate
        System.out.println("I am printed!"); // this line will be printed
    }
}

class CustomThread extends Thread {

    @Override
    public void run() {
        System.out.println(2 / 0);
    }
}

Несмотря на неперехваченное исключение, программа будет успешно завершена.

Exception in thread "Thread-0" java.lang.ArithmeticException: / by zero  at org.example.multithreading.exceptions.CustomThread.run(ExceptionInThreadExample.java:15)
I am printed!

Process finished with exit code 0

Код 0 означает, что процесс успешно завершен.


=========================================================States of a thread================================================================
В Java состояние потока представлено enum Thread.State с шестью возможными значениями:

- NEW: экземпляр класса Thread создан, но еще не запущен; 
- RUNNABLE: поток выполняется в JVM, но может ожидать ресурсов ОС, таких как процессор;
- BLOCKED: поток, который заблокирован в ожидании monitor lock; 
- WAITING: поток неопределенно долго ожидает другого потока для выполнения задачи (например, join() без тайм-аута);
- TIMED_WAITING: поток ожидает другого потока в течение заданного времени ожидания (например, sleep(), join() с тайм-аутом);
- TERMINATED: поток завершается, когда метод запуска полностью выполняет сам себя или возникает неперехваченное исключение. Как только 
поток завершается, он никогда не возвращается в рабочее состояние.

Для получения текущего состояния потока существует метод экземпляра getState(). 

Посмотрим, как меняются эти состояния в зависимости от действий программиста.

Thread worker = ... // new worker to make a difficult task
System.out.println(worker.getState()); // NEW
         
worker.start(); // start the worker
System.out.println(worker.getState()); // RUNNABLE

worker.join();  // waiting for completing the worker
System.out.println(worker.getState()); // TERMINATED

Состояния, рассмотренные выше, специфичны c точки зрения Java. Реальный жизненный цикл потока немного отличается. Например, состояние 
RUNNABLE на самом деле сложнее, чем может показаться. В этом состоянии поток может фактически выполняться или быть готовым к выполнению.

Ниже вы можете увидеть упрощенный жизненный цикл потока, связанный с терминологией ОС. Диаграмма включает пять состояний и событий, которые 
заставляют поток переходить из одного состояния в другое.

После инициализации поток готов к запуску (Ready). Планировщик потоков должен дать некоторое врем для выполнения потока (Running), а затем 
снова перевести его в состояние Ready. Это используется для одновременного разделения процессорного времени между несколькими потоками. В 
противном случае один поток мог бы захватить все доступное процессорное время.

Состояние Waiting означает, что поток временно неактивен (например, поток может ожидать другого потока или завершать ввод-вывод). Поток в 
этом состоянии не может продолжать выполнение, пока не будет переведен в состояние Ready. Конечно, реальный жизненный цикл потоков еще 
сложнее, чем мы обсуждали. Например, состояние Waiting фактически соответствует нескольким состояниям одновременно.


==============================================================Shared data==================================================================
Потоки, принадлежащие одному и тому же процессу, совместно используют общую память (которая называется кучей). Они могут общаться, 
используя общие данные в памяти. Чтобы иметь возможность доступа к одним и тем же данным из нескольких потоков, каждый поток должен иметь 
ссылку на эти данные (по объекту).

Рассмотрим пример. Вот класс с именем Counter.

class Counter {

    private int value = 0;

    public void increment() {
        value++;
    }

    public int getValue() {
        return value;
    }
}

В классе есть два метода: increment и getValue. Каждый вызов increment добавляет 1 к значению value, а вызов getValue возвращает текущее 
значение поля value.

А вот класс, расширяющий Thread:

class MyThread extends Thread {

    private final Counter counter;

    public MyThread(Counter counter) {
        this.counter = counter;
    }

    @Override
    public void run() {
        counter.increment();
    }
}

Конструктор MyThread берет экземпляр Counter и сохраняет его в поле. Метод run вызывает метод increment объекта Сounter.

Давайте теперь создадим экземпляр Counter и два экземпляра MyThread. Оба экземпляра MyThread имеют одинаковую ссылку на объект Сounter.

Counter counter = new Counter();

MyThread thread1 = new MyThread(counter);
MyThread thread2 = new MyThread(counter);

Теперь давайте посмотрим, что произойдет, когда мы запустим оба потока один за другим и выведем результат counter.getValue().

thread1.start(); // start the first thread
thread1.join();  // wait for the first thread

thread2.start(); // start the second thread
thread2.join();  // wait for the second thread

System.out.println(counter.getValue()); // it prints 2

Как видите, если вы попробуете это сделать самостоятельно, результат будет равен 2, потому что оба потока работают с одними и теми 
же данными, используя ссылку. 

Когда вы пишете свой код в разных потоках, которые одновременно работают с одними и теми же данными, важно понимать несколько вещей:

- некоторые операции не являются атомарными; 
- изменения переменной, выполняемые одним потоком, могут быть невидимы для других потоков; 
- если изменения видны, их порядок может быть не таким (переупорядочение).

Неатомарная операция — это операция, состоящая из нескольких шагов. Поток может работать с промежуточным значением неатомарной операции, 
выполняемой другим потоком. Это приводит к проблеме, называемой thread interference: последовательности шагов неатомарных операций, 
выполняемых несколькими потоками, которые могут перекрываться.

Давайте начнем с объяснения, почему increment() является неатомарной операцией и как именно она работает. В качестве примера снова 
рассмотрим класс Counter.

class Counter {

    private int value = 0;

    public void increment() {
        value++; // the same thing as value = value + 1   
    }

    public int getValue() {
        return value;
    }
}

Примечание: в предыдущем примере два потока не работали с данными одновременно. Перед началом второго потока первый уже завершился.

Значение операции value++ можно разбить на три шага: 

1) прочитать текущее значение; 
2) увеличить значение на 1; 
3) записать увеличенное значение обратно в поле;

Поскольку операция increment() не является атомарной и требует 3 шагов для работы, вмешательство потока может произойти в случае, если два 
потока вызывают метод increment() одного и того же экземпляра Counter/

Предположим, что у нас есть экземпляр класса Counter:

Counter counter = new Counter();

Начальное значение поля value равно 0. Теперь, если поток A и поток В одновременно вызывают increment() этого экземпляра, происходит 
следующее:

Thread A: read value from the variable.
Thread A: increment the read value by 1.
Thread B: read value from the variable (it reads an intermediate value 0).
Thread A: write the result in the variable (now, the current value of the field is 1).
Thread B: increment the read value by 1.
Thread B: write the result in the variable (now, the current value of the field is 1).

В этом случае после вызова метода increment из двух потоков мы можем получить неожиданный результат (1 вместо 2). Это означает, что 
результат потока A был потерян, перезаписан потоком B. Хотя иногда результат может быть правильным, это конкретное перемежение возможно.

Рассмотрим другой случай: присвоение 64-битных значений. Это может быть удивительно, но даже поля чтения и записи типов double и 
long (64-битные) могут не быть атомарными на некоторых платформах.

class MyClass {

    long longVal; // reading and writing may be not atomic

    double doubleVal; // reading and writing may be not atomic
}

Это означает, что пока поток записывает значение в переменную, другой поток может получить доступ к промежуточному результату 
(например, только к 32 записанным битам). Чтобы сделать эти операции атомарными, поля должны быть объявлены с использованием ключевого 
слова volatile.

class MyClass {

    volatile long longVal; // reading and writing are atomic now

    volatile double doubleVal; // reading and writing are atomic now
}

Чтение и запись в поля других примитивных типов (boolean, byte, short, int, char, float) гарантированно атомарны.

Иногда, когда поток изменяет общие данные, другой поток может не заметить эти изменения или получить их в другом порядке. Это означает, 
что разные потоки могут иметь несогласованные представления одних и тех же данных. Причины разные, включая кеширование значений для 
потоков, оптимизацию компилятора и прочее. К счастью, большинству программистов не требуется детальное понимание причин. Все, что 
нужно, — это стратегия их избегания.

Пример. Вот поле int, определенное и инициализированное:

int number = 0;

Поле используется совместно двумя потоками: Thread A и Thread B. Поток A увеличивает число на 5.

number += 5;

Сразу после этого Thread B выводит число в стандартный вывод:

System.out.println(number);

Результатом может быть либо 0, либо 5, поскольку нет гарантии, что изменение, выполненное потоком A, будет видно потоку B.

Как мы уже упоминали, ключевое слово volatile используется для видимости. Чтобы сделать видимыми изменения значения, сделанные одним 
потоком в других потоках, мы должны объявить поле с ключевым словом volatile.

volatile int number = 0;

Когда поле объявлено как volatile, все изменения, внесенные в это поле потоком, гарантированно будут видны другому потоку, когда он 
считывает значение из этого поля. Ключевое слово volatile может быть записано в объявлении экземпляра и статических полей.

Иногда нам не нужно писать ключевое слово volatile. Следующие процедуры также гарантируют видимость:

- изменения переменных, выполняемые потоком перед запуском нового потока, всегда видны новому потоку;
- изменения переменных внутри потока всегда видны любым другим потокам после успешного выполнения метода join() с потоком 
(мы использовали это в начале этой темы).

Опять же, ключевое слово volatile позволяет нам сделать видимыми изменения поля, сделанные одним потоком, в других потоках. Это ключевое 
слово также делает атомарной запись в double и long поля. Но ключевое слово не делает increment/decrement и подобные операции атомарными. 
На самом деле в volatile есть более абстрактные и сложные вещи, но мы пока пропустим эту информацию.



=======================================================Thread synchronization==============================================================
Одновременная работа с общими данными из нескольких потоков может привести к неожиданному или ошибочному поведению. К счастью, Java 
предоставляет механизм для управления доступом нескольких потоков к общему ресурсу любого типа. Этот механизм известен как синхронизация 
потоков.

Прежде чем мы начнем использовать синхронизацию в нашем коде, давайте познакомимся с терминами и понятиями, которые мы собираемся 
использовать

1) critical section - это область кода, которая обращается к общим ресурсам и не должна выполняться более чем одним потоком одновременно. 
Общий ресурс может быть переменной, файлом, портом ввода/вывода, базой данных или чем-то еще.

Рассмотрим пример. В классе есть статическое поле с именем counter:

public static long counter = 0;

Два потока увеличивают поле (увеличивают на 1) 10 000 000 раз одновременно. Окончательное значение должно быть 20 000 000. Но, как мы 
обсуждали в предыдущих темах, результат часто может оказаться неправильным, например, 10 999 843.

Это происходит потому, что иногда поток не видит изменений общих данных, выполненных другим потоком, а иногда поток может видеть 
промежуточное значение неатомарной операции. Это проблемы видимости и атомарности, с которыми мы сталкиваемся при работе с общими данными.
Вот почему увеличение значения с помощью нескольких потоков является critical section. Конечно, этот пример очень простой, critical 
section может быть намного сложнее.

2) Монитор — это специальный механизм для управления одновременным доступом к объекту. В Java с каждым объектом и классом связан неявный 
монитор. Поток может получить монитор, тогда как другие потоки не могут получить этот монитор одновременно. Они будут ждать, пока 
владелец (поток, который использует монитор) не освободит его.

Таким образом, поток может быть заблокирован монитором объекта и ждать его освобождения. Этот механизм позволяет программистам защитить 
critical section от одновременного доступа нескольких потоков.

«Классический» и самый простой способ защитить код от одновременного доступа к нему нескольких потоков — использовать ключевое слово 
synchronized. Он используется в двух различных формах:

- синхронизированный метод (статический или метод экземпляра) 
- синхронизированные блоки или операторы (внутри статического метода или метода экземпляра)

Синхронизированному методу или блоку нужен объект для блокировки потоков. Монитор, связанный с этим объектом, управляет одновременным 
доступом к указанной critical section. Только один поток может одновременно выполнять код в синхронизированном блоке или методе. Другие 
потоки блокируются до тех пор, пока поток внутри синхронизированного блока или метода не выйдет из него.

Когда мы синхронизируем статические методы с помощью ключевого слова synchronized, монитор — это сам класс. Только один поток может 
выполнять тело синхронизированного статического метода одновременно. Это можно охарактеризовать как «один поток на класс».

Вот пример класса с одним синхронизированным статическим методом с именем doSomething.

class SomeClass {

    public static synchronized void doSomething() {
        
        String threadName = Thread.currentThread().getName();
        System.out.println(String.format("%s entered the method", threadName));
        System.out.println(String.format("%s leaves the method", threadName));
    }
}

Метод doSomething объявлен как синхронизированный. Он может быть вызван только из одного потока одновременно. Метод синхронизируется в 
классе, к которому принадлежит статический метод (монитор — SomeClass).

Давайте вызовем метод из двух потоков одновременно. Результат всегда будет похож на:

Thread-0 entered the method
Thread-0 leaves the method
Thread-1 entered the method
Thread-1 leaves the method

Методы экземпляра синхронизируются с экземпляром (объектом). Монитор — это текущий объект (this), которому принадлежит метод. Если у нас 
есть два экземпляра класса, у каждого экземпляра есть монитор для синхронизации. Только один поток может выполнять код в методе 
синхронизированного экземпляра конкретного экземпляра. Но разные потоки могут одновременно выполнять методы разных объектов. Это можно 
резюмировать как «один поток на экземпляр».

Вот пример класса с одним синхронизированным методом экземпляра с именем doSomething. В классе также есть конструктор для 
различия экземпляров.

class SomeClass {

    private String name;

    public SomeClass(String name) {
        this.name = name;
    }

    public synchronized void doSomething() {

        String threadName = Thread.currentThread().getName();
        System.out.println(String.format("%s entered the method of %s", threadName, name));
        System.out.println(String.format("%s leaves the method of %s", threadName, name));
    }
}

Давайте создадим два экземпляра класса и три потока, вызывающих doSomething. Первый и второй потоки берут один и тот же экземпляр класса, 
а третий поток берет другой.

SomeClass instance1 = new SomeClass("instance-1");
SomeClass instance2 = new SomeClass("instance-2");

MyThread first = new MyThread(instance1);
MyThread second = new MyThread(instance1);
MyThread third = new MyThread(instance2);

first.start();
second.start();
third.start();

The result will look like this:

Thread-0 entered the method of instance-1
Thread-2 entered the method of instance-2
Thread-0 leaves the method of instance-1
Thread-1 entered the method of instance-1
Thread-2 leaves the method of instance-2
Thread-1 leaves the method of instance-1

Как видите, нет ни одного потока, выполняющего код в doSomething instance-1 одновременно. Попробуйте запустить его много раз.

Иногда вам нужно синхронизировать только часть метода. Это возможно с помощью синхронизированных блоков (операторов). Они должны указывать 
объект для блокировки потоков. Вот класс со статическим методом и методом экземпляра. Оба метода не синхронизированы, но содержат 
синхронизированные части внутри.

class SomeClass {

    public static void staticMethod() {

        // unsynchronized code
                
        synchronized (SomeClass.class) { // synchronization on the class
            // synchronized code
        }
    }

    public void instanceMethod() {

        // unsynchronized code

        synchronized (this) { // synchronization on this instance
            // synchronized code
        }
    }
}

Блок внутри staticMethod синхронизируется с классом, что означает, что только один поток может выполнять код в этом блоке.

Блок внутри instanceMethod синхронизируется с этим экземпляром, что означает, что только один поток может выполнить блок экземпляра. Но 
какой-то другой поток может выполнять блок разных экземпляров одновременно.

Синхронизированные блоки могут напоминать синхронизированные методы, но они позволяют программистам синхронизировать только необходимые 
части методов.

Спецификация языка Java гарантирует, что изменения, выполненные потоком, видны другим потокам, если они синхронизируются на том же 
мониторе. Точнее, если поток изменил общие данные (например, переменную) внутри синхронизированного блока или метода и освободил 
монитор, другие потоки могут видеть все изменения после получения того же монитора.

Вот пример. Это синхронизированный счетчик с двумя синхронизированными методами экземпляра: increment и getValue.

class SynchronizedCounter {
    
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getValue() {
        return count;
    }
}

Когда несколько потоков вызывают инкремент для одного и того же экземпляра, проблем не возникает, поскольку ключевое слово synchronized 
защищает общее поле. Только один поток может изменить поле. Другие потоки будут ждать, пока поток освободит монитор. Все изменения 
переменной count видны.

Метод getValue не изменяет поле. Он читает только текущее значение. Метод синхронизирован, так что читающий поток всегда считывает 
фактическое значение; в противном случае нет гарантии, что читающий поток увидит счетчик таким, какой он есть после его изменения.

Вот класс Worker, который расширяет Thread. Класс берет экземпляр SynchronizedCounter и вызывает метод increment 10 000 000 раз.

class Worker extends Thread {

    private final SynchronizedCounter counter;

    public Worker(SynchronizedCounter counter) {
        this.counter = counter;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10_000_000; i++) {
            counter.increment();
        }
    }
}

Следующий код создает экземпляр SynchronizedCounter, запускает потоки и печатает результат.

SynchronizedCounter counter = new SynchronizedCounter();

Worker worker1 = new Worker(counter);
Worker worker2 = new Worker(counter);

worker1.start();
worker2.start();

worker1.join();
worker2.join();

System.out.println(counter.getValue()); // the result is 20_000_000

Однако иногда нет необходимости синхронизировать методы, которые только считывают общие данные (включая геттеры):

- Если у нас есть гарантия, что читающий поток успешно возвращается из объединения всех записывающих потоков, когда он читает поле. Это 
верно для приведенного выше кода, и мы можем удалить ключевое слово synchronized из объявления getValue.
- Если общее поле объявлено с ключевым словом volatile. В этом случае мы всегда будем видеть фактическое значение этого поля.

Важно: объект или класс, у которого есть только один монитор и только один поток, могут выполнять синхронизированный код на одном мониторе.
Это означает, что если класс имеет несколько синхронизированных методов экземпляра и поток вызывает один из них, другие потоки не могут 
выполнять ни один из этих методов в том же экземпляре, пока первый поток не освободит монитор экземпляра.

Вот пример: класс с тремя методами экземпляра. Два метода синхронизированы, а третий имеет внутренний синхронизированный блок. Оба метода 
и блок синхронизируются на мониторе этого экземпляра.

class SomeClass {

    public synchronized void method1() {
        // do something useful
    }

    public synchronized void method2() {
        // do something useful
    }
    
    public void method3() {
        synchronized (this) {
            // do something useful
        }
    }
}

Если поток вызывает method1() и выполняет операторы внутри метода, никакой другой поток не может выполнять операторы внутри method2() или 
в синхронизированном блоке method3(), поскольку этот монитор уже занят. Потоки будут ждать освобождения монитора. Такое же поведение, 
когда используется монитор класса с синхронизованными статическими методами.

Поток не может получить блокировку, принадлежащую другому потоку. Но поток может получить блокировку, которой он уже владеет. 
Такое поведение называется реентерабельной синхронизацией(reentrant synchronization).

class SomeClass {

    public static synchronized void method1() {
        method2(); // legal invocation because a thread has acquired monitor of SomeClass
    }

    public static synchronized void method2() {
        // do something useful
    }
}

Код выше правильный. Когда поток находится внутри method1, он может вызывать method2, поскольку оба метода синхронизируются с одним и тем 
же объектом (SomeClass).

Иногда класс имеет несколько полей, которые никогда не используются вместе. Эти поля можно защитить с помощью одного и того же монитора, 
но в этом случае только один поток сможет получить доступ к одному из этих полей, несмотря на их независимость. Для повышения уровня 
параллелизма можно использовать идиому с дополнительными объектами в качестве мониторов. Вот пример: класс с двумя методами. Класс хранит 
количество вызовов каждого метода в специальном поле.

class SomeClass {

    private int numberOfCallingMethod1 = 0;
    private int numberOfCallingMethod2 = 0;

    final Object lock1 = new Object(); // an object for locking
    final Object lock2 = new Object(); // another object for locking

    public void method1() {
        System.out.println("method1...");

        synchronized (lock1) {
            numberOfCallingMethod1++;
        }
    }

    public void method2() {
        System.out.println("method2...");
        
        synchronized (lock2) {
            numberOfCallingMethod2++;
        }
    }
}

Как видите, в классе есть два дополнительных поля, которые являются замками для разделения мониторов на каждую критическую секцию.
Если у нас есть экземпляр класса, то один поток может работать внутри синхронизированного блока первого метода, и в то же время другой 
поток может работать внутри синхронизированного блока второго метода.

Помните, код, защищенный механизмом синхронизации, может одновременно выполняться только одним потоком. Это снижает параллелизм и 
отзывчивость программы. Не синхронизируйте весь свой код. Старайтесь использовать синхронизацию только тогда, когда это действительно 
необходимо. Определите небольшие части кода для синхронизации. Иногда лучше использовать блок синхронизации вместо синхронизации всего 
метода.


===================================================Collections and thread-safety===========================================================
Как вы уже знаете, несколько потоков могут одновременно обращаться к одним и тем же данным, что часто приводит к различным проблемам, если 
мы не используем какую-либо синхронизацию.

Аналогичные проблемы возникают, когда несколько потоков обращаются к коллекции:

- большинство классических коллекций, таких как ArrayList, LinkedList, HashMap и другие, не синхронизированы и, как следствие, не 
обеспечивают потокобезопасности;
- есть набор старых коллекций, таких как Vector, Stack и Hashtable, которые полностью синхронизированы и потокобезопасны, но имеют низкую 
производительность;
- когда один поток перебирает стандартную полностью синхронизированную коллекцию, а другой поток пытается добавить в нее новый элемент, 
мы получаем исключение времени выполнения, называемое ConcurrentModificationException.

Следующая программа демонстрирует состояние гонки, возникающее, когда два потока добавляют элементы в одну и ту же коллекцию.

import java.util.ArrayList;

public class NeedOfConcurrentCollectionsDemo {

    public static void main(String[] args) throws InterruptedException {
        ArrayList<Integer> numbers = new ArrayList<>();

        Thread writer = new Thread(() -> addNumbers(numbers));
        writer.start();

        addNumbers(numbers); // add number from the main thread

        writer.join(); // wait for writer thread

        System.out.println(numbers.size()); // the result can be any
    }

    private static void addNumbers(ArrayList<Integer> target) {
        for (int i = 0; i < 100_000; i++) {
            target.add(i);
        }
    }
}

Ожидаемый результат — 200000 (100000 + 100000), но на самом деле он меняется каждый раз, когда вы запускаете этот код. Некоторые элементы 
списка потеряны. Таким образом, использование стандартных коллекций в многопоточных средах без явной синхронизации — плохая идея. Опять 
же, такая синхронизация может привести к снижению производительности и трудно обнаруживаемым ошибкам в больших программах.

Чтобы избежать всех проблем, связанных с пользовательской синхронизацией, библиотека классов Java предоставляет альтернативные реализации 
коллекций, адаптированные для использования в многопоточных приложениях и полностью потокобезопасные. Вы можете найти их в пакете 
java.util.concurrent, который включает в себя списки, очереди, карты и другие наборы, упрощающие разработку современных приложений Java.

Эти параллельные коллекции позволяют во многих случаях избежать пользовательской синхронизации, а также обладают высокой 
производительностью, близкой к классическим коллекциям. Параллельные коллекции не используют ключевое слово synchronized, а полагаются на 
более сложные примитивы синхронизации и безблокировочный алгоритм, который позволяет им быть потокобезопасными и высокопроизводительными. 
Однако, если многопоточность вам особо не нужна, используйте классические коллекции, так как они все же более эффективны, чем параллельные.


========================================================CopyOnWriteArrayList===============================================================
Вы становитесь более опытным разработчиком и покоряете вершины многопоточности. И сегодня у нас в гостях класс CopyOnWriteArrayList, часть 
пакета java.util.concurrent. Посмотрите внимательно на название: ArrayList плюс метод копирования при записи. Вместе они дают вам 
потокобезопасное представление класса ArrayList.

Обратите внимание, что это «старый класс» — он существует с Java 5. Создание CopyOnWriteArrayList выглядит так же, как и для ArrayList:

CopyOnWriteArrayList<String> onWriteArrayList = new CopyOnWriteArrayList<>();

Сначала блокируется доступ к CopyOnWriteArrayList. Во-вторых, будет создана копия нашего списка. В-третьих, копия обновляется новым 
элементом. Тогда наш список становится «обновленной копией». И последний шаг — разблокировка. Этот метод называется Copy-On-Write и 
обеспечивает безопасность потоков. Все операции изменения списка (add, set, remove и т. д.) используют технику Copy-On-Write: они создают 
клонированную копию исходного списка. Из-за этого выполнение многих операций обновления может быть очень долгим.

Вот пример с двумя потоками: main и writer. Оба они добавляют числа в один и тот же CopyOnWriteArrayList.

public static void main(String[] args) throws InterruptedException {
    CopyOnWriteArrayList<Integer> onWriteArrayList = new CopyOnWriteArrayList<>();

    Thread writer = new Thread(() -> addNumbers(onWriteArrayList));
    writer.start();

    addNumbers(onWriteArrayList); // add numbers from the main thread

    writer.join(); // wait for writer thread to finish

    System.out.println(onWriteArrayList.size()); // the result is always the same
}

private static void addNumbers(CopyOnWriteArrayList<Integer> list) {
    for (int i = 0; i < 100_000; i++) {
        list.add(i);
    }
}

Если попробовать, результат всегда 200_000. Но что, если один поток добавил числа, а второй их удалил?

public static void main(String[] args) throws InterruptedException {
    CopyOnWriteArrayList<Integer> onWriteArrayList = new CopyOnWriteArrayList<>();


    Thread writer = new Thread(() -> addNumbers(onWriteArrayList));
    writer.start();

    removeNumbers(onWriteArrayList); // remove numbers from the main thread

    writer.join(); // wait for writer thread to finish

    System.out.println(onWriteArrayList.size()); // the result is always the same
}

private static void addNumbers(CopyOnWriteArrayList<Integer> list) {
    for (int i = 0; i < 100_000; i++) {
        list.add(i);
    }
}

private static void removeNumbers(CopyOnWriteArrayList<Integer> list) {
    int index = 0;
    while (index < 100_000) {
        if (!list.isEmpty()) {
            list.remove(0);
            index++;
        }
    }
}

В этом примере мы хотели добавить 100_000 номеров и удалить 100_000 номеров из того же списка. Все работает отлично благодаря технике 
copy-on-write. После добавления одного элемента удаление приостанавливается и наоборот. Но вы никогда не можете гарантировать, что 
выбранный индекс будет существовать в данный момент. Вот почему мы удаляли только элементы с нулевым индексом.

Если вы выполняете какую-либо операцию чтения при обновлении списка, вы всегда будете получать «старую» версию списка, то есть то, 
как ваш список выглядел до начала обновления.

Рассмотрим простой пример:

CopyOnWriteArrayList<Integer> onWriteArrayList = new CopyOnWriteArrayList<>();
onWriteArrayList.add(1);
onWriteArrayList.add(2);
onWriteArrayList.add(3);

Iterator<Integer> iterator = onWriteArrayList.iterator();

onWriteArrayList.add(4);

while(iterator.hasNext()) {
    System.out.print(iterator.next() + " "); // we will see only "1 2 3"
}

Как вы думаете, мы увидим три или четыре элемента? Ответ только три. Поскольку итератор создан и будет использовать неизменяемый список 
CopyOnWriteArrayList. Кроме того, из-за неизменности вы не можете использовать iterator.remove().

Что нужно помнить: 
- Он создает новую копию для каждой операции обновления (с помощью метода copy-on-write).
- Операции чтения возвращают «старую» версию списка, пока выполняется операция обновления. 
- Итератор использует неизменяемый снимок CopyOnWriteArrayList. 
- Частое обновление CopyOnWriteArrayList обходится очень дорого.



=========================================================Concurrent queues=================================================================
Одним из самых популярных видов параллельных коллекций является параллельная очередь. Она часто используется для организации связи между 
несколькими потоками внутри приложения путем обмена некоторыми данными(сообщения, задачи, единица работ или что-то еще). Для этого 
несколько потоков должны иметь ссылку на общую очередь и вызывать ее методы.

Вы уже знаете, что очередь — это коллекция, работающая по принципу «first-in-first-out principle» (FIFO): первый элемент, добавленный в 
очередь, будет первым удален.

Простейший тип параллельной очереди — ConcurrentLinkedQueue, очень похожий на стандартную очередь, но также потокобезопасный. У него есть 
два метода: add и offer для вставки элемента в конец очереди.

В следующем примере демонстрируется потокобезопасность этой параллельной очереди. Программа добавляет новые элементы, используя два потока, 
а затем выводит общее количество элементов в этой очереди:

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class ConcurrentQueueDemo {

    public static void main(String[] args) throws InterruptedException {
        // assigning thread-safe implementation
        Queue<Integer> numbers = new ConcurrentLinkedQueue<>();

        Thread writer = new Thread(() -> addNumbers(numbers));
        writer.start();

        addNumbers(numbers); // add number from the main thread

        writer.join(); // wait for writer thread

        System.out.println(numbers.size()); // it prints 200000
    }

    private static void addNumbers(Queue<Integer> target) {
        for (int i = 0; i < 100_000; i++) {
            target.add(i);
        }
    }
}

Неудивительно, что эта программа всегда печатает 200000, как и ожидалось, ни один элемент не потерян. Вы можете запускать эту программу 
столько раз, сколько вам нужно. Итак, ConcurrentLinkedQueue действительно потокобезопасен. Также нет исключения 
ConcurrentModificationException, если мы хотим выполнить итерацию по этой очереди.

Обратите внимание, что любая отдельная операция, предоставляемая этой очередью, является потокобезопасной. Однако, если мы сгруппируем 
такие операции вместе в один метод или последовательность операторов, вся группа операций не будет потокобезопасной.

Кроме того, не гарантируется, что массовые операции ConcurrentLinkedQueue, которые добавляют, удаляют или проверяют несколько 
элементов, такие как методы addAll, removeIf, forEach, будут выполняться атомарно.

Предположим, мы хотим обмениваться данными между двумя потоками, используя параллельную очередь. Один поток сгенерирует три числа, а 
другой поток примет эти числа и напечатает их. Существует метод под названием poll, используемый для получения текущего первого 
элемента параллельной очереди. Он возвращает элемент или null, если очередь пуста.

Вот фрагмент кода с дополнительными вызовами sleep, чтобы сделать вывод более предсказуемым. generator и poller взаимодействуют с 
использованием параллельной очереди, и данные не теряются, поскольку очередь полностью ориентирована на многопотоковое исполнение.

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;

public class GeneratorDemo {

    public static void main(String[] args) {
        Queue<Integer> queue = new ConcurrentLinkedQueue<>();

        Thread generator = new Thread(() -> {
            try {
                queue.add(10);
                TimeUnit.MILLISECONDS.sleep(10);
                queue.add(20);
                TimeUnit.MILLISECONDS.sleep(10);
                queue.add(30);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

        Thread poller = new Thread(() -> {
            int countRead = 0;
            while (countRead != 3) {
                Integer next = queue.poll();
                if (next != null) {
                    countRead++;
                }
                System.out.println(next);
                try {
                    TimeUnit.MILLISECONDS.sleep(10);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        generator.start();
        poller.start();
    }
}

Here is an example of an output:

null
10
20
null
30

Каждый стандартный метод параллельной очереди обеспечивает потокобезопасность. Однако, если вы хотите скомпоновать несколько методов 
вместе, таких гарантий нет.

Предположим, вы хотите добавить два элемента в параллельную очередь, чтобы они следовали друг за другом в этой очереди. Вот метод:

public static void addTwoElements(ConcurrentLinkedQueue<Integer> queue, int e1, int e2) {
    queue.add(e1); // (1)
    queue.add(e2); // (2)
}

Метод добавит два элемента один за другим только в случае одного потока записи. Если потоков записи больше, один поток может 
выполнить (1), а затем другой поток может вмешаться и сделать то же самое.

Только после него первый поток может выполнить (2). Таким образом, в некоторых случаях порядок может быть нарушен. Эта проблема 
возникает из-за того, что метод не является атомарным.

Как упоминалось выше, массовые методы, такие как addAll, также не являются атомарными и не помогают избежать этой проблемы.

queue.addAll(List.of(e1, e2));

Проблема решается только внешней синхронизацией, т.е.

public static synchronized void addTwoElements(ConcurrentLinkedQueue<Integer> queue, int e1, int e2) {
    queue.add(e1); // (1)
    queue.add(e2); // (2)
}

В этом случае вы должны быть уверены, что все операции, которые обновляют очередь, должны быть синхронизированы, а не только 
метод addTwoElements



===========================================================Thread-safe maps===================================================================
Потоко-безопасные map довольно популярны. Представьте, что вы реализуете кеш на основе map. У вас есть два потока записи и один поток чтения.
Если вы используете HashMap, нет гарантии, что поток чтения увидит обновления, сделанные потоком записи, сразу после внесения этих изменений.
Другая проблема заключается в том, что некоторые обновления потока записи могут быть потеряны или что измененные данные окажутся в 
несогласованном состоянии. Поэтому, если вашa map предназначенa для использования несколькими потоками, для вас есть два пути: 
ConcurrentHashMap и Collections.synchronizedMap.

Collections.synchronizedMap впервые появился в Java 2 и представляет собой статический метод стандартного класса java.util.Collections. Метод 
synchronizedMap принимает классическую map Java и возвращает потоко-безопасную map. 

Map<String, String> map = new HashMap<>();
map.put("a", "Apple");
map.put("b", "Banana");

Map<String, String> synchronizedMap = Collections.synchronizedMap(map); // contains the same as the input map

Используйте только возвращенную map, иначе вы не сможете обеспечить потокобезопасность.

Рассмотрим следующий пример. Здесь у нас есть два потока: writer, который добавляет в map положительные числа, и main поток, который 
добавляет в map отрицательные числа.

public static void main(String[] args) throws InterruptedException {
    Map<Integer, String> synchronizedNumbers = Collections.synchronizedMap(new HashMap<>());

    Thread writer = new Thread(() -> addPositiveNumbers(synchronizedNumbers));
    writer.start();

    addNegativeNumbers(synchronizedNumbers); // add negative numbers from the main thread

    writer.join(); // wait for the writer thread

    System.out.println(synchronizedNumbers.size()); // the size is always 200_000
}

private static void addPositiveNumbers(Map<Integer, String> target) {
    for (int i = 0; i < 100_000; i++) {
        target.put(i, "Number is " + i);
    }
}

private static void addNegativeNumbers(Map<Integer, String> target) {
    for (int i = -100_000; i < 0; i++) {
        target.put(i, "Number is " + i);
    }
}

Все работает так, как задумано, и результирующий размер map всегда одинаков. Однако если вы поэкспериментируете и используете классическую 
несинхронизированную map вместо synchronizedMap, размер возвращаемой map может быть совершенно непредсказуемым.

Вот основные особенности Collections.synchronizedMap, о которых следует помнить: 

- Синхронизация выполняется объектом.
- Методы (и, как следствие, все операции) synchronizedMap защищены блокировкой, которая обеспечивает потокобезопасный доступ. 
- Только один поток одновременно имеет доступ к map, другие потоки заблокированы.
- Чтобы перебрать синхронизированную карту, вам нужно использовать синхронизированный блок: 

synchronized (synchronizedMap) {
    Iterator<String> iterator = synchronizedMap.keySet().iterator();
    while (iterator.hasNext()) {
        // do important things
        iterator.next();
    }
}

Без блока synchronized итератор может генерировать исключение ConcurrentModificationException. Это произойдет, если один поток перебирает 
map, а другой поток пытается изменить нашу map.

Класс ConcurrentHashMap был создан, чтобы позволить нескольким потокам обращаться к одной и той же map, не блокируя друг друга, и, как 
следствие, увеличить их производительность. Вы можете найти ConcurrentHashMap в пакете java.util.concurrent. В этот момент вы можете 
задаться вопросом: как получилось, что класс ConcurrentHashMap стал таким замечательным? Секрет в Lock Striping. Этот метод означает, что 
механизм блокировки работает только с отдельными частями (или корзинами), а не со всей структурой данных. Когда поток обращается к страйпу, 
он блокирует только этот страйп, оставляя доступными другие страйпы.

За всю историю Java внутренняя реализация класса ConcurrentHashMap сильно изменилась. Таким, каким мы его знаем, начиная с Java 8. Давайте 
быстро рассмотрим, каким он был до Java 7 и как он изменился позже.

Во-первых, у обеих этих версий есть нечто общее: операции извлечения (например, get) не блокируются и выдают результаты самых последних 
операций обновления.

До Java 7 ConcurrentHashMap состоял из нескольких сегментов, где один сегмент представляет собой специализированную и одновременно читаемую 
хеш-таблицу. Количество сегментов задается в конструкторе ConcurrentHashMap и называется concurrencyLevel. По умолчанию равен 16.

Как вы можете догадаться из названия, concurrencyLevel представляет, сколько потоков может обновлять данные одновременно. Кроме того, 
concurrencyLevel является фиксированным, поэтому рекомендуется выбрать его, чтобы учесть точное количество потоков, которые когда-либо будут 
изменять ConcurrentHashMap одновременно.

ConcurrencyLevel и Segments все еще с нами, но мы используем их только для объединения с предыдущими версиями ConcurrentHashMap.

Начиная с Java 8 ConcurrentHashMap по умолчанию содержит 16 сегментов, столько же, сколько и в HashMap. Каждый сегмент представляет собой 
список ключ-значение. Вот основные особенности ConcurrentHashMap:

- Синхронизация выполняется на уровне сегмента. 
- Операции поиска не требуют блока.
- Итератор не будет выбрасывать исключение ConcurrentModificationException, когда один поток перебирает map, а другой поток пытается ее 
изменить. Однако нет гарантии, что итератор увидит изменения, сделанные другим потоком.
- Количество потоков, одновременно работающих с ConcurrentHashMap, может увеличиться, если увеличить размер ConcurrentHashMap.

Обратите внимание, что ConcurrentHashMap не позволяет использовать null в качестве ключа или значения.

Here is an example of usage ConcurrentHashMap:

public static void main(String[] args) throws InterruptedException {

    Map<Integer, String> map = new ConcurrentHashMap<>();

    Thread writer1 = new Thread(() -> addPositiveNumbers(map));
    Thread writer2 = new Thread(() -> addNegativeNumbers(map));

    writer1.start();
    writer2.start();

    // Here, in the main thread, we can use Iterator, retrieve values or update the map

    writer1.join(); // wait for writer1 thread
    writer2.join(); // wait for writer2 thread

    System.out.println(map.size()); // the result is always the same
}

private static void addPositiveNumbers(Map<Integer, String> target) {
    for (int i = 0; i < 100_000; i++) {
        target.put(i, "Number is " + i);
    }
}

private static void addNegativeNumbers(Map<Integer, String> target) {
    for (int i = -100_000; i < 0; i++) {
        target.put(i, "Number is " + i);
    }
}

Все это звучит здорово, но факты говорят громче слов, верно? Давайте сравним пропускную способность методов put и get для ConcurrentHashMap 
и synchronizedMap!

Чтобы было интереснее, протестируем пропускную способность для JDK 11 со случайными ключами. Обе карты будут иметь одинаковое количество 
элементов — 1000. Значения показанных диаграмм являются приблизительными. Они просто сравнивают два подхода. Не зацикливайтесь на цифрах, 
важна тенденция! Репрезентативный диапазон здесь составляет [1–8] потоков. После этого в игру вступают другие эффекты.

Как видите, ConcurrentHashMap имеет гораздо лучшую производительность в обоих сценариях. Неблокирующая операция get делает ConcurrentHashMap 
быстрее даже для одного потока. Затем пропускная способность постепенно увеличивается, а значения SynchronizedMap остаются неизменными.

Операция put в случае одного потока показывает такую ​​же пропускную способность, но дальше ситуация выглядит аналогично операции get.

Вот две потокобезопасные реализации интерфейса Map в стандартной библиотеке: ConcurrentHashMap и Collections.synchronizedMap. Они используют 
совершенно разные идеи для достижения одного и того же результата. Collections.synchronizedMap принимает классическую map Java и оборачивает 
ее методы синхронизированными блоками. ConcurrentHashMap использует метод чередования блокировок. Это позволяет нескольким потокам получать 
доступ к разным частям одной и той же map, не блокируя друг друга. На практике ConcurrentHashMap предпочтительнее из-за лучшей 
производительности. Он выполняет операции get и put быстрее, чем Collections.synchronizedMap.



=============================================================Executors========================================================================
Мы уже научились создавать потоки, расширяя класс Thread или реализуя интерфейс Runnable. Оба способа позволяют создать объект, 
представляющий поток, и запустить его для выполнения фрагмента кода в отдельном потоке. Хотя создать несколько потоков и запустить их 
несложно, это становится проблемой, когда в вашем приложении одновременно выполняются сотни или даже тысячи потоков.

Кроме того, Thread — довольно низкоуровневый класс, и его смешивание с высокоуровневым кодом вашего приложения может привести к нечитаемому 
коду и плохой архитектуре в будущем. Это также может привести к некоторым известным ошибкам, таким как вызов run() вместо start().

Для упрощения разработки многопоточных приложений в Java предусмотрена абстракция под названием ExecutorService (или просто executor). Он 
инкапсулирует один или несколько потоков в единый пул и помещает отправленные задачи во внутреннюю очередь для их выполнения с использованием 
потоков.

Такой подход четко изолирует задачи от потоков и позволяет сосредоточиться на задачах. Вам не нужно беспокоиться о создании потоков и 
управлении ими, потому что executor делает это за вас.

Все типы executors находятся в пакете java.util.concurrent. Вам нужно сначала импортировать его. Этот пакет также содержит удобный служебный 
класс Executors для создания различных типов ExecutorService.

Прежде всего, давайте создадим executor с ровно четырьмя потоками в пуле:

ExecutorService executor = Executors.newFixedThreadPool(4);

Он может выполнять несколько задач одновременно и ускорять вашу программу, выполняя несколько параллельных вычислений. Если один из потоков 
умирает, исполнитель создает новый. Далее рассмотрим, как определить необходимое количество потоков.

У executor есть метод submit, который принимает задачу Runnable для выполнения. Поскольку Runnable — это функциональный интерфейс, в качестве 
задачи можно использовать лямбда-выражение.

executor.submit(() -> System.out.println("Hello!"));

Конечно, мы можем объявить класс, реализующий Runnable для нашей задачи, а затем отправить объект этого класса. Но очень удобно использовать 
лямбда-выражения вместе с executor для коротких задач.

После вызова submit текущий поток не ожидает завершения задачи. Он просто добавляет задачу во внутреннюю очередь executor'a для асинхронного 
выполнения одним из потоков.

Executor продолжает работать после завершения задачи, поскольку потоки в пуле ожидают новых задач. Ваша программа никогда не остановится, 
пока работает хотя бы один executor. Существует два метода остановки executor'a:

- void shutdown() дожидается завершения всех запущенных задач и запрещает отправку новых задач; 
- List<Runnable> shutdownNow() немедленно останавливает все запущенные задачи и возвращает список задач, ожидающих выполнения.

Обратите внимание, что shutdown() не блокирует текущий поток, в отличие от функции join() для Thread. Если вам нужно дождаться завершения 
выполнения, вы можете вызвать awaitTermination(...) с указанным временем ожидания.

ExecutorService executor = Executors.newFixedThreadPool(4);

// submitting tasks

executor.shutdown();

boolean terminated = executor.awaitTermination(60, TimeUnit.MILLISECONDS);

if (terminated) {
    System.out.println("The executor was successfully stopped");
} else {
    System.out.println("Timeout elapsed before termination");
}

В следующем примере мы создаем один executor с пулом, состоящим из четырех потоков. Мы отправляем в него десять заданий, а затем анализируем 
результаты. Каждая задача печатает имя потока, который ее выполняет, а также имя задачи.

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorDemo {
    private final static int POOL_SIZE = 4;
    private final static int NUMBER_OF_TASKS = 10;
    
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(POOL_SIZE);

        for (int i = 0; i < NUMBER_OF_TASKS; i++) {
            int taskNumber = i;
            executor.submit(() -> {
                String taskName = "task-" + taskNumber;
                String threadName = Thread.currentThread().getName();
                System.out.printf("%s executes %s\n", threadName, taskName);
            });
        }

        executor.shutdown();
    }
}

Если вы запустите эту программу много раз, вы получите другой результат. Ниже приведен один из возможных: 

pool-1-thread-1 executes task-0
pool-1-thread-2 executes task-1
pool-1-thread-4 executes task-3
pool-1-thread-3 executes task-2
pool-1-thread-3 executes task-7
pool-1-thread-3 executes task-8
pool-1-thread-3 executes task-9
pool-1-thread-1 executes task-6
pool-1-thread-4 executes task-5
pool-1-thread-2 executes task-4

Это наглядно демонстрирует, что executor использует все четыре потока для решения задач. Количество решаемых задач каждым потоком может 
варьироваться. Нет никаких гарантий, что мы получим.

Если вы не знаете, сколько потоков требуется в вашем пуле, вы можете взять количество доступных процессоров в качестве размера пула.

int poolSize = Runtime.getRuntime().availableProcessors();
ExecutorService executor = Executors.newFixedThreadPool(poolSize);

Мы рассмотрели наиболее часто используемый executor с фиксированным размером пула. Вот еще несколько видов:

1) Executor с одним потоком

Самый простой executor имеет только один поток в пуле. Этого может быть достаточно для асинхронного выполнения редко отправляемых и небольших 
задач.

ExecutorService executor = Executors.newSingleThreadExecutor();

Важно: один поток может не успеть обработать все поступающие задачи, и очередь сильно разрастется, потребляя всю память.

2) Executor с растущим пулом

Существует также executor, который автоматически увеличивает количество потоков по мере необходимости и повторно использует ранее созданные 
потоки.

ExecutorService executor = Executors.newCachedThreadPool();

Обычно это может повысить производительность программ, выполняющих множество краткосрочных асинхронных задач. Но это также может привести к 
проблемам, когда количество потоков увеличивается слишком сильно.

3) Executor, который планирует задачу

Если вам нужно выполнять одну и ту же задачу периодически или только один раз после заданной задержки, используйте этот executor:

ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

Метод scheduleAtFixedRate отправляет периодическую задачу Runnable, которая становится доступной сначала после заданного initDelay, а затем с 
заданным периодом. Вот краткий пример с планированием:

ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
executor.scheduleAtFixedRate(() -> 
        System.out.println(LocalTime.now() + ": Hello!"), 1000, 1000, TimeUnit.MILLISECONDS);

Here is a fragment of the output:

02:30:06.375392: Hello!
02:30:07.375356: Hello!
02:30:08.375376: Hello!
...and even more...

Этот executor также имеет метод с именем schedule, который запускает задачу только один раз после заданной задержки, и другой метод 
scheduleWithFixedDelay, который запускает задачу с фиксированным ожиданием после завершения предыдущей.

В наших примерах мы часто игнорируем обработку ошибок, чтобы упростить код. Здесь мы демонстрируем одну возможность, связанную с обработкой 
исключений в executor (а именно, unchecked). Как вы думаете, что напечатает следующий код?

ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(() -> System.out.println(2 / 0));

Он вообще ничего не напечатает, включая исключения! Вот почему принято заключать задачу в блок try-catch, чтобы не потерять исключение.

ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(() -> {
    try {
        System.out.println(2 / 0);
    } catch (Exception e) {
        e.printStackTrace();
    }
});

Теперь вы увидите исключение. В реальных приложениях для его вывода лучше использовать какое-нибудь логирование. Обратите внимание, что 
executor все еще будет работать после выбрасывания исключения, потому что он динамически создает новый поток.



================================================================Timers========================================================================
Класс Timer используется в ситуациях, когда мы хотим выполнять действия, связанные со временем, такие как планирование задачи для запуска в 
определенное время или повторение задачи через определенный интервал времени. Когда мы создаем Timer, мы указываем ему, какой код запускать, 
используя специальный класс TimerTask. Этот класс реализует метод run, который определяет код, который выполняется при срабатывании Timer. 
Этот код запускается в отдельном потоке от кода, создающего Timer. Чтобы реализовать Timer, мы начнем с создания TimerTask с кодом, который 
будет запускаться при срабатывании таймера. Пример ниже демонстрирует, как мы можем создать TimerTask, который будет печатать «Hello!» 
каждый раз, когда срабатывает Timer.

import java.util.Timer;
import java.util.TimerTask;

class TimerCode extends TimerTask {
    public void run() {
        System.out.println("Hello!");
    }
}

После того, как мы реализовали TimerTask, мы можем настроить таймер для запуска задачи по мере необходимости.

Мы можем запланировать выполнение TimerTask, используя метод schedule нашего объекта Timer. У этого метода есть много разных режимов, которые 
мы можем использовать, но для начала мы рассмотрим, как запланировать однократное выполнение задачи в определенную дату и время.

Предположим, что у нас есть некоторый код, который мы хотим запустить через 2 секунды после того, как программа будет выполнена. Для этого 
нам нужно сначала получить текущую дату и время, а затем добавить к ним 2 секунды. Получив этот результат, мы можем запланировать наш таймер 
для выполнения кода в результате. Код ниже показывает, как это можно сделать, используя TimerTask, который мы определили ранее.

public class Main {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask task = new TimerCode();

        LocalDateTime timeToExecute = LocalDateTime.now().plusSeconds(2);
        Date execTime = Date.from(timeToExecute.atZone(ZoneId.systemDefault()).toInstant());
        timer.schedule(task, execTime);
    }
}

В этом примере мы начинаем с создания объекта LocalDateTime, который хранит текущее время в системе пользователя плюс две секунды, чтобы 
получить время, равное двум секундам с момента запуска приложения. Затем мы преобразуем его в объект Date, чтобы его можно было использовать 
с методом schedule. Когда мы конвертируем LocalDateTime в Date, мы указываем использовать ZoneId.systemDefault(). Это гарантирует, что 
созданная дата соответствует часовому поясу человека, запускающего приложение. Результатом этого кода является то, что наш текст «Hello» 
будет напечатан на экране через 2 секунды после запуска приложения.

В последнем разделе мы увидели, как можно использовать метод schedule для однократного запуска задачи в определенное время и дату. В этом 
разделе мы рассмотрим, как мы можем создать задачу, которая запускается в определенное время и дату, затем повторяется с фиксированным 
интервалом. 

Есть два способа, которыми мы можем настроить график запуска. Первый — указать задержку с момента запуска программы, а затем интервал 
повторения задачи. Например, если бы мы хотели запустить задачу через 2 секунды после запуска программы и повторять ее каждые 3 секунды, 
мы бы использовали код, показанный ниже.

public class Main {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask task = new TimerCode();

        timer.schedule(task, 2000, 3000);
    }
}

Обратите внимание, что метод schedule ожидает, что время будет предоставлено в миллисекундах, поэтому мы используем 2000 миллисекунд для 
представления 2 секунд и 3000 миллисекунд для представления 3 секунд. Если мы хотим начать выполнение нашего кода в определенную дату и 
время, как раньше, мы можем просто добавить скорость повторения в качестве третьего аргумента для метода schedule. В приведенном ниже коде 
показано, как мы можем добавить к нашей задаче фиксированную скорость в 2 секунды.

public class Main {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask task = new TimerCode();

        LocalDateTime timeToExecute = LocalDateTime.now().plusSeconds(2);
        Date execTime = Date.from(timeToExecute.atZone(ZoneId.systemDefault()).toInstant());
        timer.schedule(task, execTime, 2000);
    }
}

Как только мы запланируем TimerTask с фиксированной скоростью, мы можем в конечном итоге остановить его выполнение. Для этого мы можем 
использовать метод cancel, который отменит все задачи, которые в данный момент есть у таймера. Для этого нам просто нужно вызвать метод 
cancel для TimerTask, который мы хотим остановить.

public class Main {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask task = new TimerCode();

        timer.schedule(task, 2000, 3000);
        task.cancel();
    }
}

Мы также можем использовать метод cancel для нашего объекта Timer, чтобы отменить все задачи, связанные с Timer. Это идеально, если вы 
хотите отменить несколько задач одновременно. В следующем примере показано, как мы можем использовать метод отмены с нашим объектом Timer.

public class Main {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask task = new TimerCode();
        TimerTask task2 = new TimerCode();

        timer.schedule(task2, 0, 2000);
        timer.schedule(task, 0, 1000);
        timer.cancel();
    }
}

В этом примере и task, и task2 будут остановлены, как только будет вызван timer.cancel().

В дополнение к отмене задач мы также хотим рассмотреть, что произойдет, если задача неожиданно завершится сбоем из-за исключения. Если бы мы 
создали TimerTask, который выбрасывает исключение, мы увидим, что когда выюрасывается исключение, TimerTask перестает работать, и наша 
программа аварийно завершает работу. В идеале мы хотели бы иметь возможность восстановиться после исключения, если оно произойдет. Для этого 
мы можем обернуть наш код TimerTask в try-catch.

class TimerCode extends TimerTask {
    public void run() {
        try {
            throw new IllegalArgumentException();
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }
}

Когда этот код выбрасывает исключение, он печатает сообщение, а затем снова запускается в следующее запланированное время. Это идеально 
подходит для ситуаций, когда мы можем искать файл обновления, который может еще не существовать. Если файл не найден, мы перехватываем 
исключение и повторяем попытку позже, когда файл может быть доступен. В некоторых случаях мы можем захотеть отменить TimerTask, если он 
обнаружит исключение. Для этого мы можем использовать метод cancel, рассмотренный ранее.

class TimerCode extends TimerTask {
    public void run() {
        try {
            throw new IllegalArgumentException();
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            this.cancel();
        }
    }
}

С этим кодом наша TimerTask теперь будет отменяться, как только возникнет исключение.

schedule(TimerTask task, Date time)			- Run a timer task once at a specified date
schedule(TimerTask task, date time, long period)	- Start a timer task at a specified date, then repeat at a fixed interval
schedule(TimerTask task, long delay)			- Run a timer task once at a specified delay from when it is created
schedule(TimerTask task, long delay, long period)	- Run a timer task after a specified delay, then repeat at a fixed interval


============================================================Interruptions=====================================================================
Поток завершается, когда его метод run останавливается. Иногда вам может потребоваться завершить выполняемую задачу, например, при завершении 
работы приложения с несколькими потоками. Java предоставляет механизм прерывания, для запроса остановки потока или выполнения других действий. 
Прерывание не заставляет поток реагировать немедленно, но уведомляет его о таком требовании.

Вызов метода interrupt() для экземпляра класса Thread устанавливает его флаг прерывания в значение true.

Thread thread = ...
thread.interrupt(); // interrupt this thread

Реакция на это событие определяется самим прерванным потоком. Одним из распространенных случаев для этого является остановка выполнения. Хотя 
поток может просто игнорировать его. 

В зависимости от текущего состояния потока прерывания обрабатываются по-разному. Вызов thread.interrupt() вызовет InterruptedException, если 
поток спит или ожидает завершения с помощью join(). В противном случае единственное, что произойдет, это то, что флаг прерывания будет 
установлен в значение true. Вот пример того, как поток может обрабатывать прерывание:

public class CustomThread extends Thread {

    @Override
    public void run() {
        while (!isInterrupted()) {
            try {
                doAction();
                Thread.sleep(1000); // it may throw InterruptedException
            } catch (InterruptedException e) {
                System.out.println("sleeping was interrupted");
                break; // stop the loop
            }
        }
        System.out.printf("%s finished", getName());
    }

    private void doAction() {
        // something useful
    }
}

Когда этот поток выполняется, прерывание может произойти на любом операторе внутри метода run, включая проверку состояния цикла, выполнение 
doAction и во время сна. Если поток спит, Thread.sleep(1000) выдает InterruptedException, которое обрабатывается. В остальных случаях цикл 
останавливается по условию на следующей итерации.

Если вы предпочитаете реализовать Runnable, а не расширять Thread напрямую, вы можете использовать статический метод Thread.interrupted() 
внутри метода run. Основное различие между этим и предыдущим методом заключается в том, что статический метод сбрасывает статус прерывания 
на false.

В качестве примера рассмотрим задачу, которая считает числа, пока поток не прерван.

class CountingTask implements Runnable {

    @Override
    public void run() {
        System.out.println("Start counting");
        int i = 1; // the first number to print

        try {
            while (!Thread.interrupted()) {
                System.out.println(i);
                i++;
                Thread.sleep(1000); 
            }
        } catch (InterruptedException e) {
            System.out.println("Sleeping was interrupted");
        }
        System.out.println("Finishing");
    }
}

В этой реализации сон занимает почти все время, и во время сна часто будет происходить прерывание. Если программа не выводит строку 
"Сон был прерван", это означает, что поток был прерван во время работы, а не сна.

В main методе мы создаем поток для выполнения задачи, а затем прерываем поток.

public class InterruptionDemo {

    public static void main(String[] args) throws InterruptedException {
        Thread counter = new Thread(new CountingTask());
        counter.start();
        Thread.sleep(5000L);
        counter.interrupt();
        counter.join();
    }
}

Обратите внимание, что в main методе оба метода sleep и join могут также генерировать InterruptedException при прерывании. 
Обработка этого была опущена здесь только для краткости.

The program output is:

Start counting
1
2
3
4
Sleeping was interrupted
Finishing


============================================================Callable and Future===============================================================
Иногда нужно не только выполнить задачу в Executor, но и вернуть результат этой задачи в вызывающий код. Это возможно, но неудобно делать с 
Runnable.

Чтобы упростить его, Executor поддерживает другой класс задач с именем Callable, который возвращает результат и может генерировать исключение. 
Этот интерфейс принадлежит пакету java.util.concurrent. Давайте посмотрим на него.

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
} 

Как видите, это универсальный интерфейс, в котором параметр типа V определяет тип возращаемого результата. Поскольку это функциональный 
интерфейс, мы можем использовать его вместе с лямбда-выражениями и method references, а также с реализацией классов.

Вот Callable, который эмулирует длительную задачу и возвращает число, которое было «вычислено».

Callable<Integer> generator = () -> {
    TimeUnit.SECONDS.sleep(5);
    return 700000;
};

Тот же самый код можно переписать, используя наследование, которое является более шаблонным, чем лямбда.

Когда мы отправляем Callable в Executor, он не может вернуть результат напрямую, поскольку метод submit() не ожидает завершения задачи.
Вместо этого Executor возвращает специальный объект с именем Future, в котором заключен фактический результат, который может еще даже не 
существовать. Этот объект представляет результат асинхронного вычисления (задачи).

ExecutorService executor = Executors.newSingleThreadExecutor();

Future<Integer> future = executor.submit(() -> {
    TimeUnit.SECONDS.sleep(5);
    return 700000;
});

Пока задача не завершена, фактического результата в future не будет. Для проверки есть метод isDone(). Скорее всего, он вернет false, если 
вы вызовете его сразу после получения нового future.

System.out.println(future.isDone()); // most likely it is false

Результат можно получить из future с помощью метода get.

int result = future.get();

Он возвращает результат, когда вычисление завершено, или блокирует текущий поток и ожидает результата. Этот метод может генерировать два 
проверяемых исключения: ExecutionException и InterruptedException, перехват которых мы опускаем здесь для краткости.

Если отправленная задача выполняет бесконечный цикл или слишком долго ожидает внешнего ресурса, поток, вызывающий get, будет все это время 
блокироваться. Чтобы предотвратить это, существует также перегруженная версия get с тайм-аутом ожидания.

int result = future.get(10, TimeUnit.SECONDS); // it blocks the current thread 

В этом случае вызывающий поток ожидает завершения вычислений не более 10 секунд. Если тайм-аут заканчивается, метод выдает TimeoutException.

Класс Future предоставляет метод экземпляра с именем Cancel, который пытается отменить выполнение задачи. Этот способ сложнее, чем может 
показаться на первый взгляд. Попытка будет неудачной, если задача уже выполнена, уже отменена или не может быть отменена по какой-либо другой 
причине. В случае успеха и если эта задача еще не запущена при вызове метода, она никогда не запустится.

Метод принимает boolean параметр, который определяет, должен ли поток, выполняющий эту задачу, быть прерван при попытке остановить задачу 
(другими словами, остановить ли уже запущенную задачу или нет).

future1.cancel(true);  // try to cancel even if the task is executing now
future2.cancel(false); // try to cancel only if the task is not executing

Поскольку передача значения true связана с прерываниями, отмена выполняемой задачи гарантируется только в том случае, если она правильно 
обрабатывает InterruptedException и проверяет флаг Thread.currentThread().isInterrupted().

Если кто-то вызывает future.get() при успешно отмененной задаче, метод выдает непроверяемое исключение CancellationException. Если вы не 
хотите иметь с этим дело, вы можете проверить, была ли задача отменена, вызвав isCancelled().

Подход, который мы здесь изучаем, позволяет нам сделать что-то полезное между получением Future и получением фактического результата. В этот 
промежуток времени, мы можем отправить в executor несколько задач и только после этого дождаться получения всех результатов.

ExecutorService executor = Executors.newFixedThreadPool(4);

Future<Integer> future1 = executor.submit(() -> {
    TimeUnit.SECONDS.sleep(5);
    return 700000;
});

Future<Integer> future2 = executor.submit(() -> {
    TimeUnit.SECONDS.sleep(5);
    return 900000;
});

int result = future1.get() + future2.get(); // waiting for both results

System.out.println(result); // 1600000

Если у вас современный компьютер, эти задачи могут выполняться параллельно.

В дополнение ко всем функциям, описанным выше, есть два полезных метода для отправки пакетов Callable в executor.

- invokeAll принимает подготовленный набор вызываемых объектов и возвращает коллекцию Future; 
- invokeAny также принимает набор вызываемых объектов и возвращает результат (не Future!) того, который успешно завершился.

Оба метода также имеют перегруженные версии, допускающие тайм-аут выполнения, который часто необходим в реальной жизни.

Предположим, что нам нужно вычислить несколько чисел в отдельных задачах, а затем просуммировать числа в основном потоке. Это легко сделать 
с помощью метода invokeAll.

ExecutorService executor = Executors.newFixedThreadPool(4);
List<Callable<Integer>> callables =
        List.of(() -> 1000, () -> 2000, () -> 1500); // three "difficult" tasks

List<Future<Integer>> futures = executor.invokeAll(callables);
int sum = 0;
for (Future<Integer> future : futures) {
   sum += future.get(); // blocks on each future to get a result
}
System.out.println(sum);

Подытожим информацию о Callable и Future. Чтобы получить результат выполнения асинхронной задачи в ExecutorService, вам необходимо выполнить 
три шага:

1) создать объект, представляющий Callable задачу; 
2) отправить задачу в ExecutorService и получить Future; 
3) вызовите get, чтобы получить фактический результат, когда вам это нужно.

Использование Future позволяет нам не блокировать текущий поток, пока мы не захотим получить результат задачи. Также можно запустить 
несколько задач, а затем получить все результаты, чтобы агрегировать их в текущем потоке. В дополнение к тому, что ваша программа станет 
более отзывчивой, это ускорит ваши вычисления, если ваш компьютер поддерживает параллельное выполнение потоков.

Пример 1

class FutureUtils {

    public static int executeCallableObjects(List<Future<Callable<Integer>>> items) {
        int sum = 0;
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Collections.reverse(items);
        List<Callable<Integer>> callables = new ArrayList<>();

        for (Future<Callable<Integer>> el : items) {
            try {
                callables.add(el.get());
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (ExecutionException e) {
                throw new RuntimeException(e);
            }
        }

        List<Future<Integer>> futures = null;
        try {
            futures = executor.invokeAll(callables);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        for (Future<Integer> future : futures) {
            try {
                sum += future.get();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (ExecutionException e) {
                throw new RuntimeException(e);
            }
        }

        executor.shutdown();
        return sum;
    }

}

